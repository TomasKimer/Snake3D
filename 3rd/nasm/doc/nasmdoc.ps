%!PS-Adobe-3.0
%%Pages: 210
%%BoundingBox: 0 0 595 792
%%Creator: (NASM psflow.pl)
%%DocumentData: Clean7Bit
%%DocumentFonts: Times-Italic Times-Bold Courier Times-Roman Courier-Bold Times-BoldItalic
%%DocumentNeededFonts: Times-Italic Times-Bold Courier Times-Roman Courier-Bold Times-BoldItalic
%%Orientation: Portrait
%%PageOrder: Ascend
%%EndComments
%%BeginProlog
/tocind 12 def
/pymarg 50 def
/idxindent 24 def
/pageheight 792 def
/pagewidth 595 def
/idxcolumns 2 def
/tocpnz 24 def
/bulladj 12 def
/plmarg 50 def
/idxgutter 24 def
/lmarg 100 def
/topmarg 100 def
/botmarg 100 def
/prmarg 0 def
/startcopyright 75 def
/tocdots 8 def
/rmarg 50 def
/idxspace 24 def
/colorlinks false def
/NASMEncoding [ /.notdef  /.notdef  /.notdef  /.notdef  /.notdef  
 /.notdef  /.notdef  /.notdef  /.notdef  /.notdef  /.notdef  /.notdef  
 /.notdef  /.notdef  /.notdef  /.notdef  /dotlessi /grave /acute 
 /circumflex /tilde /macron /breve /dotaccent /dieresis /.notdef  /ring 
 /cedilla /.notdef  /hungarumlaut /ogonek /caron /space /exclam 
 /quotedbl /numbersign /dollar /percent /ampersand /quoteright 
 /parenleft /parenright /asterisk /plus /comma /minus /period /slash 
 /zero /one /two /three /four /five /six /seven /eight /nine /colon 
 /semicolon /less /equal /greater /question /at /A /B /C /D /E /F /G /H 
 /I /J /K /L /M /N /O /P /Q /R /S /T /U /V /W /X /Y /Z /bracketleft 
 /backslash /bracketright /asciicircum /underscore /quoteleft /a /b /c 
 /d /e /f /g /h /i /j /k /l /m /n /o /p /q /r /s /t /u /v /w /x /y /z 
 /braceleft /bar /braceright /asciitilde /.notdef  /.notdef  /.notdef  
 /quotesinglbase /florin /quotedblbase /ellipsis /dagger /dbldagger 
 /circumflex /perthousand /Scaron /guilsinglleft /OE /.notdef  /Zcaron 
 /.notdef  /.notdef  /grave /quotesingle /quotedblleft /quotedblright 
 /bullet /endash /emdash /tilde /trademark /scaron /guilsignlright /oe 
 /.notdef  /zcaron /Ydieresis /space /exclamdown /cent /sterling 
 /currency /yen /brokenbar /section /dieresis /copyright /ordfeminine 
 /guillemotleft /logicalnot /hyphen /registered /macron /degree 
 /plusminus /twosuperior /threesuperior /acute /mu /paragraph 
 /periodcentered /cedilla /onesuperior /ordmasculine /guillemotright 
 /onequarter /onehalf /threequarters /questiondown /Agrave /Aacute 
 /Acircumflex /Atilde /Adieresis /Aring /AE /Ccedilla /Egrave /Eacute 
 /Ecircumflex /Edieresis /Igrave /Iacute /Icircumflex /Idieresis /Eth 
 /Ntilde /Ograve /Oacute /Ocircumflex /Otilde /Odieresis /multiply 
 /Oslash /Ugrave /Uacute /Ucircumflex /Udieresis /Yacute /Thorn 
 /germandbls /agrave /aacute /acircumflex /atilde /adieresis /aring /ae 
 /ccedilla /egrave /eacute /ecircumflex /edieresis /igrave /iacute 
 /icircumflex /idieresis /eth /ntilde /ograve /oacute /ocircumflex 
 /otilde /odieresis /divide /oslash /ugrave /uacute /ucircumflex 
 /udieresis /yacute /thorn /ydieresis ] def
/nasmenc {
  findfont dup length dict begin
    { 1 index /FID ne {def}{pop pop} ifelse } forall
    /Encoding NASMEncoding def
    currentdict
  end
  definefont pop
} def
/Times-Italic-NASM /Times-Italic nasmenc
/Times-Bold-NASM /Times-Bold nasmenc
/Courier-NASM /Courier nasmenc
/Times-Roman-NASM /Times-Roman nasmenc
/Courier-Bold-NASM /Courier-Bold nasmenc
/Times-BoldItalic-NASM /Times-BoldItalic nasmenc
/tfont0 /Times-Bold-NASM findfont 20 scalefont def
/tfont1 /Times-BoldItalic-NASM findfont 20 scalefont def
/tfont2 /Courier-Bold-NASM findfont 20 scalefont def
/tfont [tfont0 tfont1 tfont2] def
/cfont0 /Times-Bold-NASM findfont 18 scalefont def
/cfont1 /Times-BoldItalic-NASM findfont 18 scalefont def
/cfont2 /Courier-Bold-NASM findfont 18 scalefont def
/cfont [cfont0 cfont1 cfont2] def
/hfont0 /Times-Bold-NASM findfont 14 scalefont def
/hfont1 /Times-BoldItalic-NASM findfont 14 scalefont def
/hfont2 /Courier-Bold-NASM findfont 14 scalefont def
/hfont [hfont0 hfont1 hfont2] def
/sfont0 /Times-Bold-NASM findfont 12 scalefont def
/sfont1 /Times-BoldItalic-NASM findfont 12 scalefont def
/sfont2 /Courier-Bold-NASM findfont 12 scalefont def
/sfont [sfont0 sfont1 sfont2] def
/bfont0 /Times-Roman-NASM findfont 11 scalefont def
/bfont1 /Times-Italic-NASM findfont 11 scalefont def
/bfont2 /Courier-NASM findfont 11 scalefont def
/bfont [bfont0 bfont1 bfont2] def
/bullet [(\225)] def
% $Id: head.ps,v 1.8 2002/05/20 19:50:34 hpa Exp $
%
% PostScript header for NASM documentation
%

% Avoid barfing on old PS implementations
/pdfmark where
{pop} {userdict /pdfmark /cleartomark load put} ifelse
/setpagedevice where
{pop} {userdict /setpagedevice /pop load put} ifelse

% Useful definition
/space 32 def

%
% This asks the PostScript interpreter for the proper size paper
%
/setpagesize {
  1 dict dup /PageSize [pagewidth pageheight] put setpagedevice
} def

%
% Code to handle links
%
/min { 2 copy gt { exch } if pop } def
/max { 2 copy lt { exch } if pop } def

/lkbegun 0 def
/lktype null def
/lkury 0 def
/lkurx 0 def
/lklly 0 def
/lkllx 0 def
/lkxmarg 1 def	% Extra space for link in x dir
/lkymarg 1 def	% Extra space for link in y dir
/lktarget () def

% target type --
/linkbegin {
  userdict begin
    /lkbegun 1 def
    /lktype exch def
    /lktarget exch def
    colorlinks { 0 0 0.4 setrgbcolor } if
  end
} def

% target --
/linkbegindest {
  /Dest linkbegin
} def

% uristring --
/linkbeginuri {
  /URI linkbegin
} def

% pageno --
/linkbeginpage {
  /Page linkbegin
} def

% string spacepadding --
/linkshow {
  userdict begin
    /lspad exch def /lss exch def
    lkbegun 0 ne {
      gsave lss true charpath flattenpath pathbbox grestore
      lkbegun 1 eq {
        /lkury exch def
        lss spacecount lspad mul add /lkurx exch def
        /lklly exch def
        /lkllx exch def
        /lkbegun 2 def
      } {
        lkury max /lkury exch def
        lss spacecount lspad mul add lkurx max /lkurx exch def
        lklly min /lklly exch def
        lkllx min /lkllx exch def
      } ifelse
    } if
    lspad 0 space lss widthshow
  end
} def

% --
/linkend {
  userdict begin
    [ lktype /URI eq {
        /Action 2 dict dup /Subtype /URI put dup /URI lktarget put
      } {
	/Dest lktarget
      } ifelse
      /Border [0 0 0]
      /Rect [ lkllx lkxmarg sub
              lklly lkymarg sub
              lkurx lkxmarg add
              lkury lkymarg add ]
      /Subtype /Link
      /ANN pdfmark
    /lkbegun 0 def
    colorlinks { 0 setgray } if
  end
} def

% targetname --
/linkdest {
  [ /Dest 3 -1 roll
    /View [ /XYZ currentpoint null ]
    /DEST pdfmark
} def

% A "fontset" is an array of fonts; a "stream" is an array of strings
% and numbers or procedures:
% [ 0 (Foo) ( ) (mani) ( ) 1 (padme) 0 ( ) (hum.) ]
% A number choses a font from the current fontset.
% A procedure is invoked as-is when printing the stream.
%
% When printing justified, an equal amount of space is added in
% between each string.

% string -- spacecount
% Count space characters in a string
/spacecount {
  0 exch {
    space eq { 1 add } if
  } forall
} def

% stream fontset -- spacecount width
% Get the width of a stream in the given fontset, and the
% number of space characters in the stream
/streamwidth {
  gsave
    6 dict begin
      /f exch def
      /w 0 def
      /s 0 def
      f 0 get setfont
      /integertype {
        f exch get setfont
      } def
      /stringtype {
        dup stringwidth pop w add /w exch def
        spacecount s add /s exch def
      } def
      /arraytype { pop } def
      % The input stream is on the top of the stack now
      {
        dup type exec
      } forall
      s w
    end
  grestore
} def

% stream fontset spacer --
% Show the stream in the given fontset, but add a certain amount
% of space to each space character
/showstreamspc {
  5 dict begin
    /spc exch def
    /f exch def
    f 0 get setfont
    /integertype {
      f exch get setfont
    } def
    /stringtype {
      spc linkshow
    } def
    /arraytype {
      exec
    } def
    % Now stream is on the top of the stack
    {
      dup type exec
    } forall
  end
} def

% stream fontset --
% Show the stream in the given fontset, with no extra spacing
/showstream {
  0 showstreamspc
} def

% stream fontset totalspace --
% Show the stream justified to fit into a certain number of pixels
/showstreamjust {
  userdict begin
    /ts exch def /fs exch def /st exch def
      st fs
        st fs streamwidth ts exch sub exch
	dup 0 gt { div } { pop } ifelse
      showstreamspc
    end
} def

/bullmarg lmarg bulladj add def
/lwidth pagewidth lmarg sub rmarg sub def
/bwidth lwidth bulladj sub def

%
% The various paragraph types
% The number at the end indicates start (1) of para, end (2) of para
%
/chapline {
	currentpoint exch pop 10 sub lmarg exch moveto
	0 setlinecap 3 setlinewidth
	lwidth 0 rlineto stroke
} def

/chap0 { lmarg exch moveto cfont lwidth showstreamjust } def
/chap1 { lmarg exch moveto cfont lwidth showstreamjust } def
/chap2 { lmarg exch moveto cfont showstream chapline } def
/chap3 { lmarg exch moveto cfont showstream chapline } def

/appn0 {chap0} def
/appn1 {chap1} def
/appn2 {chap2} def
/appn3 {chap3} def

% lbl ypos fontset -- ypos
/headlbl {
  3 -1 roll [exch (  )] exch % ypos strm fontset
  2 copy % ypos strm fontset strm fontset
  streamwidth % ypos strm fontset spccount width
  lmarg exch sub % ypos strm fontset spccount xpos
  4 index % ypos strm fontset spccount xpos ypos
  moveto % ypos strm fontset spccount
  pop % ypos strm fontset spccount
  showstream % ypos
} def

/head0 { lmarg exch moveto hfont lwidth showstreamjust } def
/head1 { hfont headlbl lmarg exch moveto hfont lwidth showstreamjust } def
/head2 { lmarg exch moveto hfont showstream } def
/head3 { hfont headlbl lmarg exch moveto hfont showstream } def

/subh0 { lmarg exch moveto sfont lwidth showstreamjust } def
/subh1 { sfont headlbl lmarg exch moveto sfont lwidth showstreamjust } def
/subh2 { lmarg exch moveto sfont showstream } def
/subh3 { sfont headlbl lmarg exch moveto sfont showstream } def

/norm0 { lmarg exch moveto bfont lwidth showstreamjust } def
/norm1 { lmarg exch moveto bfont lwidth showstreamjust } def
/norm2 { lmarg exch moveto bfont showstream } def
/norm3 { lmarg exch moveto bfont showstream } def

/code0 { lmarg exch moveto bfont showstream } def
/code1 { lmarg exch moveto bfont showstream } def
/code2 { lmarg exch moveto bfont showstream } def
/code3 { lmarg exch moveto bfont showstream } def

/bull0 { bullmarg exch moveto bfont bwidth showstreamjust } def
/bull1 { dup lmarg exch moveto bullet bfont showstream
	 bullmarg exch moveto bfont bwidth showstreamjust } def
/bull2 { bullmarg exch moveto bfont showstream } def
/bull3 { dup lmarg exch moveto bullet bfont showstream
	 bullmarg exch moveto bfont showstream } def

/tocw0 lwidth tocpnz sub def
/tocw1 tocw0 tocind sub def
/tocw2 tocw1 tocind sub def

/tocx0 lmarg def
/tocx1 tocx0 tocind add def
/tocx2 tocx1 tocind add def

/tocpn {
  bfont0 setfont
  3 dict begin
    /s exch def
    /x s stringwidth pop pagewidth rmarg sub exch sub def
    currentpoint /y exch def
    lmarg sub tocdots div ceiling tocdots mul lmarg add
    tocdots x {
      y moveto (.) 0 linkshow
    } for
    x y moveto s 0 linkshow
  end
  linkend
} def

/toc00 { tocx0 exch moveto 0 rmoveto bfont showstream } def
/toc01 { tocx0 exch moveto
	 linkbegindest bfont0 setfont 0 linkshow bfont showstream } def
/toc02 { tocx0 exch moveto 3 1 roll
	 0 rmoveto bfont showstream tocpn } def
/toc03 { tocx0 exch moveto 4 1 roll
	 linkbegindest bfont0 setfont 0 linkshow bfont showstream tocpn } def

/toc10 { tocx1 exch moveto 0 rmoveto bfont showstream } def
/toc11 { tocx1 exch moveto
	 linkbegindest bfont0 setfont 0 linkshow bfont showstream } def
/toc12 { tocx1 exch moveto 3 1 roll
	 0 rmoveto bfont showstream tocpn } def
/toc13 { tocx1 exch moveto 4 1 roll
	 linkbegindest bfont0 setfont 0 linkshow bfont showstream tocpn } def

/toc20 { tocx2 exch moveto 0 rmoveto bfont showstream } def
/toc21 { tocx2 exch moveto
	 linkbegindest bfont0 setfont 0 linkshow bfont showstream } def
/toc22 { tocx2 exch moveto 3 1 roll
	 0 rmoveto bfont showstream tocpn } def
/toc23 { tocx2 exch moveto 4 1 roll
	 linkbegindest bfont0 setfont 0 linkshow bfont showstream tocpn } def

% Spacing between index columns
/indexcolumn pagewidth lmarg sub rmarg sub idxgutter add idxcolumns div def
% Width of an individual index column
/indexcolwid indexcolumn idxgutter sub def

/idx03 {
  2 dict begin
    indexcolumn mul lmarg add
    /x exch def /y exch def x y moveto
    exch bfont showstream
    dup bfont streamwidth
    x indexcolwid add exch sub exch pop y moveto
    bfont showstream
  end
} def
/idx00 {idx03} def
/idx01 {idx03} def
/idx02 {idx03} def

/idx13 {
  2 dict begin
    indexcolumn mul lmarg add idxindent add
    /x exch def /y exch def x y moveto
    exch bfont showstream
    dup bfont streamwidth
    x indexcolwid idxindent sub add exch sub exch pop y moveto
    bfont showstream
  end
} def
/idx10 {idx13} def
/idx11 {idx13} def
/idx12 {idx13} def

%
% Page numbers
%
/pagey botmarg pymarg sub def
/pagel lmarg plmarg sub def
/pager pagewidth rmarg sub prmarg add def

/pageeven { pagel pagey moveto sfont0 setfont show } def
/pageodd  { sfont0 setfont dup stringwidth pop pager exch sub
	    pagey moveto show } def

%
% Functions invoked during parsing
%
/xa { linkdest } def
/pa { 0 pageheight moveto linkdest } def
/xl { linkbegindest } def
/wl { linkbeginuri } def
/pl { linkbeginpage } def
/el { linkend } def

%
% PDF viewer options
%
[/PageMode /UseOutlines /DOCVIEW pdfmark	% Display bookmarks

%
% Functions to include EPS
%
/BeginEPSF {
  /Before_EPSF_State save def
  /dict_count countdictstack def
  /op_count count 1 sub def
  userdict begin
  /showpage {} def
  0 setgray 0 setlinecap
  1 setlinewidth 0 setlinejoin
  10 setmiterlimit [ ] 0 setdash newpath
  /languagelevel where
  {
    pop languagelevel
    1 ne {
      false setstrokeadjust false setoverprint
    } if
  } if
} bind def
/EndEPSF {
  count op_count sub {pop} repeat
  countdictstack dict_count sub {end} repeat
  Before_EPSF_State restore
} bind def
%%EndProlog
%%BeginSetup
[/Title (Title)
/Dest /title /OUT pdfmark
[/Title (Contents)
/Dest /contents /OUT pdfmark
[/Title (Introduction)
/Count -3 /Dest /chapter-1 /OUT pdfmark
[/Title (What Is NASM?)
/Count -2 /Dest /section-1.1 /OUT pdfmark
[/Title (Why Yet Another Assembler?)
/Dest /section-1.1.1 /OUT pdfmark
[/Title (Licence Conditions)
/Dest /section-1.1.2 /OUT pdfmark
[/Title (Contact Information)
/Dest /section-1.2 /OUT pdfmark
[/Title (Installation)
/Count -2 /Dest /section-1.3 /OUT pdfmark
[/Title (Installing NASM under MS-DOS or Windows)
/Dest /section-1.3.1 /OUT pdfmark
[/Title (Installing NASM under Unix)
/Dest /section-1.3.2 /OUT pdfmark
[/Title (Running NASM)
/Count -2 /Dest /chapter-2 /OUT pdfmark
[/Title (NASM Command-Line Syntax)
/Count -22 /Dest /section-2.1 /OUT pdfmark
[/Title (The -o Option: Specifying the Output File Name)
/Dest /section-2.1.1 /OUT pdfmark
[/Title (The -f Option: Specifying the Output File Format)
/Dest /section-2.1.2 /OUT pdfmark
[/Title (The -l Option: Generating a Listing File)
/Dest /section-2.1.3 /OUT pdfmark
[/Title (The -M Option: Generate Makefile Dependencies.)
/Dest /section-2.1.4 /OUT pdfmark
[/Title (The -F Option: Selecting a Debug Information Format)
/Dest /section-2.1.5 /OUT pdfmark
[/Title (The -g Option: Enabling Debug Information.)
/Dest /section-2.1.6 /OUT pdfmark
[/Title (The -X Option: Selecting an Error Reporting Format)
/Dest /section-2.1.7 /OUT pdfmark
[/Title (The -E Option: Send Errors to a File)
/Dest /section-2.1.8 /OUT pdfmark
[/Title (The -s Option: Send Errors to stdout)
/Dest /section-2.1.9 /OUT pdfmark
[/Title (The -i Option: Include File Search Directories)
/Dest /section-2.1.10 /OUT pdfmark
[/Title (The -p Option: Pre-Include a File)
/Dest /section-2.1.11 /OUT pdfmark
[/Title (The -d Option: Pre-Define a Macro)
/Dest /section-2.1.12 /OUT pdfmark
[/Title (The -u Option: Undefine a Macro)
/Dest /section-2.1.13 /OUT pdfmark
[/Title (The -e Option: Preprocess Only)
/Dest /section-2.1.14 /OUT pdfmark
[/Title (The -a Option: Don't Preprocess At All)
/Dest /section-2.1.15 /OUT pdfmark
[/Title (The -On Option: Specifying Multipass Optimization.)
/Dest /section-2.1.16 /OUT pdfmark
[/Title (The -t option: Enable TASM Compatibility Mode)
/Dest /section-2.1.17 /OUT pdfmark
[/Title (The -w Option: Enable or Disable Assembly Warnings)
/Dest /section-2.1.18 /OUT pdfmark
[/Title (The -v Option: Display Version Info)
/Dest /section-2.1.19 /OUT pdfmark
[/Title (The -y Option: Display Available Debug Info Formats)
/Dest /section-2.1.20 /OUT pdfmark
[/Title (The --prefix and --postfix Options.)
/Dest /section-2.1.21 /OUT pdfmark
[/Title (The NASMENV Environment Variable)
/Dest /section-2.1.22 /OUT pdfmark
[/Title (Quick Start for MASM Users)
/Count -7 /Dest /section-2.2 /OUT pdfmark
[/Title (NASM Is Case-Sensitive)
/Dest /section-2.2.1 /OUT pdfmark
[/Title (NASM Requires Square Brackets For Memory References)
/Dest /section-2.2.2 /OUT pdfmark
[/Title (NASM Doesn't Store Variable Types)
/Dest /section-2.2.3 /OUT pdfmark
[/Title (NASM Doesn't ASSUME)
/Dest /section-2.2.4 /OUT pdfmark
[/Title (NASM Doesn't Support Memory Models)
/Dest /section-2.2.5 /OUT pdfmark
[/Title (Floating-Point Differences)
/Dest /section-2.2.6 /OUT pdfmark
[/Title (Other Differences)
/Dest /section-2.2.7 /OUT pdfmark
[/Title (The NASM Language)
/Count -9 /Dest /chapter-3 /OUT pdfmark
[/Title (Layout of a NASM Source Line)
/Dest /section-3.1 /OUT pdfmark
[/Title (Pseudo-Instructions)
/Count -5 /Dest /section-3.2 /OUT pdfmark
[/Title (DB and friends: Declaring Initialised Data)
/Dest /section-3.2.1 /OUT pdfmark
[/Title (RESB and friends: Declaring Uninitialised Data)
/Dest /section-3.2.2 /OUT pdfmark
[/Title (INCBIN: Including External Binary Files)
/Dest /section-3.2.3 /OUT pdfmark
[/Title (EQU: Defining Constants)
/Dest /section-3.2.4 /OUT pdfmark
[/Title (TIMES: Repeating Instructions or Data)
/Dest /section-3.2.5 /OUT pdfmark
[/Title (Effective Addresses)
/Dest /section-3.3 /OUT pdfmark
[/Title (Constants)
/Count -4 /Dest /section-3.4 /OUT pdfmark
[/Title (Numeric Constants)
/Dest /section-3.4.1 /OUT pdfmark
[/Title (Character Constants)
/Dest /section-3.4.2 /OUT pdfmark
[/Title (String Constants)
/Dest /section-3.4.3 /OUT pdfmark
[/Title (Floating-Point Constants)
/Dest /section-3.4.4 /OUT pdfmark
[/Title (Expressions)
/Count -7 /Dest /section-3.5 /OUT pdfmark
[/Title (|: Bitwise OR Operator)
/Dest /section-3.5.1 /OUT pdfmark
[/Title (^: Bitwise XOR Operator)
/Dest /section-3.5.2 /OUT pdfmark
[/Title (&: Bitwise AND Operator)
/Dest /section-3.5.3 /OUT pdfmark
[/Title (<< and >>: Bit Shift Operators)
/Dest /section-3.5.4 /OUT pdfmark
[/Title (+ and -: Addition and Subtraction Operators)
/Dest /section-3.5.5 /OUT pdfmark
[/Title (*, /, //, % and %%: Multiplication and Division)
/Dest /section-3.5.6 /OUT pdfmark
[/Title (Unary Operators: +, -, ~ and SEG)
/Dest /section-3.5.7 /OUT pdfmark
[/Title (SEG and WRT)
/Dest /section-3.6 /OUT pdfmark
[/Title (STRICT: Inhibiting Optimization)
/Dest /section-3.7 /OUT pdfmark
[/Title (Critical Expressions)
/Dest /section-3.8 /OUT pdfmark
[/Title (Local Labels)
/Dest /section-3.9 /OUT pdfmark
[/Title (The NASM Preprocessor)
/Count -10 /Dest /chapter-4 /OUT pdfmark
[/Title (Single-Line Macros)
/Count -5 /Dest /section-4.1 /OUT pdfmark
[/Title (The Normal Way: %define)
/Dest /section-4.1.1 /OUT pdfmark
[/Title (Enhancing %define: %xdefine)
/Dest /section-4.1.2 /OUT pdfmark
[/Title (Concatenating Single Line Macro Tokens: %+)
/Dest /section-4.1.3 /OUT pdfmark
[/Title (Undefining macros: %undef)
/Dest /section-4.1.4 /OUT pdfmark
[/Title (Preprocessor Variables: %assign)
/Dest /section-4.1.5 /OUT pdfmark
[/Title (String Handling in Macros: %strlen and %substr)
/Count -2 /Dest /section-4.2 /OUT pdfmark
[/Title (String Length: %strlen)
/Dest /section-4.2.1 /OUT pdfmark
[/Title (Sub-strings: %substr)
/Dest /section-4.2.2 /OUT pdfmark
[/Title (Multi-Line Macros: %macro)
/Count -9 /Dest /section-4.3 /OUT pdfmark
[/Title (Overloading Multi-Line Macros)
/Dest /section-4.3.1 /OUT pdfmark
[/Title (Macro-Local Labels)
/Dest /section-4.3.2 /OUT pdfmark
[/Title (Greedy Macro Parameters)
/Dest /section-4.3.3 /OUT pdfmark
[/Title (Default Macro Parameters)
/Dest /section-4.3.4 /OUT pdfmark
[/Title (%0: Macro Parameter Counter)
/Dest /section-4.3.5 /OUT pdfmark
[/Title (%rotate: Rotating Macro Parameters)
/Dest /section-4.3.6 /OUT pdfmark
[/Title (Concatenating Macro Parameters)
/Dest /section-4.3.7 /OUT pdfmark
[/Title (Condition Codes as Macro Parameters)
/Dest /section-4.3.8 /OUT pdfmark
[/Title (Disabling Listing Expansion)
/Dest /section-4.3.9 /OUT pdfmark
[/Title (Conditional Assembly)
/Count -7 /Dest /section-4.4 /OUT pdfmark
[/Title (%ifdef: Testing Single-Line Macro Existence)
/Dest /section-4.4.1 /OUT pdfmark
[/Title (ifmacro: Testing Multi-Line Macro Existence)
/Dest /section-4.4.2 /OUT pdfmark
[/Title (%ifctx: Testing the Context Stack)
/Dest /section-4.4.3 /OUT pdfmark
[/Title (%if: Testing Arbitrary Numeric Expressions)
/Dest /section-4.4.4 /OUT pdfmark
[/Title (%ifidn and %ifidni: Testing Exact Text Identity)
/Dest /section-4.4.5 /OUT pdfmark
[/Title (%ifid, %ifnum, %ifstr: Testing Token Types)
/Dest /section-4.4.6 /OUT pdfmark
[/Title (%error: Reporting User-Defined Errors)
/Dest /section-4.4.7 /OUT pdfmark
[/Title (Preprocessor Loops: %rep)
/Dest /section-4.5 /OUT pdfmark
[/Title (Including Other Files)
/Dest /section-4.6 /OUT pdfmark
[/Title (The Context Stack)
/Count -5 /Dest /section-4.7 /OUT pdfmark
[/Title (%push and %pop: Creating and Removing Contexts)
/Dest /section-4.7.1 /OUT pdfmark
[/Title (Context-Local Labels)
/Dest /section-4.7.2 /OUT pdfmark
[/Title (Context-Local Single-Line Macros)
/Dest /section-4.7.3 /OUT pdfmark
[/Title (%repl: Renaming a Context)
/Dest /section-4.7.4 /OUT pdfmark
[/Title (Example Use of the Context Stack: Block IFs)
/Dest /section-4.7.5 /OUT pdfmark
[/Title (Standard Macros)
/Count -7 /Dest /section-4.8 /OUT pdfmark
[/Title (__NASM_MAJOR__, __NASM_MINOR__, __NASM_SUBMINOR__ and ___NASM_PATCHLEVEL__: NASM Version)
/Dest /section-4.8.1 /OUT pdfmark
[/Title (__NASM_VERSION_ID__: NASM Version ID)
/Dest /section-4.8.2 /OUT pdfmark
[/Title (__NASM_VER__: NASM Version string)
/Dest /section-4.8.3 /OUT pdfmark
[/Title (__FILE__ and __LINE__: File Name and Line Number)
/Dest /section-4.8.4 /OUT pdfmark
[/Title (STRUC and ENDSTRUC: Declaring Structure Data Types)
/Dest /section-4.8.5 /OUT pdfmark
[/Title (ISTRUC, AT and IEND: Declaring Instances of Structures)
/Dest /section-4.8.6 /OUT pdfmark
[/Title (ALIGN and ALIGNB: Data Alignment)
/Dest /section-4.8.7 /OUT pdfmark
[/Title (TASM Compatible Preprocessor Directives)
/Count -3 /Dest /section-4.9 /OUT pdfmark
[/Title (%arg Directive)
/Dest /section-4.9.1 /OUT pdfmark
[/Title (%stacksize Directive)
/Dest /section-4.9.2 /OUT pdfmark
[/Title (%local Directive)
/Dest /section-4.9.3 /OUT pdfmark
[/Title (Other Preprocessor Directives)
/Count -2 /Dest /section-4.10 /OUT pdfmark
[/Title (%line Directive)
/Dest /section-4.10.1 /OUT pdfmark
[/Title (%!<env>: Read an environment variable.)
/Dest /section-4.10.2 /OUT pdfmark
[/Title (Assembler Directives)
/Count -7 /Dest /chapter-5 /OUT pdfmark
[/Title (BITS: Specifying Target Processor Mode)
/Count -1 /Dest /section-5.1 /OUT pdfmark
[/Title (USE16 & USE32: Aliases for BITS)
/Dest /section-5.1.1 /OUT pdfmark
[/Title (SECTION or SEGMENT: Changing and Defining Sections)
/Count -1 /Dest /section-5.2 /OUT pdfmark
[/Title (The __SECT__ Macro)
/Dest /section-5.2.1 /OUT pdfmark
[/Title (ABSOLUTE: Defining Absolute Labels)
/Dest /section-5.3 /OUT pdfmark
[/Title (EXTERN: Importing Symbols from Other Modules)
/Dest /section-5.4 /OUT pdfmark
[/Title (GLOBAL: Exporting Symbols to Other Modules)
/Dest /section-5.5 /OUT pdfmark
[/Title (COMMON: Defining Common Data Areas)
/Dest /section-5.6 /OUT pdfmark
[/Title (CPU: Defining CPU Dependencies)
/Dest /section-5.7 /OUT pdfmark
[/Title (Output Formats)
/Count -10 /Dest /chapter-6 /OUT pdfmark
[/Title (bin: Flat-Form Binary Output)
/Count -4 /Dest /section-6.1 /OUT pdfmark
[/Title (ORG: Binary File Program Origin)
/Dest /section-6.1.1 /OUT pdfmark
[/Title (bin Extensions to the SECTION Directive)
/Dest /section-6.1.2 /OUT pdfmark
[/Title (Multisection support for the BIN format.)
/Dest /section-6.1.3 /OUT pdfmark
[/Title (Map files)
/Dest /section-6.1.4 /OUT pdfmark
[/Title (obj: Microsoft OMF Object Files)
/Count -8 /Dest /section-6.2 /OUT pdfmark
[/Title (obj Extensions to the SEGMENT Directive)
/Dest /section-6.2.1 /OUT pdfmark
[/Title (GROUP: Defining Groups of Segments)
/Dest /section-6.2.2 /OUT pdfmark
[/Title (UPPERCASE: Disabling Case Sensitivity in Output)
/Dest /section-6.2.3 /OUT pdfmark
[/Title (IMPORT: Importing DLL Symbols)
/Dest /section-6.2.4 /OUT pdfmark
[/Title (EXPORT: Exporting DLL Symbols)
/Dest /section-6.2.5 /OUT pdfmark
[/Title (..start: Defining the Program Entry Point)
/Dest /section-6.2.6 /OUT pdfmark
[/Title (obj Extensions to the EXTERN Directive)
/Dest /section-6.2.7 /OUT pdfmark
[/Title (obj Extensions to the COMMON Directive)
/Dest /section-6.2.8 /OUT pdfmark
[/Title (win32: Microsoft Win32 Object Files)
/Count -1 /Dest /section-6.3 /OUT pdfmark
[/Title (win32 Extensions to the SECTION Directive)
/Dest /section-6.3.1 /OUT pdfmark
[/Title (coff: Common Object File Format)
/Dest /section-6.4 /OUT pdfmark
[/Title (elf: Executable and Linkable Format Object Files)
/Count -5 /Dest /section-6.5 /OUT pdfmark
[/Title (elf Extensions to the SECTION Directive)
/Dest /section-6.5.1 /OUT pdfmark
[/Title (Position-Independent Code: elf Special Symbols and WRT)
/Dest /section-6.5.2 /OUT pdfmark
[/Title (elf Extensions to the GLOBAL Directive)
/Dest /section-6.5.3 /OUT pdfmark
[/Title (elf Extensions to the COMMON Directive )
/Dest /section-6.5.4 /OUT pdfmark
[/Title (16-bit code and ELF )
/Dest /section-6.5.5 /OUT pdfmark
[/Title (aout: Linux a.out Object Files)
/Dest /section-6.6 /OUT pdfmark
[/Title (aoutb: NetBSD/FreeBSD/OpenBSD a.out Object Files)
/Dest /section-6.7 /OUT pdfmark
[/Title (as86: Minix/Linux as86 Object Files)
/Dest /section-6.8 /OUT pdfmark
[/Title (rdf: Relocatable Dynamic Object File Format)
/Count -4 /Dest /section-6.9 /OUT pdfmark
[/Title (Requiring a Library: The LIBRARY Directive)
/Dest /section-6.9.1 /OUT pdfmark
[/Title (Specifying a Module Name: The MODULE Directive)
/Dest /section-6.9.2 /OUT pdfmark
[/Title (rdf Extensions to the GLOBAL directive)
/Dest /section-6.9.3 /OUT pdfmark
[/Title (rdf Extensions to the EXTERN directive)
/Dest /section-6.9.4 /OUT pdfmark
[/Title (dbg: Debugging Format)
/Dest /section-6.10 /OUT pdfmark
[/Title (Writing 16-bit Code \(DOS, Windows 3/3.1\))
/Count -5 /Dest /chapter-7 /OUT pdfmark
[/Title (Producing .EXE Files)
/Count -2 /Dest /section-7.1 /OUT pdfmark
[/Title (Using the obj Format To Generate .EXE Files)
/Dest /section-7.1.1 /OUT pdfmark
[/Title (Using the bin Format To Generate .EXE Files)
/Dest /section-7.1.2 /OUT pdfmark
[/Title (Producing .COM Files)
/Count -2 /Dest /section-7.2 /OUT pdfmark
[/Title (Using the bin Format To Generate .COM Files)
/Dest /section-7.2.1 /OUT pdfmark
[/Title (Using the obj Format To Generate .COM Files)
/Dest /section-7.2.2 /OUT pdfmark
[/Title (Producing .SYS Files)
/Dest /section-7.3 /OUT pdfmark
[/Title (Interfacing to 16-bit C Programs)
/Count -5 /Dest /section-7.4 /OUT pdfmark
[/Title (External Symbol Names)
/Dest /section-7.4.1 /OUT pdfmark
[/Title (Memory Models)
/Dest /section-7.4.2 /OUT pdfmark
[/Title (Function Definitions and Function Calls)
/Dest /section-7.4.3 /OUT pdfmark
[/Title (Accessing Data Items)
/Dest /section-7.4.4 /OUT pdfmark
[/Title (c16.mac: Helper Macros for the 16-bit C Interface)
/Dest /section-7.4.5 /OUT pdfmark
[/Title (Interfacing to Borland Pascal Programs)
/Count -3 /Dest /section-7.5 /OUT pdfmark
[/Title (The Pascal Calling Convention)
/Dest /section-7.5.1 /OUT pdfmark
[/Title (Borland Pascal Segment Name Restrictions)
/Dest /section-7.5.2 /OUT pdfmark
[/Title (Using c16.mac With Pascal Programs)
/Dest /section-7.5.3 /OUT pdfmark
[/Title (Writing 32-bit Code \(Unix, Win32, DJGPP\))
/Count -2 /Dest /chapter-8 /OUT pdfmark
[/Title (Interfacing to 32-bit C Programs)
/Count -4 /Dest /section-8.1 /OUT pdfmark
[/Title (External Symbol Names)
/Dest /section-8.1.1 /OUT pdfmark
[/Title (Function Definitions and Function Calls)
/Dest /section-8.1.2 /OUT pdfmark
[/Title (Accessing Data Items)
/Dest /section-8.1.3 /OUT pdfmark
[/Title (c32.mac: Helper Macros for the 32-bit C Interface)
/Dest /section-8.1.4 /OUT pdfmark
[/Title (Writing NetBSD/FreeBSD/OpenBSD and Linux/ELF Shared Libraries)
/Count -6 /Dest /section-8.2 /OUT pdfmark
[/Title (Obtaining the Address of the GOT)
/Dest /section-8.2.1 /OUT pdfmark
[/Title (Finding Your Local Data Items)
/Dest /section-8.2.2 /OUT pdfmark
[/Title (Finding External and Common Data Items)
/Dest /section-8.2.3 /OUT pdfmark
[/Title (Exporting Symbols to the Library User)
/Dest /section-8.2.4 /OUT pdfmark
[/Title (Calling Procedures Outside the Library)
/Dest /section-8.2.5 /OUT pdfmark
[/Title (Generating the Library File)
/Dest /section-8.2.6 /OUT pdfmark
[/Title (Mixing 16 and 32 Bit Code)
/Count -3 /Dest /chapter-9 /OUT pdfmark
[/Title (Mixed-Size Jumps)
/Dest /section-9.1 /OUT pdfmark
[/Title (Addressing Between Different-Size Segments)
/Dest /section-9.2 /OUT pdfmark
[/Title (Other Mixed-Size Instructions)
/Dest /section-9.3 /OUT pdfmark
[/Title (Troubleshooting)
/Count -2 /Dest /chapter-10 /OUT pdfmark
[/Title (Common Problems)
/Count -4 /Dest /section-10.1 /OUT pdfmark
[/Title (NASM Generates Inefficient Code)
/Dest /section-10.1.1 /OUT pdfmark
[/Title (My Jumps are Out of Range)
/Dest /section-10.1.2 /OUT pdfmark
[/Title (ORG Doesn't Work)
/Dest /section-10.1.3 /OUT pdfmark
[/Title (TIMES Doesn't Work)
/Dest /section-10.1.4 /OUT pdfmark
[/Title (Bugs)
/Dest /section-10.2 /OUT pdfmark
[/Title (Ndisasm)
/Count -4 /Dest /appendix-A /OUT pdfmark
[/Title (Introduction)
/Dest /section-A.1 /OUT pdfmark
[/Title (Getting Started: Installation)
/Dest /section-A.2 /OUT pdfmark
[/Title (Running NDISASM)
/Count -4 /Dest /section-A.3 /OUT pdfmark
[/Title (COM Files: Specifying an Origin)
/Dest /section-A.3.1 /OUT pdfmark
[/Title (Code Following Data: Synchronisation)
/Dest /section-A.3.2 /OUT pdfmark
[/Title (Mixed Code and Data: Automatic \(Intelligent\) Synchronisation )
/Dest /section-A.3.3 /OUT pdfmark
[/Title (Other Options)
/Dest /section-A.3.4 /OUT pdfmark
[/Title (Bugs and Improvements)
/Dest /section-A.4 /OUT pdfmark
[/Title (x86 Instruction Reference)
/Count -4 /Dest /appendix-B /OUT pdfmark
[/Title (Key to Operand Specifications)
/Dest /section-B.1 /OUT pdfmark
[/Title (Key to Opcode Descriptions)
/Count -5 /Dest /section-B.2 /OUT pdfmark
[/Title (Register Values)
/Dest /section-B.2.1 /OUT pdfmark
[/Title (Condition Codes)
/Dest /section-B.2.2 /OUT pdfmark
[/Title (SSE Condition Predicates)
/Dest /section-B.2.3 /OUT pdfmark
[/Title (Status Flags)
/Dest /section-B.2.4 /OUT pdfmark
[/Title (Effective Address Encoding: ModR/M and SIB)
/Dest /section-B.2.5 /OUT pdfmark
[/Title (Key to Instruction Flags)
/Dest /section-B.3 /OUT pdfmark
[/Title (x86 Instruction Set)
/Count -337 /Dest /section-B.4 /OUT pdfmark
[/Title (AAA, AAS, AAM, AAD: ASCII Adjustments)
/Dest /section-B.4.1 /OUT pdfmark
[/Title (ADC: Add with Carry)
/Dest /section-B.4.2 /OUT pdfmark
[/Title (ADD: Add Integers)
/Dest /section-B.4.3 /OUT pdfmark
[/Title (ADDPD: ADD Packed Double-Precision FP Values)
/Dest /section-B.4.4 /OUT pdfmark
[/Title (ADDPS: ADD Packed Single-Precision FP Values)
/Dest /section-B.4.5 /OUT pdfmark
[/Title (ADDSD: ADD Scalar Double-Precision FP Values)
/Dest /section-B.4.6 /OUT pdfmark
[/Title (ADDSS: ADD Scalar Single-Precision FP Values)
/Dest /section-B.4.7 /OUT pdfmark
[/Title (AND: Bitwise AND)
/Dest /section-B.4.8 /OUT pdfmark
[/Title (ANDNPD: Bitwise Logical AND NOT of Packed Double-Precision FP Values)
/Dest /section-B.4.9 /OUT pdfmark
[/Title (ANDNPS: Bitwise Logical AND NOT of Packed Single-Precision FP Values)
/Dest /section-B.4.10 /OUT pdfmark
[/Title (ANDPD: Bitwise Logical AND For Single FP)
/Dest /section-B.4.11 /OUT pdfmark
[/Title (ANDPS: Bitwise Logical AND For Single FP)
/Dest /section-B.4.12 /OUT pdfmark
[/Title (ARPL: Adjust RPL Field of Selector)
/Dest /section-B.4.13 /OUT pdfmark
[/Title (BOUND: Check Array Index against Bounds)
/Dest /section-B.4.14 /OUT pdfmark
[/Title (BSF, BSR: Bit Scan)
/Dest /section-B.4.15 /OUT pdfmark
[/Title (BSWAP: Byte Swap)
/Dest /section-B.4.16 /OUT pdfmark
[/Title (BT, BTC, BTR, BTS: Bit Test)
/Dest /section-B.4.17 /OUT pdfmark
[/Title (CALL: Call Subroutine)
/Dest /section-B.4.18 /OUT pdfmark
[/Title (CBW, CWD, CDQ, CWDE: Sign Extensions)
/Dest /section-B.4.19 /OUT pdfmark
[/Title (CLC, CLD, CLI, CLTS: Clear Flags)
/Dest /section-B.4.20 /OUT pdfmark
[/Title (CLFLUSH: Flush Cache Line)
/Dest /section-B.4.21 /OUT pdfmark
[/Title (CMC: Complement Carry Flag)
/Dest /section-B.4.22 /OUT pdfmark
[/Title (CMOVcc: Conditional Move)
/Dest /section-B.4.23 /OUT pdfmark
[/Title (CMP: Compare Integers)
/Dest /section-B.4.24 /OUT pdfmark
[/Title (CMPccPD: Packed Double-Precision FP Compare        )
/Dest /section-B.4.25 /OUT pdfmark
[/Title (CMPccPS: Packed Single-Precision FP Compare        )
/Dest /section-B.4.26 /OUT pdfmark
[/Title (CMPSB, CMPSW, CMPSD: Compare Strings)
/Dest /section-B.4.27 /OUT pdfmark
[/Title (CMPccSD: Scalar Double-Precision FP Compare        )
/Dest /section-B.4.28 /OUT pdfmark
[/Title (CMPccSS: Scalar Single-Precision FP Compare        )
/Dest /section-B.4.29 /OUT pdfmark
[/Title (CMPXCHG, CMPXCHG486: Compare and Exchange)
/Dest /section-B.4.30 /OUT pdfmark
[/Title (CMPXCHG8B: Compare and Exchange Eight Bytes)
/Dest /section-B.4.31 /OUT pdfmark
[/Title (COMISD: Scalar Ordered Double-Precision FP Compare and Set EFLAGS)
/Dest /section-B.4.32 /OUT pdfmark
[/Title (COMISS: Scalar Ordered Single-Precision FP Compare and Set EFLAGS)
/Dest /section-B.4.33 /OUT pdfmark
[/Title (CPUID: Get CPU Identification Code)
/Dest /section-B.4.34 /OUT pdfmark
[/Title (CVTDQ2PD: Packed Signed INT32 to Packed Double-Precision FP Conversion)
/Dest /section-B.4.35 /OUT pdfmark
[/Title (CVTDQ2PS: Packed Signed INT32 to Packed Single-Precision FP Conversion)
/Dest /section-B.4.36 /OUT pdfmark
[/Title (CVTPD2DQ: Packed Double-Precision FP to Packed Signed INT32 Conversion)
/Dest /section-B.4.37 /OUT pdfmark
[/Title (CVTPD2PI: Packed Double-Precision FP to Packed Signed INT32 Conversion)
/Dest /section-B.4.38 /OUT pdfmark
[/Title (CVTPD2PS: Packed Double-Precision FP to Packed Single-Precision FP Conversion)
/Dest /section-B.4.39 /OUT pdfmark
[/Title (CVTPI2PD: Packed Signed INT32 to Packed Double-Precision FP Conversion)
/Dest /section-B.4.40 /OUT pdfmark
[/Title (CVTPI2PS: Packed Signed INT32 to Packed Single-FP Conversion)
/Dest /section-B.4.41 /OUT pdfmark
[/Title (CVTPS2DQ: Packed Single-Precision FP to Packed Signed INT32 Conversion)
/Dest /section-B.4.42 /OUT pdfmark
[/Title (CVTPS2PD: Packed Single-Precision FP to Packed Double-Precision FP Conversion)
/Dest /section-B.4.43 /OUT pdfmark
[/Title (CVTPS2PI: Packed Single-Precision FP to Packed Signed INT32 Conversion)
/Dest /section-B.4.44 /OUT pdfmark
[/Title (CVTSD2SI: Scalar Double-Precision FP to Signed INT32 Conversion)
/Dest /section-B.4.45 /OUT pdfmark
[/Title (CVTSD2SS: Scalar Double-Precision FP to Scalar Single-Precision FP Conversion)
/Dest /section-B.4.46 /OUT pdfmark
[/Title (CVTSI2SD: Signed INT32 to Scalar Double-Precision FP Conversion)
/Dest /section-B.4.47 /OUT pdfmark
[/Title (CVTSI2SS: Signed INT32 to Scalar Single-Precision FP Conversion)
/Dest /section-B.4.48 /OUT pdfmark
[/Title (CVTSS2SD: Scalar Single-Precision FP to Scalar Double-Precision FP Conversion)
/Dest /section-B.4.49 /OUT pdfmark
[/Title (CVTSS2SI: Scalar Single-Precision FP to Signed INT32 Conversion)
/Dest /section-B.4.50 /OUT pdfmark
[/Title (CVTTPD2DQ: Packed Double-Precision FP to Packed Signed INT32 Conversion with Truncation)
/Dest /section-B.4.51 /OUT pdfmark
[/Title (CVTTPD2PI: Packed Double-Precision FP to Packed Signed INT32 Conversion with Truncation)
/Dest /section-B.4.52 /OUT pdfmark
[/Title (CVTTPS2DQ: Packed Single-Precision FP to Packed Signed INT32 Conversion with Truncation)
/Dest /section-B.4.53 /OUT pdfmark
[/Title (CVTTPS2PI: Packed Single-Precision FP to Packed Signed INT32 Conversion with Truncation)
/Dest /section-B.4.54 /OUT pdfmark
[/Title (CVTTSD2SI: Scalar Double-Precision FP to Signed INT32 Conversion with Truncation)
/Dest /section-B.4.55 /OUT pdfmark
[/Title (CVTTSS2SI: Scalar Single-Precision FP to Signed INT32 Conversion with Truncation)
/Dest /section-B.4.56 /OUT pdfmark
[/Title (DAA, DAS: Decimal Adjustments)
/Dest /section-B.4.57 /OUT pdfmark
[/Title (DEC: Decrement Integer)
/Dest /section-B.4.58 /OUT pdfmark
[/Title (DIV: Unsigned Integer Divide)
/Dest /section-B.4.59 /OUT pdfmark
[/Title (DIVPD: Packed Double-Precision FP Divide)
/Dest /section-B.4.60 /OUT pdfmark
[/Title (DIVPS: Packed Single-Precision FP Divide)
/Dest /section-B.4.61 /OUT pdfmark
[/Title (DIVSD: Scalar Double-Precision FP Divide)
/Dest /section-B.4.62 /OUT pdfmark
[/Title (DIVSS: Scalar Single-Precision FP Divide)
/Dest /section-B.4.63 /OUT pdfmark
[/Title (EMMS: Empty MMX State)
/Dest /section-B.4.64 /OUT pdfmark
[/Title (ENTER: Create Stack Frame)
/Dest /section-B.4.65 /OUT pdfmark
[/Title (F2XM1: Calculate 2**X-1)
/Dest /section-B.4.66 /OUT pdfmark
[/Title (FABS: Floating-Point Absolute Value)
/Dest /section-B.4.67 /OUT pdfmark
[/Title (FADD, FADDP: Floating-Point Addition)
/Dest /section-B.4.68 /OUT pdfmark
[/Title (FBLD, FBSTP: BCD Floating-Point Load and Store)
/Dest /section-B.4.69 /OUT pdfmark
[/Title (FCHS: Floating-Point Change Sign)
/Dest /section-B.4.70 /OUT pdfmark
[/Title (FCLEX, FNCLEX: Clear Floating-Point Exceptions)
/Dest /section-B.4.71 /OUT pdfmark
[/Title (FCMOVcc: Floating-Point Conditional Move)
/Dest /section-B.4.72 /OUT pdfmark
[/Title (FCOM, FCOMP, FCOMPP, FCOMI, FCOMIP: Floating-Point Compare)
/Dest /section-B.4.73 /OUT pdfmark
[/Title (FCOS: Cosine)
/Dest /section-B.4.74 /OUT pdfmark
[/Title (FDECSTP: Decrement Floating-Point Stack Pointer)
/Dest /section-B.4.75 /OUT pdfmark
[/Title (FxDISI, FxENI: Disable and Enable Floating-Point Interrupts)
/Dest /section-B.4.76 /OUT pdfmark
[/Title (FDIV, FDIVP, FDIVR, FDIVRP: Floating-Point Division)
/Dest /section-B.4.77 /OUT pdfmark
[/Title (FEMMS: Faster Enter/Exit of the MMX or floating-point state)
/Dest /section-B.4.78 /OUT pdfmark
[/Title (FFREE: Flag Floating-Point Register as Unused)
/Dest /section-B.4.79 /OUT pdfmark
[/Title (FIADD: Floating-Point/Integer Addition)
/Dest /section-B.4.80 /OUT pdfmark
[/Title (FICOM, FICOMP: Floating-Point/Integer Compare)
/Dest /section-B.4.81 /OUT pdfmark
[/Title (FIDIV, FIDIVR: Floating-Point/Integer Division)
/Dest /section-B.4.82 /OUT pdfmark
[/Title (FILD, FIST, FISTP: Floating-Point/Integer Conversion)
/Dest /section-B.4.83 /OUT pdfmark
[/Title (FIMUL: Floating-Point/Integer Multiplication)
/Dest /section-B.4.84 /OUT pdfmark
[/Title (FINCSTP: Increment Floating-Point Stack Pointer)
/Dest /section-B.4.85 /OUT pdfmark
[/Title (FINIT, FNINIT: Initialise Floating-Point Unit)
/Dest /section-B.4.86 /OUT pdfmark
[/Title (FISUB: Floating-Point/Integer Subtraction)
/Dest /section-B.4.87 /OUT pdfmark
[/Title (FLD: Floating-Point Load)
/Dest /section-B.4.88 /OUT pdfmark
[/Title (FLDxx: Floating-Point Load Constants)
/Dest /section-B.4.89 /OUT pdfmark
[/Title (FLDCW: Load Floating-Point Control Word)
/Dest /section-B.4.90 /OUT pdfmark
[/Title (FLDENV: Load Floating-Point Environment)
/Dest /section-B.4.91 /OUT pdfmark
[/Title (FMUL, FMULP: Floating-Point Multiply)
/Dest /section-B.4.92 /OUT pdfmark
[/Title (FNOP: Floating-Point No Operation)
/Dest /section-B.4.93 /OUT pdfmark
[/Title (FPATAN, FPTAN: Arctangent and Tangent)
/Dest /section-B.4.94 /OUT pdfmark
[/Title (FPREM, FPREM1: Floating-Point Partial Remainder)
/Dest /section-B.4.95 /OUT pdfmark
[/Title (FRNDINT: Floating-Point Round to Integer)
/Dest /section-B.4.96 /OUT pdfmark
[/Title (FSAVE, FRSTOR: Save/Restore Floating-Point State)
/Dest /section-B.4.97 /OUT pdfmark
[/Title (FSCALE: Scale Floating-Point Value by Power of Two)
/Dest /section-B.4.98 /OUT pdfmark
[/Title (FSETPM: Set Protected Mode)
/Dest /section-B.4.99 /OUT pdfmark
[/Title (FSIN, FSINCOS: Sine and Cosine)
/Dest /section-B.4.100 /OUT pdfmark
[/Title (FSQRT: Floating-Point Square Root)
/Dest /section-B.4.101 /OUT pdfmark
[/Title (FST, FSTP: Floating-Point Store)
/Dest /section-B.4.102 /OUT pdfmark
[/Title (FSTCW: Store Floating-Point Control Word)
/Dest /section-B.4.103 /OUT pdfmark
[/Title (FSTENV: Store Floating-Point Environment)
/Dest /section-B.4.104 /OUT pdfmark
[/Title (FSTSW: Store Floating-Point Status Word)
/Dest /section-B.4.105 /OUT pdfmark
[/Title (FSUB, FSUBP, FSUBR, FSUBRP: Floating-Point Subtract)
/Dest /section-B.4.106 /OUT pdfmark
[/Title (FTST: Test ST0 Against Zero)
/Dest /section-B.4.107 /OUT pdfmark
[/Title (FUCOMxx: Floating-Point Unordered Compare)
/Dest /section-B.4.108 /OUT pdfmark
[/Title (FXAM: Examine Class of Value in ST0)
/Dest /section-B.4.109 /OUT pdfmark
[/Title (FXCH: Floating-Point Exchange)
/Dest /section-B.4.110 /OUT pdfmark
[/Title (FXRSTOR: Restore FP, MMX and SSE State)
/Dest /section-B.4.111 /OUT pdfmark
[/Title (FXSAVE: Store FP, MMX and SSE State)
/Dest /section-B.4.112 /OUT pdfmark
[/Title (FXTRACT: Extract Exponent and Significand)
/Dest /section-B.4.113 /OUT pdfmark
[/Title (FYL2X, FYL2XP1: Compute Y times Log2\(X\) or Log2\(X+1\))
/Dest /section-B.4.114 /OUT pdfmark
[/Title (HLT: Halt Processor)
/Dest /section-B.4.115 /OUT pdfmark
[/Title (IBTS: Insert Bit String)
/Dest /section-B.4.116 /OUT pdfmark
[/Title (IDIV: Signed Integer Divide)
/Dest /section-B.4.117 /OUT pdfmark
[/Title (IMUL: Signed Integer Multiply)
/Dest /section-B.4.118 /OUT pdfmark
[/Title (IN: Input from I/O Port)
/Dest /section-B.4.119 /OUT pdfmark
[/Title (INC: Increment Integer)
/Dest /section-B.4.120 /OUT pdfmark
[/Title (INSB, INSW, INSD: Input String from I/O Port)
/Dest /section-B.4.121 /OUT pdfmark
[/Title (INT: Software Interrupt)
/Dest /section-B.4.122 /OUT pdfmark
[/Title (INT3, INT1, ICEBP, INT01: Breakpoints)
/Dest /section-B.4.123 /OUT pdfmark
[/Title (INTO: Interrupt if Overflow)
/Dest /section-B.4.124 /OUT pdfmark
[/Title (INVD: Invalidate Internal Caches)
/Dest /section-B.4.125 /OUT pdfmark
[/Title (INVLPG: Invalidate TLB Entry)
/Dest /section-B.4.126 /OUT pdfmark
[/Title (IRET, IRETW, IRETD: Return from Interrupt)
/Dest /section-B.4.127 /OUT pdfmark
[/Title (Jcc: Conditional Branch)
/Dest /section-B.4.128 /OUT pdfmark
[/Title (JCXZ, JECXZ: Jump if CX/ECX Zero)
/Dest /section-B.4.129 /OUT pdfmark
[/Title (JMP: Jump)
/Dest /section-B.4.130 /OUT pdfmark
[/Title (LAHF: Load AH from Flags)
/Dest /section-B.4.131 /OUT pdfmark
[/Title (LAR: Load Access Rights)
/Dest /section-B.4.132 /OUT pdfmark
[/Title (LDMXCSR: Load Streaming SIMD Extension Control/Status)
/Dest /section-B.4.133 /OUT pdfmark
[/Title (LDS, LES, LFS, LGS, LSS: Load Far Pointer)
/Dest /section-B.4.134 /OUT pdfmark
[/Title (LEA: Load Effective Address)
/Dest /section-B.4.135 /OUT pdfmark
[/Title (LEAVE: Destroy Stack Frame)
/Dest /section-B.4.136 /OUT pdfmark
[/Title (LFENCE: Load Fence)
/Dest /section-B.4.137 /OUT pdfmark
[/Title (LGDT, LIDT, LLDT: Load Descriptor Tables)
/Dest /section-B.4.138 /OUT pdfmark
[/Title (LMSW: Load/Store Machine Status Word)
/Dest /section-B.4.139 /OUT pdfmark
[/Title (LOADALL, LOADALL286: Load Processor State)
/Dest /section-B.4.140 /OUT pdfmark
[/Title (LODSB, LODSW, LODSD: Load from String)
/Dest /section-B.4.141 /OUT pdfmark
[/Title (LOOP, LOOPE, LOOPZ, LOOPNE, LOOPNZ: Loop with Counter)
/Dest /section-B.4.142 /OUT pdfmark
[/Title (LSL: Load Segment Limit)
/Dest /section-B.4.143 /OUT pdfmark
[/Title (LTR: Load Task Register)
/Dest /section-B.4.144 /OUT pdfmark
[/Title (MASKMOVDQU: Byte Mask Write)
/Dest /section-B.4.145 /OUT pdfmark
[/Title (MASKMOVQ: Byte Mask Write)
/Dest /section-B.4.146 /OUT pdfmark
[/Title (MAXPD: Return Packed Double-Precision FP Maximum)
/Dest /section-B.4.147 /OUT pdfmark
[/Title (MAXPS: Return Packed Single-Precision FP Maximum)
/Dest /section-B.4.148 /OUT pdfmark
[/Title (MAXSD: Return Scalar Double-Precision FP Maximum)
/Dest /section-B.4.149 /OUT pdfmark
[/Title (MAXSS: Return Scalar Single-Precision FP Maximum)
/Dest /section-B.4.150 /OUT pdfmark
[/Title (MFENCE: Memory Fence)
/Dest /section-B.4.151 /OUT pdfmark
[/Title (MINPD: Return Packed Double-Precision FP Minimum)
/Dest /section-B.4.152 /OUT pdfmark
[/Title (MINPS: Return Packed Single-Precision FP Minimum)
/Dest /section-B.4.153 /OUT pdfmark
[/Title (MINSD: Return Scalar Double-Precision FP Minimum)
/Dest /section-B.4.154 /OUT pdfmark
[/Title (MINSS: Return Scalar Single-Precision FP Minimum)
/Dest /section-B.4.155 /OUT pdfmark
[/Title (MOV: Move Data)
/Dest /section-B.4.156 /OUT pdfmark
[/Title (MOVAPD: Move Aligned Packed Double-Precision FP Values)
/Dest /section-B.4.157 /OUT pdfmark
[/Title (MOVAPS: Move Aligned Packed Single-Precision FP Values)
/Dest /section-B.4.158 /OUT pdfmark
[/Title (MOVD: Move Doubleword to/from MMX Register)
/Dest /section-B.4.159 /OUT pdfmark
[/Title (MOVDQ2Q: Move Quadword from XMM to MMX register.)
/Dest /section-B.4.160 /OUT pdfmark
[/Title (MOVDQA: Move Aligned Double Quadword)
/Dest /section-B.4.161 /OUT pdfmark
[/Title (MOVDQU: Move Unaligned Double Quadword)
/Dest /section-B.4.162 /OUT pdfmark
[/Title (MOVHLPS: Move Packed Single-Precision FP High to Low)
/Dest /section-B.4.163 /OUT pdfmark
[/Title (MOVHPD: Move High Packed Double-Precision FP)
/Dest /section-B.4.164 /OUT pdfmark
[/Title (MOVHPS: Move High Packed Single-Precision FP)
/Dest /section-B.4.165 /OUT pdfmark
[/Title (MOVLHPS: Move Packed Single-Precision FP Low to High)
/Dest /section-B.4.166 /OUT pdfmark
[/Title (MOVLPD: Move Low Packed Double-Precision FP)
/Dest /section-B.4.167 /OUT pdfmark
[/Title (MOVLPS: Move Low Packed Single-Precision FP)
/Dest /section-B.4.168 /OUT pdfmark
[/Title (MOVMSKPD: Extract Packed Double-Precision FP Sign Mask)
/Dest /section-B.4.169 /OUT pdfmark
[/Title (MOVMSKPS: Extract Packed Single-Precision FP Sign Mask)
/Dest /section-B.4.170 /OUT pdfmark
[/Title (MOVNTDQ: Move Double Quadword Non Temporal)
/Dest /section-B.4.171 /OUT pdfmark
[/Title (MOVNTI: Move Doubleword Non Temporal)
/Dest /section-B.4.172 /OUT pdfmark
[/Title (MOVNTPD: Move Aligned Four Packed Single-Precision FP Values Non Temporal)
/Dest /section-B.4.173 /OUT pdfmark
[/Title (MOVNTPS: Move Aligned Four Packed Single-Precision FP Values Non Temporal)
/Dest /section-B.4.174 /OUT pdfmark
[/Title (MOVNTQ: Move Quadword Non Temporal)
/Dest /section-B.4.175 /OUT pdfmark
[/Title (MOVQ: Move Quadword to/from MMX Register)
/Dest /section-B.4.176 /OUT pdfmark
[/Title (MOVQ2DQ: Move Quadword from MMX to XMM register.)
/Dest /section-B.4.177 /OUT pdfmark
[/Title (MOVSB, MOVSW, MOVSD: Move String)
/Dest /section-B.4.178 /OUT pdfmark
[/Title (MOVSD: Move Scalar Double-Precision FP Value)
/Dest /section-B.4.179 /OUT pdfmark
[/Title (MOVSS: Move Scalar Single-Precision FP Value)
/Dest /section-B.4.180 /OUT pdfmark
[/Title (MOVSX, MOVZX: Move Data with Sign or Zero Extend)
/Dest /section-B.4.181 /OUT pdfmark
[/Title (MOVUPD: Move Unaligned Packed Double-Precision FP Values)
/Dest /section-B.4.182 /OUT pdfmark
[/Title (MOVUPS: Move Unaligned Packed Single-Precision FP Values)
/Dest /section-B.4.183 /OUT pdfmark
[/Title (MUL: Unsigned Integer Multiply)
/Dest /section-B.4.184 /OUT pdfmark
[/Title (MULPD: Packed Single-FP Multiply)
/Dest /section-B.4.185 /OUT pdfmark
[/Title (MULPS: Packed Single-FP Multiply)
/Dest /section-B.4.186 /OUT pdfmark
[/Title (MULSD: Scalar Single-FP Multiply)
/Dest /section-B.4.187 /OUT pdfmark
[/Title (MULSS: Scalar Single-FP Multiply)
/Dest /section-B.4.188 /OUT pdfmark
[/Title (NEG, NOT: Two's and One's Complement)
/Dest /section-B.4.189 /OUT pdfmark
[/Title (NOP: No Operation)
/Dest /section-B.4.190 /OUT pdfmark
[/Title (OR: Bitwise OR)
/Dest /section-B.4.191 /OUT pdfmark
[/Title (ORPD: Bit-wise Logical OR of Double-Precision FP Data)
/Dest /section-B.4.192 /OUT pdfmark
[/Title (ORPS: Bit-wise Logical OR of Single-Precision FP Data)
/Dest /section-B.4.193 /OUT pdfmark
[/Title (OUT: Output Data to I/O Port)
/Dest /section-B.4.194 /OUT pdfmark
[/Title (OUTSB, OUTSW, OUTSD: Output String to I/O Port)
/Dest /section-B.4.195 /OUT pdfmark
[/Title (PACKSSDW, PACKSSWB, PACKUSWB: Pack Data)
/Dest /section-B.4.196 /OUT pdfmark
[/Title (PADDB, PADDW, PADDD: Add Packed Integers)
/Dest /section-B.4.197 /OUT pdfmark
[/Title (PADDQ: Add Packed Quadword Integers)
/Dest /section-B.4.198 /OUT pdfmark
[/Title (PADDSB, PADDSW: Add Packed Signed Integers With Saturation)
/Dest /section-B.4.199 /OUT pdfmark
[/Title (PADDSIW: MMX Packed Addition to Implicit Destination)
/Dest /section-B.4.200 /OUT pdfmark
[/Title (PADDUSB, PADDUSW: Add Packed Unsigned Integers With Saturation)
/Dest /section-B.4.201 /OUT pdfmark
[/Title (PAND, PANDN: MMX Bitwise AND and AND-NOT)
/Dest /section-B.4.202 /OUT pdfmark
[/Title (PAUSE: Spin Loop Hint)
/Dest /section-B.4.203 /OUT pdfmark
[/Title (PAVEB: MMX Packed Average)
/Dest /section-B.4.204 /OUT pdfmark
[/Title (PAVGB PAVGW: Average Packed Integers)
/Dest /section-B.4.205 /OUT pdfmark
[/Title (PAVGUSB: Average of unsigned packed 8-bit values)
/Dest /section-B.4.206 /OUT pdfmark
[/Title (PCMPxx: Compare Packed Integers.)
/Dest /section-B.4.207 /OUT pdfmark
[/Title (PDISTIB: MMX Packed Distance and Accumulate with Implied Register)
/Dest /section-B.4.208 /OUT pdfmark
[/Title (PEXTRW: Extract Word)
/Dest /section-B.4.209 /OUT pdfmark
[/Title (PF2ID: Packed Single-Precision FP to Integer Convert)
/Dest /section-B.4.210 /OUT pdfmark
[/Title (PF2IW: Packed Single-Precision FP to Integer Word Convert)
/Dest /section-B.4.211 /OUT pdfmark
[/Title (PFACC: Packed Single-Precision FP Accumulate)
/Dest /section-B.4.212 /OUT pdfmark
[/Title (PFADD: Packed Single-Precision FP Addition)
/Dest /section-B.4.213 /OUT pdfmark
[/Title (PFCMPxx: Packed Single-Precision FP Compare   )
/Dest /section-B.4.214 /OUT pdfmark
[/Title (PFMAX: Packed Single-Precision FP Maximum)
/Dest /section-B.4.215 /OUT pdfmark
[/Title (PFMIN: Packed Single-Precision FP Minimum)
/Dest /section-B.4.216 /OUT pdfmark
[/Title (PFMUL: Packed Single-Precision FP Multiply)
/Dest /section-B.4.217 /OUT pdfmark
[/Title (PFNACC: Packed Single-Precision FP Negative Accumulate)
/Dest /section-B.4.218 /OUT pdfmark
[/Title (PFPNACC: Packed Single-Precision FP Mixed Accumulate)
/Dest /section-B.4.219 /OUT pdfmark
[/Title (PFRCP: Packed Single-Precision FP Reciprocal Approximation)
/Dest /section-B.4.220 /OUT pdfmark
[/Title (PFRCPIT1: Packed Single-Precision FP Reciprocal, First Iteration Step)
/Dest /section-B.4.221 /OUT pdfmark
[/Title (PFRCPIT2: Packed Single-Precision FP Reciprocal/ Reciprocal Square Root, Second Iteration Step)
/Dest /section-B.4.222 /OUT pdfmark
[/Title (PFRSQIT1: Packed Single-Precision FP Reciprocal Square Root, First Iteration Step)
/Dest /section-B.4.223 /OUT pdfmark
[/Title (PFRSQRT: Packed Single-Precision FP Reciprocal Square Root Approximation)
/Dest /section-B.4.224 /OUT pdfmark
[/Title (PFSUB: Packed Single-Precision FP Subtract)
/Dest /section-B.4.225 /OUT pdfmark
[/Title (PFSUBR: Packed Single-Precision FP Reverse Subtract)
/Dest /section-B.4.226 /OUT pdfmark
[/Title (PI2FD: Packed Doubleword Integer to Single-Precision FP Convert)
/Dest /section-B.4.227 /OUT pdfmark
[/Title (PF2IW: Packed Word Integer to Single-Precision FP Convert)
/Dest /section-B.4.228 /OUT pdfmark
[/Title (PINSRW: Insert Word)
/Dest /section-B.4.229 /OUT pdfmark
[/Title (PMACHRIW: Packed Multiply and Accumulate with Rounding)
/Dest /section-B.4.230 /OUT pdfmark
[/Title (PMADDWD: MMX Packed Multiply and Add)
/Dest /section-B.4.231 /OUT pdfmark
[/Title (PMAGW: MMX Packed Magnitude)
/Dest /section-B.4.232 /OUT pdfmark
[/Title (PMAXSW: Packed Signed Integer Word Maximum)
/Dest /section-B.4.233 /OUT pdfmark
[/Title (PMAXUB: Packed Unsigned Integer Byte Maximum)
/Dest /section-B.4.234 /OUT pdfmark
[/Title (PMINSW: Packed Signed Integer Word Minimum)
/Dest /section-B.4.235 /OUT pdfmark
[/Title (PMINUB: Packed Unsigned Integer Byte Minimum)
/Dest /section-B.4.236 /OUT pdfmark
[/Title (PMOVMSKB: Move Byte Mask To Integer)
/Dest /section-B.4.237 /OUT pdfmark
[/Title (PMULHRWC, PMULHRIW: Multiply Packed 16-bit Integers With Rounding, and Store High Word)
/Dest /section-B.4.238 /OUT pdfmark
[/Title (PMULHRWA: Multiply Packed 16-bit Integers With Rounding, and Store High Word)
/Dest /section-B.4.239 /OUT pdfmark
[/Title (PMULHUW: Multiply Packed 16-bit Integers, and Store High Word)
/Dest /section-B.4.240 /OUT pdfmark
[/Title (PMULHW, PMULLW: Multiply Packed 16-bit Integers, and Store)
/Dest /section-B.4.241 /OUT pdfmark
[/Title (PMULUDQ: Multiply Packed Unsigned 32-bit Integers, and Store.)
/Dest /section-B.4.242 /OUT pdfmark
[/Title (PMVccZB: MMX Packed Conditional Move)
/Dest /section-B.4.243 /OUT pdfmark
[/Title (POP: Pop Data from Stack)
/Dest /section-B.4.244 /OUT pdfmark
[/Title (POPAx: Pop All General-Purpose Registers)
/Dest /section-B.4.245 /OUT pdfmark
[/Title (POPFx: Pop Flags Register)
/Dest /section-B.4.246 /OUT pdfmark
[/Title (POR: MMX Bitwise OR)
/Dest /section-B.4.247 /OUT pdfmark
[/Title (PREFETCH: Prefetch Data Into Caches)
/Dest /section-B.4.248 /OUT pdfmark
[/Title (PREFETCHh: Prefetch Data Into Caches    )
/Dest /section-B.4.249 /OUT pdfmark
[/Title (PSADBW: Packed Sum of Absolute Differences)
/Dest /section-B.4.250 /OUT pdfmark
[/Title (PSHUFD: Shuffle Packed Doublewords)
/Dest /section-B.4.251 /OUT pdfmark
[/Title (PSHUFHW: Shuffle Packed High Words)
/Dest /section-B.4.252 /OUT pdfmark
[/Title (PSHUFLW: Shuffle Packed Low Words)
/Dest /section-B.4.253 /OUT pdfmark
[/Title (PSHUFW: Shuffle Packed Words)
/Dest /section-B.4.254 /OUT pdfmark
[/Title (PSLLx: Packed Data Bit Shift Left Logical)
/Dest /section-B.4.255 /OUT pdfmark
[/Title (PSRAx: Packed Data Bit Shift Right Arithmetic)
/Dest /section-B.4.256 /OUT pdfmark
[/Title (PSRLx: Packed Data Bit Shift Right Logical)
/Dest /section-B.4.257 /OUT pdfmark
[/Title (PSUBx: Subtract Packed Integers)
/Dest /section-B.4.258 /OUT pdfmark
[/Title (PSUBSxx, PSUBUSx: Subtract Packed Integers With Saturation)
/Dest /section-B.4.259 /OUT pdfmark
[/Title (PSUBSIW: MMX Packed Subtract with Saturation to Implied Destination)
/Dest /section-B.4.260 /OUT pdfmark
[/Title (PSWAPD: Swap Packed Data )
/Dest /section-B.4.261 /OUT pdfmark
[/Title (PUNPCKxxx: Unpack and Interleave Data)
/Dest /section-B.4.262 /OUT pdfmark
[/Title (PUSH: Push Data on Stack)
/Dest /section-B.4.263 /OUT pdfmark
[/Title (PUSHAx: Push All General-Purpose Registers)
/Dest /section-B.4.264 /OUT pdfmark
[/Title (PUSHFx: Push Flags Register)
/Dest /section-B.4.265 /OUT pdfmark
[/Title (PXOR: MMX Bitwise XOR)
/Dest /section-B.4.266 /OUT pdfmark
[/Title (RCL, RCR: Bitwise Rotate through Carry Bit)
/Dest /section-B.4.267 /OUT pdfmark
[/Title (RCPPS: Packed Single-Precision FP Reciprocal)
/Dest /section-B.4.268 /OUT pdfmark
[/Title (RCPSS: Scalar Single-Precision FP Reciprocal)
/Dest /section-B.4.269 /OUT pdfmark
[/Title (RDMSR: Read Model-Specific Registers)
/Dest /section-B.4.270 /OUT pdfmark
[/Title (RDPMC: Read Performance-Monitoring Counters)
/Dest /section-B.4.271 /OUT pdfmark
[/Title (RDSHR: Read SMM Header Pointer Register)
/Dest /section-B.4.272 /OUT pdfmark
[/Title (RDTSC: Read Time-Stamp Counter)
/Dest /section-B.4.273 /OUT pdfmark
[/Title (RET, RETF, RETN: Return from Procedure Call)
/Dest /section-B.4.274 /OUT pdfmark
[/Title (ROL, ROR: Bitwise Rotate)
/Dest /section-B.4.275 /OUT pdfmark
[/Title (RSDC: Restore Segment Register and Descriptor)
/Dest /section-B.4.276 /OUT pdfmark
[/Title (RSLDT: Restore Segment Register and Descriptor)
/Dest /section-B.4.277 /OUT pdfmark
[/Title (RSM: Resume from System-Management Mode)
/Dest /section-B.4.278 /OUT pdfmark
[/Title (RSQRTPS: Packed Single-Precision FP Square Root Reciprocal)
/Dest /section-B.4.279 /OUT pdfmark
[/Title (RSQRTSS: Scalar Single-Precision FP Square Root Reciprocal)
/Dest /section-B.4.280 /OUT pdfmark
[/Title (RSTS: Restore TSR and Descriptor)
/Dest /section-B.4.281 /OUT pdfmark
[/Title (SAHF: Store AH to Flags)
/Dest /section-B.4.282 /OUT pdfmark
[/Title (SAL, SAR: Bitwise Arithmetic Shifts)
/Dest /section-B.4.283 /OUT pdfmark
[/Title (SALC: Set AL from Carry Flag)
/Dest /section-B.4.284 /OUT pdfmark
[/Title (SBB: Subtract with Borrow)
/Dest /section-B.4.285 /OUT pdfmark
[/Title (SCASB, SCASW, SCASD: Scan String)
/Dest /section-B.4.286 /OUT pdfmark
[/Title (SETcc: Set Register from Condition)
/Dest /section-B.4.287 /OUT pdfmark
[/Title (SFENCE: Store Fence)
/Dest /section-B.4.288 /OUT pdfmark
[/Title (SGDT, SIDT, SLDT: Store Descriptor Table Pointers)
/Dest /section-B.4.289 /OUT pdfmark
[/Title (SHL, SHR: Bitwise Logical Shifts)
/Dest /section-B.4.290 /OUT pdfmark
[/Title (SHLD, SHRD: Bitwise Double-Precision Shifts)
/Dest /section-B.4.291 /OUT pdfmark
[/Title (SHUFPD: Shuffle Packed Double-Precision FP Values)
/Dest /section-B.4.292 /OUT pdfmark
[/Title (SHUFPS: Shuffle Packed Single-Precision FP Values)
/Dest /section-B.4.293 /OUT pdfmark
[/Title (SMI: System Management Interrupt)
/Dest /section-B.4.294 /OUT pdfmark
[/Title (SMINT, SMINTOLD: Software SMM Entry \(CYRIX\))
/Dest /section-B.4.295 /OUT pdfmark
[/Title (SMSW: Store Machine Status Word)
/Dest /section-B.4.296 /OUT pdfmark
[/Title (SQRTPD: Packed Double-Precision FP Square Root)
/Dest /section-B.4.297 /OUT pdfmark
[/Title (SQRTPS: Packed Single-Precision FP Square Root)
/Dest /section-B.4.298 /OUT pdfmark
[/Title (SQRTSD: Scalar Double-Precision FP Square Root)
/Dest /section-B.4.299 /OUT pdfmark
[/Title (SQRTSS: Scalar Single-Precision FP Square Root)
/Dest /section-B.4.300 /OUT pdfmark
[/Title (STC, STD, STI: Set Flags)
/Dest /section-B.4.301 /OUT pdfmark
[/Title (STMXCSR: Store Streaming SIMD Extension Control/Status)
/Dest /section-B.4.302 /OUT pdfmark
[/Title (STOSB, STOSW, STOSD: Store Byte to String)
/Dest /section-B.4.303 /OUT pdfmark
[/Title (STR: Store Task Register)
/Dest /section-B.4.304 /OUT pdfmark
[/Title (SUB: Subtract Integers)
/Dest /section-B.4.305 /OUT pdfmark
[/Title (SUBPD: Packed Double-Precision FP Subtract)
/Dest /section-B.4.306 /OUT pdfmark
[/Title (SUBPS: Packed Single-Precision FP Subtract)
/Dest /section-B.4.307 /OUT pdfmark
[/Title (SUBSD: Scalar Single-FP Subtract)
/Dest /section-B.4.308 /OUT pdfmark
[/Title (SUBSS: Scalar Single-FP Subtract)
/Dest /section-B.4.309 /OUT pdfmark
[/Title (SVDC: Save Segment Register and Descriptor)
/Dest /section-B.4.310 /OUT pdfmark
[/Title (SVLDT: Save LDTR and Descriptor)
/Dest /section-B.4.311 /OUT pdfmark
[/Title (SVTS: Save TSR and Descriptor)
/Dest /section-B.4.312 /OUT pdfmark
[/Title (SYSCALL: Call Operating System)
/Dest /section-B.4.313 /OUT pdfmark
[/Title (SYSENTER: Fast System Call)
/Dest /section-B.4.314 /OUT pdfmark
[/Title (SYSEXIT: Fast Return From System Call)
/Dest /section-B.4.315 /OUT pdfmark
[/Title (SYSRET: Return From Operating System)
/Dest /section-B.4.316 /OUT pdfmark
[/Title (TEST: Test Bits \(notional bitwise AND\))
/Dest /section-B.4.317 /OUT pdfmark
[/Title (UCOMISD: Unordered Scalar Double-Precision FP compare and set EFLAGS)
/Dest /section-B.4.318 /OUT pdfmark
[/Title (UCOMISS: Unordered Scalar Single-Precision FP compare and set EFLAGS)
/Dest /section-B.4.319 /OUT pdfmark
[/Title (UD0, UD1, UD2: Undefined Instruction)
/Dest /section-B.4.320 /OUT pdfmark
[/Title (UMOV: User Move Data)
/Dest /section-B.4.321 /OUT pdfmark
[/Title (UNPCKHPD: Unpack and Interleave High Packed Double-Precision FP Values)
/Dest /section-B.4.322 /OUT pdfmark
[/Title (UNPCKHPS: Unpack and Interleave High Packed Single-Precision FP Values)
/Dest /section-B.4.323 /OUT pdfmark
[/Title (UNPCKLPD: Unpack and Interleave Low Packed Double-Precision FP Data)
/Dest /section-B.4.324 /OUT pdfmark
[/Title (UNPCKLPS: Unpack and Interleave Low Packed Single-Precision FP Data)
/Dest /section-B.4.325 /OUT pdfmark
[/Title (VERR, VERW: Verify Segment Readability/Writability)
/Dest /section-B.4.326 /OUT pdfmark
[/Title (WAIT: Wait for Floating-Point Processor)
/Dest /section-B.4.327 /OUT pdfmark
[/Title (WBINVD: Write Back and Invalidate Cache)
/Dest /section-B.4.328 /OUT pdfmark
[/Title (WRMSR: Write Model-Specific Registers)
/Dest /section-B.4.329 /OUT pdfmark
[/Title (WRSHR: Write SMM Header Pointer Register)
/Dest /section-B.4.330 /OUT pdfmark
[/Title (XADD: Exchange and Add)
/Dest /section-B.4.331 /OUT pdfmark
[/Title (XBTS: Extract Bit String)
/Dest /section-B.4.332 /OUT pdfmark
[/Title (XCHG: Exchange)
/Dest /section-B.4.333 /OUT pdfmark
[/Title (XLATB: Translate Byte in Lookup Table)
/Dest /section-B.4.334 /OUT pdfmark
[/Title (XOR: Bitwise Exclusive OR)
/Dest /section-B.4.335 /OUT pdfmark
[/Title (XORPD: Bitwise Logical XOR of Double-Precision FP Values)
/Dest /section-B.4.336 /OUT pdfmark
[/Title (XORPS: Bitwise Logical XOR of Single-Precision FP Values)
/Dest /section-B.4.337 /OUT pdfmark
[/Title (Index)
/Dest /index /OUT pdfmark
setpagesize
%%EndSetup
%%Page: 1 1
%%BeginPageSetup
save
%%EndPageSetup
/1 pa
/ti (NASM \227 The Netwide Assembler) def
/sti (version\2400.98.39) def
lmarg pageheight 2 mul 3 div moveto
tfont0 setfont
/title linkdest ti show
lmarg pageheight 2 mul 3 div 10 sub moveto
0 setlinecap 3 setlinewidth
pagewidth lmarg sub rmarg sub 0 rlineto currentpoint stroke moveto
hfont1 setfont sti stringwidth pop neg -14 rmoveto
sti show
BeginEPSF
154.5 363 translate
-99 -45 translate
99 45 moveto
385 45 lineto
385 111 lineto
99 111 lineto
99 45 lineto clip newpath
%%BeginDocument: (nasmlogo.eps)
%!PS-Adobe-3.0 EPSF-3.0
%%BoundingBox: 99 45 385 111
%%DocumentData: Clean7Bit
%%DocumentFonts: Courier-Bold
%%DocumentNeededFonts: Courier-Bold
%%Title: (NASM logo)
%%EndComments
% $Id: nasmlogo.eps,v 1.3 2002/05/14 05:43:47 hpa Exp $
%%Page 1 1
%%BeginPageSetup
save
newpath
%%EndPageSetup
% x y pointsize --
/nasmlogo {
gsave 1 dict begin
/sz exch def
/Courier-Bold findfont sz scalefont setfont
moveto
0.85 1.22 scale
[(-~~..~:#;L       .-:#;L,.-   .~:#:;.T  -~~.~:;. .~:;. )
( E8+U    *T     +U'   *T#  .97     *L   E8+'  *;T'  *;, )
( D97     `*L  .97     '*L   "T;E+:,     D9     *L    *L )
( H7       I#  T7       I#        "*:.   H7     I#    I# )
( U:       :8  *#+    , :8  T,      79   U:     :8    :8 )
(,#B.     .IE,  "T;E*  .IE, J *+;#:T*"  ,#B.   .IE,  .IE,)] {
currentpoint 3 -1 roll
sz -0.10 mul 0 3 -1 roll ashow
sz 0.72 mul sub moveto
} forall
end grestore
} def
0.6 setgray 100 100 12 nasmlogo
%%PageTrailer
restore
%%EndDocument
EndEPSF
restore showpage
%%Page: 2 2
%%BeginPageSetup
save
%%EndPageSetup
/2 pa
[(\251 2003 The NASM Development Team)]164 norm3
[(All rights reserved. This document is redistributable under the licence given in the file "COPYING")]147 norm1
[(distributed in the NASM archive.)]136 norm2
restore showpage
%%Page: 3 3
%%BeginPageSetup
save
%%EndPageSetup
/3 pa
[{/contents xa}(Contents)]644 chap3
[(Introduction)](Chapter 1: )/chapter-1 (20)609 toc03
[(What Is NASM?)](1.1 )/section-1.1 (20)592 toc13
[(Why Yet Another Assembler?)](1.1.1 )/section-1.1.1 (20)575 toc23
[(Licence Conditions)](1.1.2 )/section-1.1.2 (20)558 toc23
[(Contact Information)](1.2 )/section-1.2 (20)541 toc13
[(Installation)](1.3 )/section-1.3 (21)524 toc13
[(Installing NASM under MS-DOS or Windows)](1.3.1 )/section-1.3.1 (21)507 toc23
[(Installing NASM under Unix)](1.3.2 )/section-1.3.2 (21)490 toc23
[(Running NASM)](Chapter 2: )/chapter-2 (23)473 toc03
[(NASM Command-Line Syntax)](2.1 )/section-2.1 (23)456 toc13
[(The )2(-o)0( Option: Specifying the Output File Name)](2.1.1 )/section-2.1.1 (23)439 toc23
[(The )2(-f)0( Option: Specifying the Output File Format)](2.1.2 )/section-2.1.2 (24)422 toc23
[(The )2(-l)0( Option: Generating a Listing File)](2.1.3 )/section-2.1.3 (24)405 toc23
[(The )2(-M)0( Option: Generate Makefile Dependencies.)](2.1.4 )/section-2.1.4 (24)388 toc23
[(The )2(-F)0( Option: Selecting a Debug Information Format)](2.1.5 )/section-2.1.5 (24)371 toc23
[(The )2(-g)0( Option: Enabling Debug Information.)](2.1.6 )/section-2.1.6 (24)354 toc23
[(The )2(-X)0( Option: Selecting an Error Reporting Format)](2.1.7 )/section-2.1.7 (25)337 toc23
[(The )2(-E)0( Option: Send Errors to a File)](2.1.8 )/section-2.1.8 (25)320 toc23
[(The )2(-s)0( Option: Send Errors to )2(stdout)](2.1.9 )/section-2.1.9 (25)303 toc23
[(The )2(-i)0( Option: Include File Search Directories)](2.1.10 )/section-2.1.10 (25)286 toc23
[(The )2(-p)0( Option: Pre-Include a File)](2.1.11 )/section-2.1.11 (26)269 toc23
[(The )2(-d)0( Option: Pre-Define a Macro)](2.1.12 )/section-2.1.12 (26)252 toc23
[(The )2(-u)0( Option: Undefine a Macro)](2.1.13 )/section-2.1.13 (26)235 toc23
[(The )2(-e)0( Option: Preprocess Only)](2.1.14 )/section-2.1.14 (26)218 toc23
[(The )2(-a)0( Option: Don't Preprocess At All)](2.1.15 )/section-2.1.15 (27)201 toc23
[(The )2(-On)0( Option: Specifying Multipass Optimization.)](2.1.16 )/section-2.1.16 (27)184 toc23
[(The )2(-t)0( option: Enable TASM Compatibility Mode)](2.1.17 )/section-2.1.17 (27)167 toc23
[(The )2(-w)0( Option: Enable or Disable Assembly Warnings)](2.1.18 )/section-2.1.18 (28)150 toc23
[(The )2(-v)0( Option: Display Version Info)](2.1.19 )/section-2.1.19 (28)133 toc23
[(The )2(-y)0( Option: Display Available Debug Info Formats)](2.1.20 )/section-2.1.20 (28)116 toc23
(3)pageodd
restore showpage
%%Page: 4 4
%%BeginPageSetup
save
%%EndPageSetup
/4 pa
[(The )2(--prefix)0( and )2(--postfix)0( Options.)](2.1.21 )/section-2.1.21 (28)681 toc23
[(The )2(NASMENV)0( Environment Variable)](2.1.22 )/section-2.1.22 (28)664 toc23
[(Quick Start for MASM Users)](2.2 )/section-2.2 (29)647 toc13
[(NASM Is Case-Sensitive)](2.2.1 )/section-2.2.1 (29)630 toc23
[(NASM Requires Square Brackets For Memory References)](2.2.2 )/section-2.2.2 (29)613 toc23
[(NASM Doesn't Store Variable Types)](2.2.3 )/section-2.2.3 (30)596 toc23
[(NASM Doesn't )2(ASSUME)](2.2.4 )/section-2.2.4 (30)579 toc23
[(NASM Doesn't Support Memory Models)](2.2.5 )/section-2.2.5 (30)562 toc23
[(Floating-Point Differences)](2.2.6 )/section-2.2.6 (30)545 toc23
[(Other Differences)](2.2.7 )/section-2.2.7 (30)528 toc23
[(The NASM Language)](Chapter 3: )/chapter-3 (31)511 toc03
[(Layout of a NASM Source Line)](3.1 )/section-3.1 (31)494 toc13
[(Pseudo-Instructions)](3.2 )/section-3.2 (32)477 toc13
[2(DB)0( and friends: Declaring Initialised Data)](3.2.1 )/section-3.2.1 (32)460 toc23
[2(RESB)0( and friends: Declaring Uninitialised Data)](3.2.2 )/section-3.2.2 (32)443 toc23
[2(INCBIN)0(: Including External Binary Files)](3.2.3 )/section-3.2.3 (32)426 toc23
[2(EQU)0(: Defining Constants)](3.2.4 )/section-3.2.4 (33)409 toc23
[2(TIMES)0(: Repeating Instructions or Data)](3.2.5 )/section-3.2.5 (33)392 toc23
[(Effective Addresses)](3.3 )/section-3.3 (33)375 toc13
[(Constants)](3.4 )/section-3.4 (34)358 toc13
[(Numeric Constants)](3.4.1 )/section-3.4.1 (34)341 toc23
[(Character Constants)](3.4.2 )/section-3.4.2 (35)324 toc23
[(String Constants)](3.4.3 )/section-3.4.3 (35)307 toc23
[(Floating-Point Constants)](3.4.4 )/section-3.4.4 (35)290 toc23
[(Expressions)](3.5 )/section-3.5 (36)273 toc13
[2(|)0(: Bitwise OR Operator)](3.5.1 )/section-3.5.1 (36)256 toc23
[2(^)0(: Bitwise XOR Operator)](3.5.2 )/section-3.5.2 (36)239 toc23
[2(&)0(: Bitwise AND Operator)](3.5.3 )/section-3.5.3 (36)222 toc23
[2(<<)0( and )2(>>)0(: Bit Shift Operators)](3.5.4 )/section-3.5.4 (36)205 toc23
[2(+)0( and )2(-)0(: Addition and Subtraction Operators)](3.5.5 )/section-3.5.5 (36)188 toc23
[2(*)0(, )2(/)0(, )2(//)0(, )2(%)0( and )2(%%)0(: Multiplication and Division)](3.5.6 )/section-3.5.6 (36)171 toc23
[(Unary Operators: )2(+)0(, )2(-)0(, )2(~)0( and )2(SEG)](3.5.7 )/section-3.5.7 (36)154 toc23
[2(SEG)0( and )2(WRT)](3.6 )/section-3.6 (37)137 toc13
[2(STRICT)0(: Inhibiting Optimization)](3.7 )/section-3.7 (37)120 toc13
[(Critical Expressions)](3.8 )/section-3.8 (38)103 toc13
(4)pageeven
restore showpage
%%Page: 5 5
%%BeginPageSetup
save
%%EndPageSetup
/5 pa
[(Local Labels)](3.9 )/section-3.9 (39)681 toc13
[(The NASM Preprocessor)](Chapter 4: )/chapter-4 (41)664 toc03
[(Single-Line Macros)](4.1 )/section-4.1 (41)647 toc13
[(The Normal Way: )2(%define)](4.1.1 )/section-4.1.1 (41)630 toc23
[(Enhancing %define: )2(%xdefine)](4.1.2 )/section-4.1.2 (42)613 toc23
[(Concatenating Single Line Macro Tokens: )2(%+)](4.1.3 )/section-4.1.3 (43)596 toc23
[(Undefining macros: )2(%undef)](4.1.4 )/section-4.1.4 (43)579 toc23
[(Preprocessor Variables: )2(%assign)](4.1.5 )/section-4.1.5 (43)562 toc23
[(String Handling in Macros: )2(%strlen)0( and )2(%substr)](4.2 )/section-4.2 (44)545 toc13
[(String Length: )2(%strlen)](4.2.1 )/section-4.2.1 (44)528 toc23
[(Sub-strings: )2(%substr)](4.2.2 )/section-4.2.2 (44)511 toc23
[(Multi-Line Macros: )2(%macro)](4.3 )/section-4.3 (44)494 toc13
[(Overloading Multi-Line Macros)](4.3.1 )/section-4.3.1 (45)477 toc23
[(Macro-Local Labels)](4.3.2 )/section-4.3.2 (46)460 toc23
[(Greedy Macro Parameters)](4.3.3 )/section-4.3.3 (46)443 toc23
[(Default Macro Parameters)](4.3.4 )/section-4.3.4 (47)426 toc23
[2(%0)0(: Macro Parameter Counter)](4.3.5 )/section-4.3.5 (48)409 toc23
[2(%rotate)0(: Rotating Macro Parameters)](4.3.6 )/section-4.3.6 (48)392 toc23
[(Concatenating Macro Parameters)](4.3.7 )/section-4.3.7 (49)375 toc23
[(Condition Codes as Macro Parameters)](4.3.8 )/section-4.3.8 (50)358 toc23
[(Disabling Listing Expansion)](4.3.9 )/section-4.3.9 (50)341 toc23
[(Conditional Assembly)](4.4 )/section-4.4 (50)324 toc13
[2(%ifdef)0(: Testing Single-Line Macro Existence)](4.4.1 )/section-4.4.1 (51)307 toc23
[2(ifmacro)0(: Testing Multi-Line Macro Existence)](4.4.2 )/section-4.4.2 (51)290 toc23
[2(%ifctx)0(: Testing the Context Stack)](4.4.3 )/section-4.4.3 (51)273 toc23
[2(%if)0(: Testing Arbitrary Numeric Expressions)](4.4.4 )/section-4.4.4 (52)256 toc23
[2(%ifidn)0( and )2(%ifidni)0(: Testing Exact Text Identity)](4.4.5 )/section-4.4.5 (52)239 toc23
[2(%ifid)0(, )2(%ifnum)0(, )2(%ifstr)0(: Testing Token Types)](4.4.6 )/section-4.4.6 (52)222 toc23
[2(%error)0(: Reporting User-Defined Errors)](4.4.7 )/section-4.4.7 (53)205 toc23
[(Preprocessor Loops: )2(%rep)](4.5 )/section-4.5 (54)188 toc13
[(Including Other Files)](4.6 )/section-4.6 (54)171 toc13
[(The Context Stack)](4.7 )/section-4.7 (55)154 toc13
[2(%push)0( and )2(%pop)0(: Creating and Removing Contexts)](4.7.1 )/section-4.7.1 (55)137 toc23
[(Context-Local Labels)](4.7.2 )/section-4.7.2 (55)120 toc23
[(Context-Local Single-Line Macros)](4.7.3 )/section-4.7.3 (56)103 toc23
(5)pageodd
restore showpage
%%Page: 6 6
%%BeginPageSetup
save
%%EndPageSetup
/6 pa
[2(%repl)0(: Renaming a Context)](4.7.4 )/section-4.7.4 (56)681 toc23
[(Example Use of the Context Stack: Block IFs)](4.7.5 )/section-4.7.5 (56)664 toc23
[(Standard Macros)](4.8 )/section-4.8 (58)647 toc13
[2(__NASM_MAJOR__)0(, )2(__NASM_MINOR__)0(, )2(__NASM_SUBMINOR__)0( and)](4.8.1 )/section-4.8.1 630 toc21
[2(___NASM_PATCHLEVEL__)0(: NASM Version)]24.75 (58)619 toc22
[2(__NASM_VERSION_ID__)0(: NASM Version ID)](4.8.2 )/section-4.8.2 (58)602 toc23
[2(__NASM_VER__)0(: NASM Version string)](4.8.3 )/section-4.8.3 (58)585 toc23
[2(__FILE__)0( and )2(__LINE__)0(: File Name and Line Number)](4.8.4 )/section-4.8.4 (58)568 toc23
[2(STRUC)0( and )2(ENDSTRUC)0(: Declaring Structure Data Types)](4.8.5 )/section-4.8.5 (59)551 toc23
[2(ISTRUC)0(, )2(AT)0( and )2(IEND)0(: Declaring Instances of Structures)](4.8.6 )/section-4.8.6 (60)534 toc23
[2(ALIGN)0( and )2(ALIGNB)0(: Data Alignment)](4.8.7 )/section-4.8.7 (60)517 toc23
[(TASM Compatible Preprocessor Directives)](4.9 )/section-4.9 (61)500 toc13
[2(%arg)0( Directive)](4.9.1 )/section-4.9.1 (61)483 toc23
[2(%stacksize)0( Directive)](4.9.2 )/section-4.9.2 (62)466 toc23
[2(%local)0( Directive)](4.9.3 )/section-4.9.3 (62)449 toc23
[(Other Preprocessor Directives)](4.10 )/section-4.10 (63)432 toc13
[2(%line)0( Directive)](4.10.1 )/section-4.10.1 (63)415 toc23
[2(%!<env>)0(: Read an environment variable.)](4.10.2 )/section-4.10.2 (63)398 toc23
[(Assembler Directives)](Chapter 5: )/chapter-5 (65)381 toc03
[2(BITS)0(: Specifying Target Processor Mode)](5.1 )/section-5.1 (65)364 toc13
[2(USE16)0( & )2(USE32)0(: Aliases for BITS)](5.1.1 )/section-5.1.1 (65)347 toc23
[2(SECTION)0( or )2(SEGMENT)0(: Changing and Defining Sections)](5.2 )/section-5.2 (65)330 toc13
[(The )2(__SECT__)0( Macro)](5.2.1 )/section-5.2.1 (66)313 toc23
[2(ABSOLUTE)0(: Defining Absolute Labels)](5.3 )/section-5.3 (66)296 toc13
[2(EXTERN)0(: Importing Symbols from Other Modules)](5.4 )/section-5.4 (67)279 toc13
[2(GLOBAL)0(: Exporting Symbols to Other Modules)](5.5 )/section-5.5 (68)262 toc13
[2(COMMON)0(: Defining Common Data Areas)](5.6 )/section-5.6 (68)245 toc13
[2(CPU)0(: Defining CPU Dependencies)](5.7 )/section-5.7 (68)228 toc13
[(Output Formats)](Chapter 6: )/chapter-6 (70)211 toc03
[2(bin)0(: Flat-Form Binary Output)](6.1 )/section-6.1 (70)194 toc13
[2(ORG)0(: Binary File Program Origin)](6.1.1 )/section-6.1.1 (70)177 toc23
[2(bin)0( Extensions to the )2(SECTION)0( Directive)](6.1.2 )/section-6.1.2 (70)160 toc23
[2(Multisection)0( support for the BIN format.)](6.1.3 )/section-6.1.3 (71)143 toc23
[(Map files)](6.1.4 )/section-6.1.4 (71)126 toc23
[2(obj)0(: Microsoft OMF Object Files)](6.2 )/section-6.2 (71)109 toc13
(6)pageeven
restore showpage
%%Page: 7 7
%%BeginPageSetup
save
%%EndPageSetup
/7 pa
[2(obj)0( Extensions to the )2(SEGMENT)0( Directive)](6.2.1 )/section-6.2.1 (72)681 toc23
[2(GROUP)0(: Defining Groups of Segments)](6.2.2 )/section-6.2.2 (73)664 toc23
[2(UPPERCASE)0(: Disabling Case Sensitivity in Output)](6.2.3 )/section-6.2.3 (73)647 toc23
[2(IMPORT)0(: Importing DLL Symbols)](6.2.4 )/section-6.2.4 (74)630 toc23
[2(EXPORT)0(: Exporting DLL Symbols)](6.2.5 )/section-6.2.5 (74)613 toc23
[2(..start)0(: Defining the Program Entry Point)](6.2.6 )/section-6.2.6 (74)596 toc23
[2(obj)0( Extensions to the )2(EXTERN)0( Directive)](6.2.7 )/section-6.2.7 (75)579 toc23
[2(obj)0( Extensions to the )2(COMMON)0( Directive)](6.2.8 )/section-6.2.8 (75)562 toc23
[2(win32)0(: Microsoft Win32 Object Files)](6.3 )/section-6.3 (76)545 toc13
[2(win32)0( Extensions to the )2(SECTION)0( Directive)](6.3.1 )/section-6.3.1 (76)528 toc23
[2(coff)0(: Common Object File Format)](6.4 )/section-6.4 (77)511 toc13
[2(elf)0(: Executable and Linkable Format Object Files)](6.5 )/section-6.5 (77)494 toc13
[2(elf)0( Extensions to the )2(SECTION)0( Directive)](6.5.1 )/section-6.5.1 (77)477 toc23
[(Position-Independent Code: )2(elf)0( Special Symbols and )2(WRT)](6.5.2 )/section-6.5.2 (77)460 toc23
[2(elf)0( Extensions to the )2(GLOBAL)0( Directive)](6.5.3 )/section-6.5.3 (78)443 toc23
[2(elf)0( Extensions to the )2(COMMON)0( Directive )](6.5.4 )/section-6.5.4 (79)426 toc23
[(16-bit code and ELF )](6.5.5 )/section-6.5.5 (79)409 toc23
[2(aout)0(: Linux )2(a.out)0( Object Files)](6.6 )/section-6.6 (79)392 toc13
[2(aoutb)0(: NetBSD/FreeBSD/OpenBSD )2(a.out)0( Object Files)](6.7 )/section-6.7 (79)375 toc13
[2(as86)0(: Minix/Linux )2(as86)0( Object Files)](6.8 )/section-6.8 (79)358 toc13
[2(rdf)0(: Relocatable Dynamic Object File Format)](6.9 )/section-6.9 (80)341 toc13
[(Requiring a Library: The )2(LIBRARY)0( Directive)](6.9.1 )/section-6.9.1 (80)324 toc23
[(Specifying a Module Name: The )2(MODULE)0( Directive)](6.9.2 )/section-6.9.2 (80)307 toc23
[2(rdf)0( Extensions to the )2(GLOBAL)0( directive)](6.9.3 )/section-6.9.3 (80)290 toc23
[2(rdf)0( Extensions to the )2(EXTERN)0( directive)](6.9.4 )/section-6.9.4 (81)273 toc23
[2(dbg)0(: Debugging Format)](6.10 )/section-6.10 (81)256 toc13
[(Writing 16-bit Code \(DOS, Windows 3/3.1\))](Chapter 7: )/chapter-7 (82)239 toc03
[(Producing )2(.EXE)0( Files)](7.1 )/section-7.1 (82)222 toc13
[(Using the )2(obj)0( Format To Generate )2(.EXE)0( Files)](7.1.1 )/section-7.1.1 (82)205 toc23
[(Using the )2(bin)0( Format To Generate )2(.EXE)0( Files)](7.1.2 )/section-7.1.2 (83)188 toc23
[(Producing )2(.COM)0( Files)](7.2 )/section-7.2 (84)171 toc13
[(Using the )2(bin)0( Format To Generate )2(.COM)0( Files)](7.2.1 )/section-7.2.1 (84)154 toc23
[(Using the )2(obj)0( Format To Generate )2(.COM)0( Files)](7.2.2 )/section-7.2.2 (85)137 toc23
[(Producing )2(.SYS)0( Files)](7.3 )/section-7.3 (85)120 toc13
[(Interfacing to 16-bit C Programs)](7.4 )/section-7.4 (85)103 toc13
(7)pageodd
restore showpage
%%Page: 8 8
%%BeginPageSetup
save
%%EndPageSetup
/8 pa
[(External Symbol Names)](7.4.1 )/section-7.4.1 (85)681 toc23
[(Memory Models)](7.4.2 )/section-7.4.2 (86)664 toc23
[(Function Definitions and Function Calls)](7.4.3 )/section-7.4.3 (87)647 toc23
[(Accessing Data Items)](7.4.4 )/section-7.4.4 (89)630 toc23
[2(c16.mac)0(: Helper Macros for the 16-bit C Interface)](7.4.5 )/section-7.4.5 (90)613 toc23
[(Interfacing to Borland Pascal Programs)](7.5 )/section-7.5 (91)596 toc13
[(The Pascal Calling Convention)](7.5.1 )/section-7.5.1 (91)579 toc23
[(Borland Pascal Segment Name Restrictions)](7.5.2 )/section-7.5.2 (92)562 toc23
[(Using )2(c16.mac)0( With Pascal Programs)](7.5.3 )/section-7.5.3 (93)545 toc23
[(Writing 32-bit Code \(Unix, Win32, DJGPP\))](Chapter 8: )/chapter-8 (94)528 toc03
[(Interfacing to 32-bit C Programs)](8.1 )/section-8.1 (94)511 toc13
[(External Symbol Names)](8.1.1 )/section-8.1.1 (94)494 toc23
[(Function Definitions and Function Calls)](8.1.2 )/section-8.1.2 (94)477 toc23
[(Accessing Data Items)](8.1.3 )/section-8.1.3 (96)460 toc23
[2(c32.mac)0(: Helper Macros for the 32-bit C Interface)](8.1.4 )/section-8.1.4 (96)443 toc23
[(Writing NetBSD/FreeBSD/OpenBSD and Linux/ELF Shared Libraries)](8.2 )/section-8.2 (97)426 toc13
[(Obtaining the Address of the GOT)](8.2.1 )/section-8.2.1 (97)409 toc23
[(Finding Your Local Data Items)](8.2.2 )/section-8.2.2 (98)392 toc23
[(Finding External and Common Data Items)](8.2.3 )/section-8.2.3 (99)375 toc23
[(Exporting Symbols to the Library User)](8.2.4 )/section-8.2.4 (99)358 toc23
[(Calling Procedures Outside the Library)](8.2.5 )/section-8.2.5 (100)341 toc23
[(Generating the Library File)](8.2.6 )/section-8.2.6 (100)324 toc23
[(Mixing 16 and 32 Bit Code)](Chapter 9: )/chapter-9 (101)307 toc03
[(Mixed-Size Jumps)](9.1 )/section-9.1 (101)290 toc13
[(Addressing Between Different-Size Segments)](9.2 )/section-9.2 (101)273 toc13
[(Other Mixed-Size Instructions)](9.3 )/section-9.3 (102)256 toc13
[(Troubleshooting)](Chapter 10: )/chapter-10 (104)239 toc03
[(Common Problems)](10.1 )/section-10.1 (104)222 toc13
[(NASM Generates Inefficient Code)](10.1.1 )/section-10.1.1 (104)205 toc23
[(My Jumps are Out of Range)](10.1.2 )/section-10.1.2 (104)188 toc23
[2(ORG)0( Doesn't Work)](10.1.3 )/section-10.1.3 (104)171 toc23
[2(TIMES)0( Doesn't Work)](10.1.4 )/section-10.1.4 (105)154 toc23
[(Bugs)](10.2 )/section-10.2 (105)137 toc13
[(Ndisasm)](Appendix A: )/appendix-A (107)120 toc03
[(Introduction)](A.1 )/section-A.1 (107)103 toc13
(8)pageeven
restore showpage
%%Page: 9 9
%%BeginPageSetup
save
%%EndPageSetup
/9 pa
[(Getting Started: Installation)](A.2 )/section-A.2 (107)681 toc13
[(Running NDISASM)](A.3 )/section-A.3 (107)664 toc13
[(COM Files: Specifying an Origin)](A.3.1 )/section-A.3.1 (107)647 toc23
[(Code Following Data: Synchronisation)](A.3.2 )/section-A.3.2 (107)630 toc23
[(Mixed Code and Data: Automatic \(Intelligent\) Synchronisation )](A.3.3 )/section-A.3.3 (108)613 toc23
[(Other Options)](A.3.4 )/section-A.3.4 (109)596 toc23
[(Bugs and Improvements)](A.4 )/section-A.4 (109)579 toc13
[(x86 Instruction Reference)](Appendix B: )/appendix-B (110)562 toc03
[(Key to Operand Specifications)](B.1 )/section-B.1 (110)545 toc13
[(Key to Opcode Descriptions)](B.2 )/section-B.2 (110)528 toc13
[(Register Values)](B.2.1 )/section-B.2.1 (111)511 toc23
[(Condition Codes)](B.2.2 )/section-B.2.2 (112)494 toc23
[(SSE Condition Predicates)](B.2.3 )/section-B.2.3 (112)477 toc23
[(Status Flags)](B.2.4 )/section-B.2.4 (113)460 toc23
[(Effective Address Encoding: ModR/M and SIB)](B.2.5 )/section-B.2.5 (114)443 toc23
[(Key to Instruction Flags)](B.3 )/section-B.3 (115)426 toc13
[(x86 Instruction Set)](B.4 )/section-B.4 (116)409 toc13
[2(AAA)0(, )2(AAS)0(, )2(AAM)0(, )2(AAD)0(: ASCII Adjustments)](B.4.1 )/section-B.4.1 (116)392 toc23
[2(ADC)0(: Add with Carry)](B.4.2 )/section-B.4.2 (116)375 toc23
[2(ADD)0(: Add Integers)](B.4.3 )/section-B.4.3 (117)358 toc23
[2(ADDPD)0(: ADD Packed Double-Precision FP Values)](B.4.4 )/section-B.4.4 (118)341 toc23
[2(ADDPS)0(: ADD Packed Single-Precision FP Values)](B.4.5 )/section-B.4.5 (118)324 toc23
[2(ADDSD)0(: ADD Scalar Double-Precision FP Values)](B.4.6 )/section-B.4.6 (118)307 toc23
[2(ADDSS)0(: ADD Scalar Single-Precision FP Values)](B.4.7 )/section-B.4.7 (118)290 toc23
[2(AND)0(: Bitwise AND)](B.4.8 )/section-B.4.8 (118)273 toc23
[2(ANDNPD)0(: Bitwise Logical AND NOT of Packed Double-Precision FP Values)](B.4.9 )/section-B.4.9 (119)256 toc23
[2(ANDNPS)0(: Bitwise Logical AND NOT of Packed Single-Precision FP Values)](B.4.10 )/section-B.4.10 (119)239 toc23
[2(ANDPD)0(: Bitwise Logical AND For Single FP)](B.4.11 )/section-B.4.11 (119)222 toc23
[2(ANDPS)0(: Bitwise Logical AND For Single FP)](B.4.12 )/section-B.4.12 (120)205 toc23
[2(ARPL)0(: Adjust RPL Field of Selector)](B.4.13 )/section-B.4.13 (120)188 toc23
[2(BOUND)0(: Check Array Index against Bounds)](B.4.14 )/section-B.4.14 (120)171 toc23
[2(BSF)0(, )2(BSR)0(: Bit Scan)](B.4.15 )/section-B.4.15 (120)154 toc23
[2(BSWAP)0(: Byte Swap)](B.4.16 )/section-B.4.16 (120)137 toc23
[2(BT)0(, )2(BTC)0(, )2(BTR)0(, )2(BTS)0(: Bit Test)](B.4.17 )/section-B.4.17 (121)120 toc23
[2(CALL)0(: Call Subroutine)](B.4.18 )/section-B.4.18 (121)103 toc23
(9)pageodd
restore showpage
%%Page: 10 10
%%BeginPageSetup
save
%%EndPageSetup
/10 pa
[2(CBW)0(, )2(CWD)0(, )2(CDQ)0(, )2(CWDE)0(: Sign Extensions)](B.4.19 )/section-B.4.19 (122)681 toc23
[2(CLC)0(, )2(CLD)0(, )2(CLI)0(, )2(CLTS)0(: Clear Flags)](B.4.20 )/section-B.4.20 (122)664 toc23
[2(CLFLUSH)0(: Flush Cache Line)](B.4.21 )/section-B.4.21 (122)647 toc23
[2(CMC)0(: Complement Carry Flag)](B.4.22 )/section-B.4.22 (123)630 toc23
[2(CMOVcc)0(: Conditional Move)](B.4.23 )/section-B.4.23 (123)613 toc23
[2(CMP)0(: Compare Integers)](B.4.24 )/section-B.4.24 (123)596 toc23
[2(CMPccPD)0(: Packed Double-Precision FP Compare        )](B.4.25 )/section-B.4.25 (123)579 toc23
[2(CMPccPS)0(: Packed Single-Precision FP Compare        )](B.4.26 )/section-B.4.26 (124)562 toc23
[2(CMPSB)0(, )2(CMPSW)0(, )2(CMPSD)0(: Compare Strings)](B.4.27 )/section-B.4.27 (125)545 toc23
[2(CMPccSD)0(: Scalar Double-Precision FP Compare        )](B.4.28 )/section-B.4.28 (125)528 toc23
[2(CMPccSS)0(: Scalar Single-Precision FP Compare        )](B.4.29 )/section-B.4.29 (126)511 toc23
[2(CMPXCHG)0(, )2(CMPXCHG486)0(: Compare and Exchange)](B.4.30 )/section-B.4.30 (126)494 toc23
[2(CMPXCHG8B)0(: Compare and Exchange Eight Bytes)](B.4.31 )/section-B.4.31 (127)477 toc23
[2(COMISD)0(: Scalar Ordered Double-Precision FP Compare and Set EFLAGS)](B.4.32 )/section-B.4.32 (127)460 toc23
[2(COMISS)0(: Scalar Ordered Single-Precision FP Compare and Set EFLAGS)](B.4.33 )/section-B.4.33 (127)443 toc23
[2(CPUID)0(: Get CPU Identification Code)](B.4.34 )/section-B.4.34 (128)426 toc23
[2(CVTDQ2PD)0(: Packed Signed INT32 to Packed Double-Precision FP Conversion)](B.4.35 )/section-B.4.35 (128)409 toc23
[2(CVTDQ2PS)0(: Packed Signed INT32 to Packed Single-Precision FP Conversion)](B.4.36 )/section-B.4.36 (128)392 toc23
[2(CVTPD2DQ)0(: Packed Double-Precision FP to Packed Signed INT32 Conversion)](B.4.37 )/section-B.4.37 (128)375 toc23
[2(CVTPD2PI)0(: Packed Double-Precision FP to Packed Signed INT32 Conversion)](B.4.38 )/section-B.4.38 (129)358 toc23
[2(CVTPD2PS)0(: Packed Double-Precision FP to Packed Single-Precision FP)](B.4.39 )/section-B.4.39 341 toc21
[(Conversion)]32.087 (129)330 toc22
[2(CVTPI2PD)0(: Packed Signed INT32 to Packed Double-Precision FP Conversion)](B.4.40 )/section-B.4.40 (129)313 toc23
[2(CVTPI2PS)0(: Packed Signed INT32 to Packed Single-FP Conversion)](B.4.41 )/section-B.4.41 (129)296 toc23
[2(CVTPS2DQ)0(: Packed Single-Precision FP to Packed Signed INT32 Conversion)](B.4.42 )/section-B.4.42 (129)279 toc23
[2(CVTPS2PD)0(: Packed Single-Precision FP to Packed Double-Precision FP)](B.4.43 )/section-B.4.43 262 toc21
[(Conversion)]32.087 (130)251 toc22
[2(CVTPS2PI)0(: Packed Single-Precision FP to Packed Signed INT32 Conversion)](B.4.44 )/section-B.4.44 (130)234 toc23
[2(CVTSD2SI)0(: Scalar Double-Precision FP to Signed INT32 Conversion)](B.4.45 )/section-B.4.45 (130)217 toc23
[2(CVTSD2SS)0(: Scalar Double-Precision FP to Scalar Single-Precision FP)](B.4.46 )/section-B.4.46 200 toc21
[(Conversion)]32.087 (130)189 toc22
[2(CVTSI2SD)0(: Signed INT32 to Scalar Double-Precision FP Conversion)](B.4.47 )/section-B.4.47 (130)172 toc23
[2(CVTSI2SS)0(: Signed INT32 to Scalar Single-Precision FP Conversion)](B.4.48 )/section-B.4.48 (131)155 toc23
[2(CVTSS2SD)0(: Scalar Single-Precision FP to Scalar Double-Precision FP)](B.4.49 )/section-B.4.49 138 toc21
[(Conversion)]32.087 (131)127 toc22
[2(CVTSS2SI)0(: Scalar Single-Precision FP to Signed INT32 Conversion)](B.4.50 )/section-B.4.50 (131)110 toc23
(10)pageeven
restore showpage
%%Page: 11 11
%%BeginPageSetup
save
%%EndPageSetup
/11 pa
[2(CVTTPD2DQ)0(: Packed Double-Precision FP to Packed Signed INT32 Conversion)](B.4.51 )/section-B.4.51 681 toc21
[(with Truncation)]32.087 (131)670 toc22
[2(CVTTPD2PI)0(: Packed Double-Precision FP to Packed Signed INT32 Conversion)](B.4.52 )/section-B.4.52 653 toc21
[(with Truncation)]32.087 (131)642 toc22
[2(CVTTPS2DQ)0(: Packed Single-Precision FP to Packed Signed INT32 Conversion)](B.4.53 )/section-B.4.53 625 toc21
[(with Truncation)]32.087 (132)614 toc22
[2(CVTTPS2PI)0(: Packed Single-Precision FP to Packed Signed INT32 Conversion)](B.4.54 )/section-B.4.54 597 toc21
[(with Truncation)]32.087 (132)586 toc22
[2(CVTTSD2SI)0(: Scalar Double-Precision FP to Signed INT32 Conversion with)](B.4.55 )/section-B.4.55 569 toc21
[(Truncation)]32.087 (132)558 toc22
[2(CVTTSS2SI)0(: Scalar Single-Precision FP to Signed INT32 Conversion with)](B.4.56 )/section-B.4.56 541 toc21
[(Truncation)]32.087 (132)530 toc22
[2(DAA)0(, )2(DAS)0(: Decimal Adjustments)](B.4.57 )/section-B.4.57 (132)513 toc23
[2(DEC)0(: Decrement Integer)](B.4.58 )/section-B.4.58 (133)496 toc23
[2(DIV)0(: Unsigned Integer Divide)](B.4.59 )/section-B.4.59 (133)479 toc23
[2(DIVPD)0(: Packed Double-Precision FP Divide)](B.4.60 )/section-B.4.60 (133)462 toc23
[2(DIVPS)0(: Packed Single-Precision FP Divide)](B.4.61 )/section-B.4.61 (134)445 toc23
[2(DIVSD)0(: Scalar Double-Precision FP Divide)](B.4.62 )/section-B.4.62 (134)428 toc23
[2(DIVSS)0(: Scalar Single-Precision FP Divide)](B.4.63 )/section-B.4.63 (134)411 toc23
[2(EMMS)0(: Empty MMX State)](B.4.64 )/section-B.4.64 (134)394 toc23
[2(ENTER)0(: Create Stack Frame)](B.4.65 )/section-B.4.65 (134)377 toc23
[2(F2XM1)0(: Calculate 2**X-1)](B.4.66 )/section-B.4.66 (135)360 toc23
[2(FABS)0(: Floating-Point Absolute Value)](B.4.67 )/section-B.4.67 (135)343 toc23
[2(FADD)0(, )2(FADDP)0(: Floating-Point Addition)](B.4.68 )/section-B.4.68 (135)326 toc23
[2(FBLD)0(, )2(FBSTP)0(: BCD Floating-Point Load and Store)](B.4.69 )/section-B.4.69 (135)309 toc23
[2(FCHS)0(: Floating-Point Change Sign)](B.4.70 )/section-B.4.70 (136)292 toc23
[2(FCLEX)0(, )2(FNCLEX)0(: Clear Floating-Point Exceptions)](B.4.71 )/section-B.4.71 (136)275 toc23
[2(FCMOVcc)0(: Floating-Point Conditional Move)](B.4.72 )/section-B.4.72 (136)258 toc23
[2(FCOM)0(, )2(FCOMP)0(, )2(FCOMPP)0(, )2(FCOMI)0(, )2(FCOMIP)0(: Floating-Point Compare)](B.4.73 )/section-B.4.73 (137)241 toc23
[2(FCOS)0(: Cosine)](B.4.74 )/section-B.4.74 (137)224 toc23
[2(FDECSTP)0(: Decrement Floating-Point Stack Pointer)](B.4.75 )/section-B.4.75 (137)207 toc23
[2(FxDISI)0(, )2(FxENI)0(: Disable and Enable Floating-Point Interrupts)](B.4.76 )/section-B.4.76 (137)190 toc23
[2(FDIV)0(, )2(FDIVP)0(, )2(FDIVR)0(, )2(FDIVRP)0(: Floating-Point Division)](B.4.77 )/section-B.4.77 (138)173 toc23
[2(FEMMS)0(: Faster Enter/Exit of the MMX or floating-point state)](B.4.78 )/section-B.4.78 (138)156 toc23
[2(FFREE)0(: Flag Floating-Point Register as Unused)](B.4.79 )/section-B.4.79 (138)139 toc23
[2(FIADD)0(: Floating-Point/Integer Addition)](B.4.80 )/section-B.4.80 (139)122 toc23
[2(FICOM)0(, )2(FICOMP)0(: Floating-Point/Integer Compare)](B.4.81 )/section-B.4.81 (139)105 toc23
(11)pageodd
restore showpage
%%Page: 12 12
%%BeginPageSetup
save
%%EndPageSetup
/12 pa
[2(FIDIV)0(, )2(FIDIVR)0(: Floating-Point/Integer Division)](B.4.82 )/section-B.4.82 (139)681 toc23
[2(FILD)0(, )2(FIST)0(, )2(FISTP)0(: Floating-Point/Integer Conversion)](B.4.83 )/section-B.4.83 (139)664 toc23
[2(FIMUL)0(: Floating-Point/Integer Multiplication)](B.4.84 )/section-B.4.84 (139)647 toc23
[2(FINCSTP)0(: Increment Floating-Point Stack Pointer)](B.4.85 )/section-B.4.85 (139)630 toc23
[2(FINIT)0(, )2(FNINIT)0(: Initialise Floating-Point Unit)](B.4.86 )/section-B.4.86 (140)613 toc23
[2(FISUB)0(: Floating-Point/Integer Subtraction)](B.4.87 )/section-B.4.87 (140)596 toc23
[2(FLD)0(: Floating-Point Load)](B.4.88 )/section-B.4.88 (140)579 toc23
[2(FLDxx)0(: Floating-Point Load Constants)](B.4.89 )/section-B.4.89 (140)562 toc23
[2(FLDCW)0(: Load Floating-Point Control Word)](B.4.90 )/section-B.4.90 (140)545 toc23
[2(FLDENV)0(: Load Floating-Point Environment)](B.4.91 )/section-B.4.91 (141)528 toc23
[2(FMUL)0(, )2(FMULP)0(: Floating-Point Multiply)](B.4.92 )/section-B.4.92 (141)511 toc23
[2(FNOP)0(: Floating-Point No Operation)](B.4.93 )/section-B.4.93 (141)494 toc23
[2(FPATAN)0(, )2(FPTAN)0(: Arctangent and Tangent)](B.4.94 )/section-B.4.94 (141)477 toc23
[2(FPREM)0(, )2(FPREM1)0(: Floating-Point Partial Remainder)](B.4.95 )/section-B.4.95 (141)460 toc23
[2(FRNDINT)0(: Floating-Point Round to Integer)](B.4.96 )/section-B.4.96 (142)443 toc23
[2(FSAVE)0(, )2(FRSTOR)0(: Save/Restore Floating-Point State)](B.4.97 )/section-B.4.97 (142)426 toc23
[2(FSCALE)0(: Scale Floating-Point Value by Power of Two)](B.4.98 )/section-B.4.98 (142)409 toc23
[2(FSETPM)0(: Set Protected Mode)](B.4.99 )/section-B.4.99 (142)392 toc23
[2(FSIN)0(, )2(FSINCOS)0(: Sine and Cosine)](B.4.100 )/section-B.4.100 (142)375 toc23
[2(FSQRT)0(: Floating-Point Square Root)](B.4.101 )/section-B.4.101 (142)358 toc23
[2(FST)0(, )2(FSTP)0(: Floating-Point Store)](B.4.102 )/section-B.4.102 (143)341 toc23
[2(FSTCW)0(: Store Floating-Point Control Word)](B.4.103 )/section-B.4.103 (143)324 toc23
[2(FSTENV)0(: Store Floating-Point Environment)](B.4.104 )/section-B.4.104 (143)307 toc23
[2(FSTSW)0(: Store Floating-Point Status Word)](B.4.105 )/section-B.4.105 (143)290 toc23
[2(FSUB)0(, )2(FSUBP)0(, )2(FSUBR)0(, )2(FSUBRP)0(: Floating-Point Subtract)](B.4.106 )/section-B.4.106 (143)273 toc23
[2(FTST)0(: Test )2(ST0)0( Against Zero)](B.4.107 )/section-B.4.107 (144)256 toc23
[2(FUCOMxx)0(: Floating-Point Unordered Compare)](B.4.108 )/section-B.4.108 (144)239 toc23
[2(FXAM)0(: Examine Class of Value in )2(ST0)](B.4.109 )/section-B.4.109 (145)222 toc23
[2(FXCH)0(: Floating-Point Exchange)](B.4.110 )/section-B.4.110 (145)205 toc23
[2(FXRSTOR)0(: Restore )2(FP)0(, )2(MMX)0( and )2(SSE)0( State)](B.4.111 )/section-B.4.111 (145)188 toc23
[2(FXSAVE)0(: Store )2(FP)0(, )2(MMX)0( and )2(SSE)0( State)](B.4.112 )/section-B.4.112 (145)171 toc23
[2(FXTRACT)0(: Extract Exponent and Significand)](B.4.113 )/section-B.4.113 (145)154 toc23
[2(FYL2X)0(, )2(FYL2XP1)0(: Compute Y times Log2\(X\) or Log2\(X+1\))](B.4.114 )/section-B.4.114 (146)137 toc23
[2(HLT)0(: Halt Processor)](B.4.115 )/section-B.4.115 (146)120 toc23
[2(IBTS)0(: Insert Bit String)](B.4.116 )/section-B.4.116 (146)103 toc23
(12)pageeven
restore showpage
%%Page: 13 13
%%BeginPageSetup
save
%%EndPageSetup
/13 pa
[2(IDIV)0(: Signed Integer Divide)](B.4.117 )/section-B.4.117 (146)681 toc23
[2(IMUL)0(: Signed Integer Multiply)](B.4.118 )/section-B.4.118 (147)664 toc23
[2(IN)0(: Input from I/O Port)](B.4.119 )/section-B.4.119 (147)647 toc23
[2(INC)0(: Increment Integer)](B.4.120 )/section-B.4.120 (147)630 toc23
[2(INSB)0(, )2(INSW)0(, )2(INSD)0(: Input String from I/O Port)](B.4.121 )/section-B.4.121 (148)613 toc23
[2(INT)0(: Software Interrupt)](B.4.122 )/section-B.4.122 (148)596 toc23
[2(INT3)0(, )2(INT1)0(, )2(ICEBP)0(, )2(INT01)0(: Breakpoints)](B.4.123 )/section-B.4.123 (148)579 toc23
[2(INTO)0(: Interrupt if Overflow)](B.4.124 )/section-B.4.124 (149)562 toc23
[2(INVD)0(: Invalidate Internal Caches)](B.4.125 )/section-B.4.125 (149)545 toc23
[2(INVLPG)0(: Invalidate TLB Entry)](B.4.126 )/section-B.4.126 (149)528 toc23
[2(IRET)0(, )2(IRETW)0(, )2(IRETD)0(: Return from Interrupt)](B.4.127 )/section-B.4.127 (149)511 toc23
[2(Jcc)0(: Conditional Branch)](B.4.128 )/section-B.4.128 (149)494 toc23
[2(JCXZ)0(, )2(JECXZ)0(: Jump if CX/ECX Zero)](B.4.129 )/section-B.4.129 (149)477 toc23
[2(JMP)0(: Jump)](B.4.130 )/section-B.4.130 (150)460 toc23
[2(LAHF)0(: Load AH from Flags)](B.4.131 )/section-B.4.131 (150)443 toc23
[2(LAR)0(: Load Access Rights)](B.4.132 )/section-B.4.132 (150)426 toc23
[2(LDMXCSR)0(: Load Streaming SIMD Extension Control/Status)](B.4.133 )/section-B.4.133 (151)409 toc23
[2(LDS)0(, )2(LES)0(, )2(LFS)0(, )2(LGS)0(, )2(LSS)0(: Load Far Pointer)](B.4.134 )/section-B.4.134 (151)392 toc23
[2(LEA)0(: Load Effective Address)](B.4.135 )/section-B.4.135 (151)375 toc23
[2(LEAVE)0(: Destroy Stack Frame)](B.4.136 )/section-B.4.136 (151)358 toc23
[2(LFENCE)0(: Load Fence)](B.4.137 )/section-B.4.137 (152)341 toc23
[2(LGDT)0(, )2(LIDT)0(, )2(LLDT)0(: Load Descriptor Tables)](B.4.138 )/section-B.4.138 (152)324 toc23
[2(LMSW)0(: Load/Store Machine Status Word)](B.4.139 )/section-B.4.139 (152)307 toc23
[2(LOADALL)0(, )2(LOADALL286)0(: Load Processor State)](B.4.140 )/section-B.4.140 (152)290 toc23
[2(LODSB)0(, )2(LODSW)0(, )2(LODSD)0(: Load from String)](B.4.141 )/section-B.4.141 (153)273 toc23
[2(LOOP)0(, )2(LOOPE)0(, )2(LOOPZ)0(, )2(LOOPNE)0(, )2(LOOPNZ)0(: Loop with Counter)](B.4.142 )/section-B.4.142 (153)256 toc23
[2(LSL)0(: Load Segment Limit)](B.4.143 )/section-B.4.143 (153)239 toc23
[2(LTR)0(: Load Task Register)](B.4.144 )/section-B.4.144 (154)222 toc23
[2(MASKMOVDQU)0(: Byte Mask Write)](B.4.145 )/section-B.4.145 (154)205 toc23
[2(MASKMOVQ)0(: Byte Mask Write)](B.4.146 )/section-B.4.146 (154)188 toc23
[2(MAXPD)0(: Return Packed Double-Precision FP Maximum)](B.4.147 )/section-B.4.147 (154)171 toc23
[2(MAXPS)0(: Return Packed Single-Precision FP Maximum)](B.4.148 )/section-B.4.148 (154)154 toc23
[2(MAXSD)0(: Return Scalar Double-Precision FP Maximum)](B.4.149 )/section-B.4.149 (154)137 toc23
[2(MAXSS)0(: Return Scalar Single-Precision FP Maximum)](B.4.150 )/section-B.4.150 (154)120 toc23
[2(MFENCE)0(: Memory Fence)](B.4.151 )/section-B.4.151 (155)103 toc23
(13)pageodd
restore showpage
%%Page: 14 14
%%BeginPageSetup
save
%%EndPageSetup
/14 pa
[2(MINPD)0(: Return Packed Double-Precision FP Minimum)](B.4.152 )/section-B.4.152 (155)681 toc23
[2(MINPS)0(: Return Packed Single-Precision FP Minimum)](B.4.153 )/section-B.4.153 (155)664 toc23
[2(MINSD)0(: Return Scalar Double-Precision FP Minimum)](B.4.154 )/section-B.4.154 (155)647 toc23
[2(MINSS)0(: Return Scalar Single-Precision FP Minimum)](B.4.155 )/section-B.4.155 (155)630 toc23
[2(MOV)0(: Move Data)](B.4.156 )/section-B.4.156 (156)613 toc23
[2(MOVAPD)0(: Move Aligned Packed Double-Precision FP Values)](B.4.157 )/section-B.4.157 (156)596 toc23
[2(MOVAPS)0(: Move Aligned Packed Single-Precision FP Values)](B.4.158 )/section-B.4.158 (157)579 toc23
[2(MOVD)0(: Move Doubleword to/from MMX Register)](B.4.159 )/section-B.4.159 (157)562 toc23
[2(MOVDQ2Q)0(: Move Quadword from XMM to MMX register.)](B.4.160 )/section-B.4.160 (157)545 toc23
[2(MOVDQA)0(: Move Aligned Double Quadword)](B.4.161 )/section-B.4.161 (157)528 toc23
[2(MOVDQU)0(: Move Unaligned Double Quadword)](B.4.162 )/section-B.4.162 (157)511 toc23
[2(MOVHLPS)0(: Move Packed Single-Precision FP High to Low)](B.4.163 )/section-B.4.163 (157)494 toc23
[2(MOVHPD)0(: Move High Packed Double-Precision FP)](B.4.164 )/section-B.4.164 (158)477 toc23
[2(MOVHPS)0(: Move High Packed Single-Precision FP)](B.4.165 )/section-B.4.165 (158)460 toc23
[2(MOVLHPS)0(: Move Packed Single-Precision FP Low to High)](B.4.166 )/section-B.4.166 (158)443 toc23
[2(MOVLPD)0(: Move Low Packed Double-Precision FP)](B.4.167 )/section-B.4.167 (158)426 toc23
[2(MOVLPS)0(: Move Low Packed Single-Precision FP)](B.4.168 )/section-B.4.168 (159)409 toc23
[2(MOVMSKPD)0(: Extract Packed Double-Precision FP Sign Mask)](B.4.169 )/section-B.4.169 (159)392 toc23
[2(MOVMSKPS)0(: Extract Packed Single-Precision FP Sign Mask)](B.4.170 )/section-B.4.170 (159)375 toc23
[2(MOVNTDQ)0(: Move Double Quadword Non Temporal)](B.4.171 )/section-B.4.171 (159)358 toc23
[2(MOVNTI)0(: Move Doubleword Non Temporal)](B.4.172 )/section-B.4.172 (159)341 toc23
[2(MOVNTPD)0(: Move Aligned Four Packed Single-Precision FP Values Non)](B.4.173 )/section-B.4.173 324 toc21
[(Temporal)]37.587 (159)313 toc22
[2(MOVNTPS)0(: Move Aligned Four Packed Single-Precision FP Values Non)](B.4.174 )/section-B.4.174 296 toc21
[(Temporal)]37.587 (160)285 toc22
[2(MOVNTQ)0(: Move Quadword Non Temporal)](B.4.175 )/section-B.4.175 (160)268 toc23
[2(MOVQ)0(: Move Quadword to/from MMX Register)](B.4.176 )/section-B.4.176 (160)251 toc23
[2(MOVQ2DQ)0(: Move Quadword from MMX to XMM register.)](B.4.177 )/section-B.4.177 (160)234 toc23
[2(MOVSB)0(, )2(MOVSW)0(, )2(MOVSD)0(: Move String)](B.4.178 )/section-B.4.178 (160)217 toc23
[2(MOVSD)0(: Move Scalar Double-Precision FP Value)](B.4.179 )/section-B.4.179 (160)200 toc23
[2(MOVSS)0(: Move Scalar Single-Precision FP Value)](B.4.180 )/section-B.4.180 (161)183 toc23
[2(MOVSX)0(, )2(MOVZX)0(: Move Data with Sign or Zero Extend)](B.4.181 )/section-B.4.181 (161)166 toc23
[2(MOVUPD)0(: Move Unaligned Packed Double-Precision FP Values)](B.4.182 )/section-B.4.182 (161)149 toc23
[2(MOVUPS)0(: Move Unaligned Packed Single-Precision FP Values)](B.4.183 )/section-B.4.183 (161)132 toc23
[2(MUL)0(: Unsigned Integer Multiply)](B.4.184 )/section-B.4.184 (161)115 toc23
(14)pageeven
restore showpage
%%Page: 15 15
%%BeginPageSetup
save
%%EndPageSetup
/15 pa
[2(MULPD)0(: Packed Single-FP Multiply)](B.4.185 )/section-B.4.185 (162)681 toc23
[2(MULPS)0(: Packed Single-FP Multiply)](B.4.186 )/section-B.4.186 (162)664 toc23
[2(MULSD)0(: Scalar Single-FP Multiply)](B.4.187 )/section-B.4.187 (162)647 toc23
[2(MULSS)0(: Scalar Single-FP Multiply)](B.4.188 )/section-B.4.188 (162)630 toc23
[2(NEG)0(, )2(NOT)0(: Two's and One's Complement)](B.4.189 )/section-B.4.189 (162)613 toc23
[2(NOP)0(: No Operation)](B.4.190 )/section-B.4.190 (162)596 toc23
[2(OR)0(: Bitwise OR)](B.4.191 )/section-B.4.191 (162)579 toc23
[2(ORPD)0(: Bit-wise Logical OR of Double-Precision FP Data)](B.4.192 )/section-B.4.192 (163)562 toc23
[2(ORPS)0(: Bit-wise Logical OR of Single-Precision FP Data)](B.4.193 )/section-B.4.193 (163)545 toc23
[2(OUT)0(: Output Data to I/O Port)](B.4.194 )/section-B.4.194 (163)528 toc23
[2(OUTSB)0(, )2(OUTSW)0(, )2(OUTSD)0(: Output String to I/O Port)](B.4.195 )/section-B.4.195 (163)511 toc23
[2(PACKSSDW)0(, )2(PACKSSWB)0(, )2(PACKUSWB)0(: Pack Data)](B.4.196 )/section-B.4.196 (164)494 toc23
[2(PADDB)0(, )2(PADDW)0(, )2(PADDD)0(: Add Packed Integers)](B.4.197 )/section-B.4.197 (164)477 toc23
[2(PADDQ)0(: Add Packed Quadword Integers)](B.4.198 )/section-B.4.198 (165)460 toc23
[2(PADDSB)0(, )2(PADDSW)0(: Add Packed Signed Integers With Saturation)](B.4.199 )/section-B.4.199 (165)443 toc23
[2(PADDSIW)0(: MMX Packed Addition to Implicit Destination)](B.4.200 )/section-B.4.200 (165)426 toc23
[2(PADDUSB)0(, )2(PADDUSW)0(: Add Packed Unsigned Integers With Saturation)](B.4.201 )/section-B.4.201 (165)409 toc23
[2(PAND)0(, )2(PANDN)0(: MMX Bitwise AND and AND-NOT)](B.4.202 )/section-B.4.202 (165)392 toc23
[2(PAUSE)0(: Spin Loop Hint)](B.4.203 )/section-B.4.203 (166)375 toc23
[2(PAVEB)0(: MMX Packed Average)](B.4.204 )/section-B.4.204 (166)358 toc23
[2(PAVGB)0( )2(PAVGW)0(: Average Packed Integers)](B.4.205 )/section-B.4.205 (166)341 toc23
[2(PAVGUSB)0(: Average of unsigned packed 8-bit values)](B.4.206 )/section-B.4.206 (166)324 toc23
[2(PCMPxx)0(: Compare Packed Integers.)](B.4.207 )/section-B.4.207 (166)307 toc23
[2(PDISTIB)0(: MMX Packed Distance and Accumulate with Implied Register)](B.4.208 )/section-B.4.208 (167)290 toc23
[2(PEXTRW)0(: Extract Word)](B.4.209 )/section-B.4.209 (167)273 toc23
[2(PF2ID)0(: Packed Single-Precision FP to Integer Convert)](B.4.210 )/section-B.4.210 (168)256 toc23
[2(PF2IW)0(: Packed Single-Precision FP to Integer Word Convert)](B.4.211 )/section-B.4.211 (168)239 toc23
[2(PFACC)0(: Packed Single-Precision FP Accumulate)](B.4.212 )/section-B.4.212 (168)222 toc23
[2(PFADD)0(: Packed Single-Precision FP Addition)](B.4.213 )/section-B.4.213 (168)205 toc23
[2(PFCMPxx)0(: Packed Single-Precision FP Compare   )](B.4.214 )/section-B.4.214 (168)188 toc23
[2(PFMAX)0(: Packed Single-Precision FP Maximum)](B.4.215 )/section-B.4.215 (169)171 toc23
[2(PFMIN)0(: Packed Single-Precision FP Minimum)](B.4.216 )/section-B.4.216 (169)154 toc23
[2(PFMUL)0(: Packed Single-Precision FP Multiply)](B.4.217 )/section-B.4.217 (169)137 toc23
[2(PFNACC)0(: Packed Single-Precision FP Negative Accumulate)](B.4.218 )/section-B.4.218 (169)120 toc23
[2(PFPNACC)0(: Packed Single-Precision FP Mixed Accumulate)](B.4.219 )/section-B.4.219 (169)103 toc23
(15)pageodd
restore showpage
%%Page: 16 16
%%BeginPageSetup
save
%%EndPageSetup
/16 pa
[2(PFRCP)0(: Packed Single-Precision FP Reciprocal Approximation)](B.4.220 )/section-B.4.220 (169)681 toc23
[2(PFRCPIT1)0(: Packed Single-Precision FP Reciprocal, First Iteration Step)](B.4.221 )/section-B.4.221 (170)664 toc23
[2(PFRCPIT2)0(: Packed Single-Precision FP Reciprocal/ Reciprocal Square Root,)](B.4.222 )/section-B.4.222 647 toc21
[(Second Iteration Step)]37.587 (170)636 toc22
[2(PFRSQIT1)0(: Packed Single-Precision FP Reciprocal Square Root, First)](B.4.223 )/section-B.4.223 619 toc21
[(Iteration Step)]37.587 (170)608 toc22
[2(PFRSQRT)0(: Packed Single-Precision FP Reciprocal Square Root Approximation)](B.4.224 )/section-B.4.224 (170)591 toc23
[2(PFSUB)0(: Packed Single-Precision FP Subtract)](B.4.225 )/section-B.4.225 (170)574 toc23
[2(PFSUBR)0(: Packed Single-Precision FP Reverse Subtract)](B.4.226 )/section-B.4.226 (170)557 toc23
[2(PI2FD)0(: Packed Doubleword Integer to Single-Precision FP Convert)](B.4.227 )/section-B.4.227 (171)540 toc23
[2(PF2IW)0(: Packed Word Integer to Single-Precision FP Convert)](B.4.228 )/section-B.4.228 (171)523 toc23
[2(PINSRW)0(: Insert Word)](B.4.229 )/section-B.4.229 (171)506 toc23
[2(PMACHRIW)0(: Packed Multiply and Accumulate with Rounding)](B.4.230 )/section-B.4.230 (171)489 toc23
[2(PMADDWD)0(: MMX Packed Multiply and Add)](B.4.231 )/section-B.4.231 (171)472 toc23
[2(PMAGW)0(: MMX Packed Magnitude)](B.4.232 )/section-B.4.232 (172)455 toc23
[2(PMAXSW)0(: Packed Signed Integer Word Maximum)](B.4.233 )/section-B.4.233 (172)438 toc23
[2(PMAXUB)0(: Packed Unsigned Integer Byte Maximum)](B.4.234 )/section-B.4.234 (172)421 toc23
[2(PMINSW)0(: Packed Signed Integer Word Minimum)](B.4.235 )/section-B.4.235 (172)404 toc23
[2(PMINUB)0(: Packed Unsigned Integer Byte Minimum)](B.4.236 )/section-B.4.236 (172)387 toc23
[2(PMOVMSKB)0(: Move Byte Mask To Integer)](B.4.237 )/section-B.4.237 (172)370 toc23
[2(PMULHRWC)0(, )2(PMULHRIW)0(: Multiply Packed 16-bit Integers With Rounding, and)](B.4.238 )/section-B.4.238 353 toc21
[(Store High Word)]37.587 (173)342 toc22
[2(PMULHRWA)0(: Multiply Packed 16-bit Integers With Rounding, and Store High)](B.4.239 )/section-B.4.239 325 toc21
[(Word)]37.587 (173)314 toc22
[2(PMULHUW)0(: Multiply Packed 16-bit Integers, and Store High Word)](B.4.240 )/section-B.4.240 (173)297 toc23
[2(PMULHW)0(, )2(PMULLW)0(: Multiply Packed 16-bit Integers, and Store)](B.4.241 )/section-B.4.241 (173)280 toc23
[2(PMULUDQ)0(: Multiply Packed Unsigned 32-bit Integers, and Store.)](B.4.242 )/section-B.4.242 (174)263 toc23
[2(PMVccZB)0(: MMX Packed Conditional Move)](B.4.243 )/section-B.4.243 (174)246 toc23
[2(POP)0(: Pop Data from Stack)](B.4.244 )/section-B.4.244 (174)229 toc23
[2(POPAx)0(: Pop All General-Purpose Registers)](B.4.245 )/section-B.4.245 (175)212 toc23
[2(POPFx)0(: Pop Flags Register)](B.4.246 )/section-B.4.246 (175)195 toc23
[2(POR)0(: MMX Bitwise OR)](B.4.247 )/section-B.4.247 (175)178 toc23
[2(PREFETCH)0(: Prefetch Data Into Caches)](B.4.248 )/section-B.4.248 (175)161 toc23
[2(PREFETCHh)0(: Prefetch Data Into Caches    )](B.4.249 )/section-B.4.249 (176)144 toc23
[2(PSADBW)0(: Packed Sum of Absolute Differences)](B.4.250 )/section-B.4.250 (176)127 toc23
[2(PSHUFD)0(: Shuffle Packed Doublewords)](B.4.251 )/section-B.4.251 (176)110 toc23
(16)pageeven
restore showpage
%%Page: 17 17
%%BeginPageSetup
save
%%EndPageSetup
/17 pa
[2(PSHUFHW)0(: Shuffle Packed High Words)](B.4.252 )/section-B.4.252 (176)681 toc23
[2(PSHUFLW)0(: Shuffle Packed Low Words)](B.4.253 )/section-B.4.253 (177)664 toc23
[2(PSHUFW)0(: Shuffle Packed Words)](B.4.254 )/section-B.4.254 (177)647 toc23
[2(PSLLx)0(: Packed Data Bit Shift Left Logical)](B.4.255 )/section-B.4.255 (177)630 toc23
[2(PSRAx)0(: Packed Data Bit Shift Right Arithmetic)](B.4.256 )/section-B.4.256 (177)613 toc23
[2(PSRLx)0(: Packed Data Bit Shift Right Logical)](B.4.257 )/section-B.4.257 (178)596 toc23
[2(PSUBx)0(: Subtract Packed Integers)](B.4.258 )/section-B.4.258 (178)579 toc23
[2(PSUBSxx)0(, )2(PSUBUSx)0(: Subtract Packed Integers With Saturation)](B.4.259 )/section-B.4.259 (179)562 toc23
[2(PSUBSIW)0(: MMX Packed Subtract with Saturation to Implied Destination)](B.4.260 )/section-B.4.260 (179)545 toc23
[2(PSWAPD)0(: Swap Packed Data )](B.4.261 )/section-B.4.261 (179)528 toc23
[2(PUNPCKxxx)0(: Unpack and Interleave Data)](B.4.262 )/section-B.4.262 (180)511 toc23
[2(PUSH)0(: Push Data on Stack)](B.4.263 )/section-B.4.263 (180)494 toc23
[2(PUSHAx)0(: Push All General-Purpose Registers)](B.4.264 )/section-B.4.264 (181)477 toc23
[2(PUSHFx)0(: Push Flags Register)](B.4.265 )/section-B.4.265 (181)460 toc23
[2(PXOR)0(: MMX Bitwise XOR)](B.4.266 )/section-B.4.266 (182)443 toc23
[2(RCL)0(, )2(RCR)0(: Bitwise Rotate through Carry Bit)](B.4.267 )/section-B.4.267 (182)426 toc23
[2(RCPPS)0(: Packed Single-Precision FP Reciprocal)](B.4.268 )/section-B.4.268 (182)409 toc23
[2(RCPSS)0(: Scalar Single-Precision FP Reciprocal)](B.4.269 )/section-B.4.269 (183)392 toc23
[2(RDMSR)0(: Read Model-Specific Registers)](B.4.270 )/section-B.4.270 (183)375 toc23
[2(RDPMC)0(: Read Performance-Monitoring Counters)](B.4.271 )/section-B.4.271 (183)358 toc23
[2(RDSHR)0(: Read SMM Header Pointer Register)](B.4.272 )/section-B.4.272 (183)341 toc23
[2(RDTSC)0(: Read Time-Stamp Counter)](B.4.273 )/section-B.4.273 (183)324 toc23
[2(RET)0(, )2(RETF)0(, )2(RETN)0(: Return from Procedure Call)](B.4.274 )/section-B.4.274 (183)307 toc23
[2(ROL)0(, )2(ROR)0(: Bitwise Rotate)](B.4.275 )/section-B.4.275 (183)290 toc23
[2(RSDC)0(: Restore Segment Register and Descriptor)](B.4.276 )/section-B.4.276 (184)273 toc23
[2(RSLDT)0(: Restore Segment Register and Descriptor)](B.4.277 )/section-B.4.277 (184)256 toc23
[2(RSM)0(: Resume from System-Management Mode)](B.4.278 )/section-B.4.278 (184)239 toc23
[2(RSQRTPS)0(: Packed Single-Precision FP Square Root Reciprocal)](B.4.279 )/section-B.4.279 (184)222 toc23
[2(RSQRTSS)0(: Scalar Single-Precision FP Square Root Reciprocal)](B.4.280 )/section-B.4.280 (184)205 toc23
[2(RSTS)0(: Restore TSR and Descriptor)](B.4.281 )/section-B.4.281 (185)188 toc23
[2(SAHF)0(: Store AH to Flags)](B.4.282 )/section-B.4.282 (185)171 toc23
[2(SAL)0(, )2(SAR)0(: Bitwise Arithmetic Shifts)](B.4.283 )/section-B.4.283 (185)154 toc23
[2(SALC)0(: Set AL from Carry Flag)](B.4.284 )/section-B.4.284 (185)137 toc23
[2(SBB)0(: Subtract with Borrow)](B.4.285 )/section-B.4.285 (186)120 toc23
[2(SCASB)0(, )2(SCASW)0(, )2(SCASD)0(: Scan String)](B.4.286 )/section-B.4.286 (186)103 toc23
(17)pageodd
restore showpage
%%Page: 18 18
%%BeginPageSetup
save
%%EndPageSetup
/18 pa
[2(SETcc)0(: Set Register from Condition)](B.4.287 )/section-B.4.287 (186)681 toc23
[2(SFENCE)0(: Store Fence)](B.4.288 )/section-B.4.288 (187)664 toc23
[2(SGDT)0(, )2(SIDT)0(, )2(SLDT)0(: Store Descriptor Table Pointers)](B.4.289 )/section-B.4.289 (187)647 toc23
[2(SHL)0(, )2(SHR)0(: Bitwise Logical Shifts)](B.4.290 )/section-B.4.290 (187)630 toc23
[2(SHLD)0(, )2(SHRD)0(: Bitwise Double-Precision Shifts)](B.4.291 )/section-B.4.291 (188)613 toc23
[2(SHUFPD)0(: Shuffle Packed Double-Precision FP Values)](B.4.292 )/section-B.4.292 (188)596 toc23
[2(SHUFPS)0(: Shuffle Packed Single-Precision FP Values)](B.4.293 )/section-B.4.293 (189)579 toc23
[2(SMI)0(: System Management Interrupt)](B.4.294 )/section-B.4.294 (189)562 toc23
[2(SMINT)0(, )2(SMINTOLD)0(: Software SMM Entry \(CYRIX\))](B.4.295 )/section-B.4.295 (189)545 toc23
[2(SMSW)0(: Store Machine Status Word)](B.4.296 )/section-B.4.296 (189)528 toc23
[2(SQRTPD)0(: Packed Double-Precision FP Square Root)](B.4.297 )/section-B.4.297 (189)511 toc23
[2(SQRTPS)0(: Packed Single-Precision FP Square Root)](B.4.298 )/section-B.4.298 (189)494 toc23
[2(SQRTSD)0(: Scalar Double-Precision FP Square Root)](B.4.299 )/section-B.4.299 (189)477 toc23
[2(SQRTSS)0(: Scalar Single-Precision FP Square Root)](B.4.300 )/section-B.4.300 (190)460 toc23
[2(STC)0(, )2(STD)0(, )2(STI)0(: Set Flags)](B.4.301 )/section-B.4.301 (190)443 toc23
[2(STMXCSR)0(: Store Streaming SIMD Extension Control/Status)](B.4.302 )/section-B.4.302 (190)426 toc23
[2(STOSB)0(, )2(STOSW)0(, )2(STOSD)0(: Store Byte to String)](B.4.303 )/section-B.4.303 (190)409 toc23
[2(STR)0(: Store Task Register)](B.4.304 )/section-B.4.304 (190)392 toc23
[2(SUB)0(: Subtract Integers)](B.4.305 )/section-B.4.305 (191)375 toc23
[2(SUBPD)0(: Packed Double-Precision FP Subtract)](B.4.306 )/section-B.4.306 (191)358 toc23
[2(SUBPS)0(: Packed Single-Precision FP Subtract)](B.4.307 )/section-B.4.307 (191)341 toc23
[2(SUBSD)0(: Scalar Single-FP Subtract)](B.4.308 )/section-B.4.308 (191)324 toc23
[2(SUBSS)0(: Scalar Single-FP Subtract)](B.4.309 )/section-B.4.309 (191)307 toc23
[2(SVDC)0(: Save Segment Register and Descriptor)](B.4.310 )/section-B.4.310 (192)290 toc23
[2(SVLDT)0(: Save LDTR and Descriptor)](B.4.311 )/section-B.4.311 (192)273 toc23
[2(SVTS)0(: Save TSR and Descriptor)](B.4.312 )/section-B.4.312 (192)256 toc23
[2(SYSCALL)0(: Call Operating System)](B.4.313 )/section-B.4.313 (192)239 toc23
[2(SYSENTER)0(: Fast System Call)](B.4.314 )/section-B.4.314 (192)222 toc23
[2(SYSEXIT)0(: Fast Return From System Call)](B.4.315 )/section-B.4.315 (193)205 toc23
[2(SYSRET)0(: Return From Operating System)](B.4.316 )/section-B.4.316 (193)188 toc23
[2(TEST)0(: Test Bits \(notional bitwise AND\))](B.4.317 )/section-B.4.317 (194)171 toc23
[2(UCOMISD)0(: Unordered Scalar Double-Precision FP compare and set EFLAGS)](B.4.318 )/section-B.4.318 (194)154 toc23
[2(UCOMISS)0(: Unordered Scalar Single-Precision FP compare and set EFLAGS)](B.4.319 )/section-B.4.319 (194)137 toc23
[2(UD0)0(, )2(UD1)0(, )2(UD2)0(: Undefined Instruction)](B.4.320 )/section-B.4.320 (194)120 toc23
[2(UMOV)0(: User Move Data)](B.4.321 )/section-B.4.321 (195)103 toc23
(18)pageeven
restore showpage
%%Page: 19 19
%%BeginPageSetup
save
%%EndPageSetup
/19 pa
[2(UNPCKHPD)0(: Unpack and Interleave High Packed Double-Precision FP Values)](B.4.322 )/section-B.4.322 (195)681 toc23
[2(UNPCKHPS)0(: Unpack and Interleave High Packed Single-Precision FP Values)](B.4.323 )/section-B.4.323 (195)664 toc23
[2(UNPCKLPD)0(: Unpack and Interleave Low Packed Double-Precision FP Data)](B.4.324 )/section-B.4.324 (195)647 toc23
[2(UNPCKLPS)0(: Unpack and Interleave Low Packed Single-Precision FP Data)](B.4.325 )/section-B.4.325 (195)630 toc23
[2(VERR)0(, )2(VERW)0(: Verify Segment Readability/Writability)](B.4.326 )/section-B.4.326 (196)613 toc23
[2(WAIT)0(: Wait for Floating-Point Processor)](B.4.327 )/section-B.4.327 (196)596 toc23
[2(WBINVD)0(: Write Back and Invalidate Cache)](B.4.328 )/section-B.4.328 (196)579 toc23
[2(WRMSR)0(: Write Model-Specific Registers)](B.4.329 )/section-B.4.329 (196)562 toc23
[2(WRSHR)0(: Write SMM Header Pointer Register)](B.4.330 )/section-B.4.330 (196)545 toc23
[2(XADD)0(: Exchange and Add)](B.4.331 )/section-B.4.331 (196)528 toc23
[2(XBTS)0(: Extract Bit String)](B.4.332 )/section-B.4.332 (197)511 toc23
[2(XCHG)0(: Exchange)](B.4.333 )/section-B.4.333 (197)494 toc23
[2(XLATB)0(: Translate Byte in Lookup Table)](B.4.334 )/section-B.4.334 (197)477 toc23
[2(XOR)0(: Bitwise Exclusive OR)](B.4.335 )/section-B.4.335 (197)460 toc23
[2(XORPD)0(: Bitwise Logical XOR of Double-Precision FP Values)](B.4.336 )/section-B.4.336 (198)443 toc23
[2(XORPS)0(: Bitwise Logical XOR of Single-Precision FP Values)](B.4.337 )/section-B.4.337 (198)426 toc23
(19)pageodd
restore showpage
%%Page: 20 20
%%BeginPageSetup
save
%%EndPageSetup
/20 pa
[{/chapter-1 xa}(Chapter 1: Introduction)]644 chap3
[{/section-1.1 xa}(What Is NASM?)](1.1)606 head3
[(The Netwide Assembler, NASM, is an 80x86 assembler designed for portability and modularity. It)]589 norm1
[(supports a range of object file formats, including Linux and )2(NetBSD/FreeBSD)0( )2(a.out)0(, )2(ELF)0(,)]578 norm0
[2(COFF)0(, Microsoft 16-bit )2(OBJ)0( and )2(Win32)0(. It will also output plain binary files. Its syntax is)]567 norm0
[(designed to be simple and easy to understand, similar to Intel's but less complex. It supports)]556 norm0
[2(Pentium)0(, )2(P6)0(, )2(MMX)0(, )2(3DNow!)0(, )2(SSE)0( and )2(SSE2)0( opcodes, and has macro capability.)]545 norm2
[{/section-1.1.1 xa}(Why Yet Another Assembler?)](1.1.1)527 subh3
[(The Netwide Assembler grew out of an idea on )2(comp.lang.asm.x86)0( \(or possibly)]510 norm1
[2(alt.lang.asm)0( \226 I forget which\), which was essentially that there didn't seem to be a good )1(free)]499 norm0
[(x86-series assembler around, and that maybe someone ought to write one.)]488 norm2
[2(a86)0( is good, but not free, and in particular you don't get any 32-bit capability until you pay. It's)]471 bull1
[(DOS only, too.)]460 bull2
[2(gas)0( is free, and ports over DOS and Unix, but it's not very good, since it's designed to be a back)]443 bull1
[(end to )2(gcc)0(, which always feeds it correct code. So its error checking is minimal. Also, its syntax)]432 bull0
[(is horrible, from the point of view of anyone trying to actually )1(write)0( anything in it. Plus you can't)]421 bull0
[(write 16-bit code in it \(properly\).)]410 bull2
[2(as86)0( is Minix- and Linux-specific, and \(my version at least\) doesn't seem to have much \(or)]393 bull1
[(any\) documentation.)]382 bull2
[2(MASM)0( isn't very good, and it's \(was\) expensive, and it runs only under DOS.)]365 bull3
[2(TASM)0( is better, but still strives for MASM compatibility, which means millions of directives and)]348 bull1
[(tons of red tape. And its syntax is essentially MASM's, with the contradictions and quirks that)]337 bull0
[(entails \(although it sorts out some of those by means of Ideal mode\). It's expensive too. And it's)]326 bull0
[(DOS-only.)]315 bull2
[(So here, for your coding pleasure, is NASM. At present it's still in prototype stage \226 we don't)]298 norm1
[(promise that it can outperform any of these assemblers. But please, )1(please)0( send us bug reports,)]287 norm0
[(fixes, helpful information, and anything else you can get your hands on \(and thanks to the many)]276 norm0
[(people who've done this already! You all know who you are\), and we'll improve it out of all)]265 norm0
[(recognition. Again.)]254 norm2
[{/section-1.1.2 xa}(Licence Conditions)](1.1.2)236 subh3
[(Please see the file )2(COPYING)0(, supplied as part of any NASM distribution archive, for the )(licence)]219 norm1
[(conditions under which you may use NASM. NASM is now under the so-called GNU Lesser)]208 norm0
[(General Public License, LGPL.)]197 norm2
[{/section-1.2 xa}(Contact Information)](1.2)177 head3
[(The current version of NASM \(since about 0.98.08\) are maintained by a team of developers,)]160 norm1
[(accessible through the )2(nasm-devel)0( mailing list \(see below for the link\). If you want to report a)]149 norm0
[(bug, please read ){/section-10.2 xl}(section 10.2){el}( first.)]138 norm2
[(NASM has a )(WWW page at ){(http://nasm.sourceforge.net)wl}2(http://nasm.sourceforge.net){el}0(. If it's not there, google for us!)]121 norm3
(20)pageeven
restore showpage
%%Page: 21 21
%%BeginPageSetup
save
%%EndPageSetup
/21 pa
[(The original authors are )(e-mailable as ){(mailto:jules@dsf.org.uk)wl}2(jules@dsf.org.uk){el}0( and ){(mailto:anakin@pobox.com)wl}2(anakin@pobox.com){el}0(. The)]681 norm1
[(latter is no longer involved in the development team.)]670 norm2
[(New releases of NASM are uploaded to the official sites ){(http://nasm.sourceforge.net)wl}2(http://nasm.sourceforge.net){el}]653 norm1
[(and to ){(ftp://ftp.kernel.org/pub/software/devel/nasm/)wl}2(ftp.kernel.org){el}0( and ){(ftp://ibiblio.org/pub/Linux/devel/lang/assemblers/)wl}2(ibiblio.org){el}0(.)]642 norm2
[(Announcements are posted to ){(news:comp.lang.asm.x86)wl}2(comp.lang.asm.x86){el}0(, ){(news:alt.lang.asm)wl}2(alt.lang.asm){el}0( and)]625 norm1
[{(news:comp.os.linux.announce)wl}2(comp.os.linux.announce){el}]614 norm2
[(If you want information about NASM beta releases, and the current development status, please)]597 norm1
[(subscribe to the )2(nasm-devel)0( email list by registering at)]586 norm0
[{(http://sourceforge.net/projects/nasm)wl}2(http://sourceforge.net/projects/nasm){el}0(.)]575 norm2
[{/section-1.3 xa}(Installation)](1.3)555 head3
[{/section-1.3.1 xa}(Installing NASM under MS-)(DOS or Windows)](1.3.1)537 subh3
[(Once you've obtained the )(DOS archive for NASM, )2(nasmXXX.zip)0( \(where )2(XXX)0( denotes the)]520 norm1
[(version number of NASM contained in the archive\), unpack it into its own directory \(for example)]509 norm0
[2(c:\\nasm)0(\).)]498 norm2
[(The archive will contain four executable files: the NASM executable files )2(nasm.exe)0( and)]481 norm1
[2(nasmw.exe)0(, and the NDISASM executable files )2(ndisasm.exe)0( and )2(ndisasmw.exe)0(. In each)]470 norm0
[(case, the file whose name ends in )2(w)0( is a )2(Win32)0( executable, designed to run under )2(Windows 95)0( or)]459 norm0
[( )2(Windows NT)0( Intel, and the other one is a 16-bit )2(DOS)0( executable.)]448 norm2
[(The only file NASM needs to run is its own executable, so copy \(at least\) one of )2(nasm.exe)0( and)]431 norm1
[2(nasmw.exe)0( to a directory on your PATH, or alternatively edit )2(autoexec.bat)0( to add the )2(nasm)]420 norm0
[(directory to your )2(PATH)0(. \(If you're only installing the )2(Win32)0( version, you may wish to rename it to)]409 norm0
[2(nasm.exe)0(.\))]398 norm2
[(That's it \226 NASM is installed. You don't need the nasm directory to be present to run NASM)]381 norm1
[(\(unless you've added it to your )2(PATH)0(\), so you can delete it if you need to save space; however, you)]370 norm0
[(may want to keep the documentation or test programs.)]359 norm2
[(If you've downloaded the )(DOS source archive, )2(nasmXXXs.zip)0(, the )2(nasm)0( directory will also)]342 norm1
[(contain the full NASM )(source code, and a selection of )(Makefiles you can \(hopefully\) use to rebuild)]331 norm0
[(your copy of NASM from scratch.)]320 norm2
[(Note that the source files )2(insnsa.c)0(, )2(insnsd.c)0(, )2(insnsi.h)0( and )2(insnsn.c)0( are automatically)]303 norm1
[(generated from the master instruction table )2(insns.dat)0( by a Perl script; the file )2(macros.c)0( is)]292 norm0
[(generated from )2(standard.mac)0( by another Perl script. Although the NASM source distribution)]281 norm0
[(includes these generated files, you will need to rebuild them \(and hence, will need a Perl interpreter\))]270 norm0
[(if you change insns.dat, standard.mac or the documentation. It is possible future source distributions)]259 norm0
[(may not include these files at all. Ports of )(Perl for a variety of platforms, including DOS and)]248 norm0
[(Windows, are available from ){(http://www.cpan.org/ports/)wl}(www.cpan.org){el}(.)]237 norm2
[{/section-1.3.2 xa}(Installing NASM under )(Unix)](1.3.2)219 subh3
[(Once you've obtained the )(Unix source archive for NASM, )2(nasm-X.XX.tar.gz)0( \(where )2(X.XX)]202 norm1
[(denotes the version number of NASM contained in the archive\), unpack it into a directory such as)]191 norm0
[2(/usr/local/src)0(. The archive, when unpacked, will create its own subdirectory )2(nasm-X.XX)0(.)]180 norm2
[(NASM is an )(auto-configuring package: once you've unpacked it, )2(cd)0( to the directory it's been)]163 norm1
[(unpacked into and type )2(./configure)0(. This shell script will find the best C compiler to use for)]152 norm0
[(building NASM and set up )(Makefiles accordingly.)]141 norm2
[(Once NASM has auto-configured, you can type )2(make)0( to build the )2(nasm)0( and )2(ndisasm)0( binaries,)]124 norm1
[(and then )2(make install)0( to install them in )2(/usr/local/bin)0( and install the )(man pages)]113 norm0
[2(nasm.1)0( and )2(ndisasm.1)0( in )2(/usr/local/man/man1)0(. Alternatively, you can give options)]102 norm0
(21)pageodd
restore showpage
%%Page: 22 22
%%BeginPageSetup
save
%%EndPageSetup
/22 pa
[(such as )2(--prefix)0( to the configure script \(see the file )2(INSTALL)0( for more details\), or install the)]681 norm0
[(programs yourself.)]670 norm2
[(NASM also comes with a set of utilities for handling the )2(RDOFF)0( custom object-file format, which)]653 norm1
[(are in the )2(rdoff)0( subdirectory of the NASM archive. You can build these with )2(make rdf)0( and)]642 norm0
[(install them with )2(make rdf_install)0(, if you want them.)]631 norm2
[(If NASM fails to auto-configure, you may still be able to make it compile by using the fall-back)]614 norm1
[(Unix makefile )2(Makefile.unx)0(. Copy or rename that file to )2(Makefile)0( and try typing )2(make)0(.)]603 norm0
[(There is also a Makefile.unx file in the )2(rdoff)0( subdirectory.)]592 norm2
(22)pageeven
restore showpage
%%Page: 23 23
%%BeginPageSetup
save
%%EndPageSetup
/23 pa
[{/chapter-2 xa}(Chapter 2: Running NASM)]644 chap3
[{/section-2.1 xa}(NASM )(Command-Line Syntax)](2.1)606 head3
[(To assemble a file, you issue a command of the form)]589 norm3
[2(nasm -f <format> <filename> [-o <output>])]572 code3
[(For example,)]555 norm3
[2(nasm -f elf myfile.asm)]538 code3
[(will assemble )2(myfile.asm)0( into an )2(ELF)0( object file )2(myfile.o)0(. And)]521 norm3
[2(nasm -f bin myfile.asm -o myfile.com)]504 code3
[(will assemble )2(myfile.asm)0( into a raw binary file )2(myfile.com)0(.)]487 norm3
[(To produce a listing file, with the hex codes output from NASM displayed on the left of the original)]470 norm1
[(sources, use the )2(-l)0( option to give a listing file name, for example:)]459 norm2
[2(nasm -f coff myfile.asm -l myfile.lst)]442 code3
[(To get further usage instructions from NASM, try typing)]425 norm3
[2(nasm -h)]408 code3
[(As )2(-hf)0(, this will also list the available output file formats, and what they are.)]391 norm3
[(If you use Linux but aren't sure whether your system is )2(a.out)0( or )2(ELF)0(, type)]374 norm3
[2(file nasm)]357 code3
[(\(in the directory in which you put the NASM binary when you installed it\). If it says something like)]340 norm3
[2(nasm: ELF 32-bit LSB executable i386 \(386 and up\) Version 1)]323 code3
[(then your system is )2(ELF)0(, and you should use the option )2(-f elf)0( when you want NASM to produce)]306 norm1
[(Linux object files. If it says)]295 norm2
[2(nasm: Linux/i386 demand-paged executable \(QMAGIC\))]278 code3
[(or something similar, your system is )2(a.out)0(, and you should use )2(-f aout)0( instead \(Linux )2(a.out)]261 norm1
[(systems have long been obsolete, and are rare these days.\))]250 norm2
[(Like Unix compilers and assemblers, NASM is silent unless it goes wrong: you won't see any)]233 norm1
[(output at all, unless it gives error messages.)]222 norm2
[{/section-2.1.1 xa}(The )2(-o)0( Option: Specifying the Output File Name)](2.1.1)204 subh3
[(NASM will normally choose the name of your output file for you; precisely how it does this is)]187 norm1
[(dependent on the object file format. For Microsoft object file formats \()2(obj)0( and )2(win32)0(\), it will)]176 norm0
[(remove the )2(.asm)0( )(extension \(or whatever extension you like to use \226 NASM doesn't care\) from)]165 norm0
[(your source file name and substitute )2(.obj)0(. For Unix object file formats \()2(aout)0(, )2(coff)0(, )2(elf)0( and)]154 norm0
[2(as86)0(\) it will substitute )2(.o)0(. For )2(rdf)0(, it will use )2(.rdf)0(, and for the )2(bin)0( format it will simply)]143 norm0
[(remove the extension, so that )2(myfile.asm)0( produces the output file )2(myfile)0(.)]132 norm2
[(If the output file already exists, NASM will overwrite it, unless it has the same name as the input)]115 norm1
[(file, in which case it will give a warning and use )2(nasm.out)0( as the output file name instead.)]104 norm2
(23)pageodd
restore showpage
%%Page: 24 24
%%BeginPageSetup
save
%%EndPageSetup
/24 pa
[(For situations in which this behaviour is unacceptable, NASM provides the )2(-o)0( command-line)]681 norm1
[(option, which allows you to specify your desired output file name. You invoke )2(-o)0( by following it)]670 norm0
[(with the name you wish for the output file, either with or without an intervening space. For example:)]659 norm2
[2(nasm -f bin program.asm -o program.com )]642 code1
[2(nasm -f bin driver.asm -odriver.sys)]631 code2
[(Note that this is a small o, and is different from a capital O , which is used to specify the number of)]614 norm1
[(optimisation passes required. See ){/section-2.1.16 xl}(section 2.1.16){el}(.)]603 norm2
[{/section-2.1.2 xa}(The )2(-f)0( Option: Specifying the )(Output File Format)](2.1.2)585 subh3
[(If you do not supply the )2(-f)0( option to NASM, it will choose an output file format for you itself. In)]568 norm1
[(the distribution versions of NASM, the default is always )2(bin)0(; if you've compiled your own copy of)]557 norm0
[(NASM, you can redefine )2(OF_DEFAULT)0( at compile time and choose what you want the default to)]546 norm0
[(be.)]535 norm2
[(Like )2(-o)0(, the intervening space between )2(-f)0( and the output file format is optional; so )2(-f elf)0( and)]518 norm1
[2(-felf)0( are both valid.)]507 norm2
[(A complete list of the available output file formats can be given by issuing the command)]490 norm1
[2(nasm -hf)0(.)]479 norm2
[{/section-2.1.3 xa}(The )2(-l)0( Option: Generating a )(Listing File)](2.1.3)461 subh3
[(If you supply the )2(-l)0( option to NASM, followed \(with the usual optional space\) by a file name,)]444 norm1
[(NASM will generate a )(source-listing file for you, in which addresses and generated code are listed)]433 norm0
[(on the left, and the actual source code, with expansions of multi-line macros \(except those which)]422 norm0
[(specifically request no expansion in source listings: see ){/section-4.3.9 xl}(section 4.3.9){el}(\) on the right. For example:)]411 norm2
[2(nasm -f elf myfile.asm -l myfile.lst)]394 code3
[(If a list file is selected, you may turn off listing for a section of your source with )2([list -])0(, and)]377 norm1
[(turn it back on with )2([list +])0(, \(the default, obviously\). There is no "user form" \(without the)]366 norm0
[(brackets\). This can be used to list only sections of interest, avoiding excessively long listings.)]355 norm2
[{/section-2.1.4 xa}(The )2(-M)0( Option: Generate )(Makefile Dependencies.)](2.1.4)337 subh3
[(This option can be used to generate makefile dependencies on stdout. This can be redirected to a file)]320 norm1
[(for further processing. For example:)]309 norm2
[2(NASM -M myfile.asm > myfile.dep)]292 code3
[{/section-2.1.5 xa}(The )2(-F)0( Option: Selecting a )(Debug Information Format)](2.1.5)274 subh3
[(This option is used to select the format of the debug information emitted into the output file, to be)]257 norm1
[(used by a debugger \(or )1(will)0( be\). Use of this switch does )1(not)0( enable output of the selected debug info)]246 norm0
[(format. Use )2(-g)0(, see ){/section-2.1.6 xl}(section 2.1.6){el}(, to enable output.)]235 norm2
[(A complete list of the available debug file formats for an output format can be seen by issuing the)]218 norm1
[(command )2(nasm -f <format> -y)0(. \(only "borland" in "-f obj", as of 0.98.35, but "watch this)]207 norm0
[(space"\) See: ){/section-2.1.20 xl}(section 2.1.20){el}(.)]196 norm2
[(This should not be confused with the "-f dbg" output format option which is not built into NASM)]179 norm1
[(by default. For information on how to enable it when building from the sources, see ){/section-6.10 xl}(section 6.10){el}]168 norm2
[{/section-2.1.6 xa}(The )2(-g)0( Option: Enabling )(Debug Information.)](2.1.6)150 subh3
[(This option can be used to generate debugging information in the specified format. See: ){/section-2.1.5 xl}(section){el}]133 norm1
[{/section-2.1.5 xl}(2.1.5){el}(. Using )2(-g)0( without )2(-F)0( results in emitting debug info in the default format, if any, for the)]122 norm0
[(selected output format. If no debug information is currently implemented in the selected output)]111 norm0
[(format, )2(-g)0( is )1(silently ignored)0(.)]100 norm2
(24)pageeven
restore showpage
%%Page: 25 25
%%BeginPageSetup
save
%%EndPageSetup
/25 pa
[{/section-2.1.7 xa}(The )2(-X)0( Option: Selecting an )(Error Reporting Format)](2.1.7)680 subh3
[(This option can be used to select an error reporting format for any error messages that might be)]663 norm1
[(produced by NASM.)]652 norm2
[(Currently, two error reporting formats may be selected. They are the )2(-Xvc)0( option and the )2(-Xgnu)]635 norm1
[(option. The GNU format is the default and looks like this:)]624 norm2
[2(filename.asm:65: error: specific error message )]607 code3
[(where )2(filename.asm)0( is the name of the source file in which the error was detected, )2(65)0( is the)]590 norm1
[(source file line number on which the error was detected, )2(error)0( is the severity of the error \(this)]579 norm0
[(could be )2(warning)0(\), and )2(specific error message)0( is a more detailed text message which)]568 norm0
[(should help pinpoint the exact problem.)]557 norm2
[(The other format, specified by )2(-Xvc)0( is the style used by Microsoft Visual C++ and some other)]540 norm1
[(programs. It looks like this:)]529 norm2
[2(filename.asm\(65\) : error: specific error message)]512 code3
[(where the only difference is that the line number is in parentheses instead of being delimited by)]495 norm1
[(colons.)]484 norm2
[(See also the )2(Visual C++)0( output format, ){/section-6.3 xl}(section 6.3){el}(.)]467 norm3
[{/section-2.1.8 xa}(The )2(-E)0( Option: Send Errors to a File)](2.1.8)449 subh3
[(Under )2(MS-DOS)0( it can be difficult \(though there are ways\) to redirect the standard-error output of a)]432 norm1
[(program to a file. Since NASM usually produces its warning and )(error messages on )2(stderr)0(, this)]421 norm0
[(can make it hard to capture the errors if \(for example\) you want to load them into an editor.)]410 norm2
[(NASM therefore provides the )2(-E)0( option, taking a filename argument which causes errors to be sent)]393 norm1
[(to the specified files rather than standard error. Therefore you can )(redirect the errors into a file by)]382 norm0
[(typing)]371 norm2
[2(nasm -E myfile.err -f obj myfile.asm)]354 code3
[{/section-2.1.9 xa}(The )2(-s)0( Option: Send Errors to )2(stdout)](2.1.9)336 subh3
[(The )2(-s)0( option redirects )(error messages to )2(stdout)0( rather than )2(stderr)0(, so it can be redirected)]319 norm1
[(under )2(MS-DOS)0(. To assemble the file )2(myfile.asm)0( and pipe its output to the )2(more)0( program, you)]308 norm0
[(can type:)]297 norm2
[2(nasm -s -f obj myfile.asm | more)]280 code3
[(See also the )2(-E)0( option, ){/section-2.1.8 xl}(section 2.1.8){el}(.)]263 norm3
[{/section-2.1.10 xa}(The )2(-i)0( Option: Include File Search Directories)](2.1.10)245 subh3
[(When NASM sees the )2(%include)0( or )2(incbin)0( directive in a source file \(see ){/section-4.6 xl}(section 4.6){el}( or ){/section-3.2.3 xl}(section){el}]228 norm1
[{/section-3.2.3 xl}(3.2.3){el}(\), it will search for the given file not only in the current directory, but also in any directories)]217 norm0
[(specified on the command line by the use of the )2(-i)0( option. Therefore you can include files from a)]206 norm0
[(macro library, for example, by typing)]195 norm2
[2(nasm -ic:\\\\macrolib\\\\ -f obj myfile.asm)]178 code3
[(\(As usual, a space between )2(-i)0( and the path name is allowed, and optional\).)]161 norm3
[(NASM, in the interests of complete source-code portability, does not understand the file naming)]144 norm1
[(conventions of the OS it is running on; the string you provide as an argument to the )2(-i)0( option will)]133 norm0
[(be prepended exactly as written to the name of the include file. Therefore the trailing backslash in)]122 norm0
[(the above example is necessary. Under Unix, a trailing forward slash is similarly necessary.)]111 norm2
(25)pageodd
restore showpage
%%Page: 26 26
%%BeginPageSetup
save
%%EndPageSetup
/26 pa
[(\(You can use this to your advantage, if you're really )(perverse, by noting that the option )2(-ifoo)0( will)]681 norm1
[(cause )2(%include "bar.i")0( to search for the file )2(foobar.i)0(...\))]670 norm2
[(If you want to define a )1(standard)0( )(include search path, similar to )2(/usr/include)0( on Unix systems,)]653 norm1
[(you should place one or more )2(-i)0( directives in the )2(NASMENV)0( environment variable \(see ){/section-2.1.22 xl}(section){el}]642 norm0
[{/section-2.1.22 xl}(2.1.22){el}(\).)]631 norm2
[(For Makefile compatibility with many C compilers, this option can also be specified as )2(-I)0(.)]614 norm3
[{/section-2.1.11 xa}(The )2(-p)0( Option: )(Pre-Include a File)](2.1.11)596 subh3
[(NASM allows you to specify files to be )1(pre-included)0( into your source file, by the use of the )2(-p)]579 norm1
[(option. So running)]568 norm2
[2(nasm myfile.asm -p myinc.inc)]551 code3
[(is equivalent to running )2(nasm myfile.asm)0( and placing the directive)]534 norm1
[2(%include "myinc.inc")0( at the start of the file.)]523 norm2
[(For consistency with the )2(-I)0(, )2(-D)0( and )2(-U)0( options, this option can also be specified as )2(-P)0(.)]506 norm3
[{/section-2.1.12 xa}(The )2(-d)0( Option: )(Pre-Define a Macro)](2.1.12)488 subh3
[(Just as the )2(-p)0( option gives an alternative to placing )2(%include)0( directives at the start of a source)]471 norm1
[(file, the )2(-d)0( option gives an alternative to placing a )2(%define)0( directive. You could code)]460 norm2
[2(nasm myfile.asm -dFOO=100)]443 code3
[(as an alternative to placing the directive)]426 norm3
[2(%define FOO 100)]409 code3
[(at the start of the file. You can miss off the macro value, as well: the option )2(-dFOO)0( is equivalent to)]392 norm1
[(coding )2(%define FOO)0(. This form of the directive may be useful for selecting )(assembly-time)]381 norm0
[(options which are then tested using )2(%ifdef)0(, for example )2(-dDEBUG)0(.)]370 norm2
[(For Makefile compatibility with many C compilers, this option can also be specified as )2(-D)0(.)]353 norm3
[{/section-2.1.13 xa}(The )2(-u)0( Option: )(Undefine a Macro)](2.1.13)335 subh3
[(The )2(-u)0( option undefines a macro that would otherwise have been pre-defined, either automatically)]318 norm1
[(or by a )2(-p)0( or )2(-d)0( option specified earlier on the command lines.)]307 norm2
[(For example, the following command line:)]290 norm3
[2(nasm myfile.asm -dFOO=100 -uFOO)]273 code3
[(would result in )2(FOO)0( )1(not)0( being a predefined macro in the program. This is useful to override options)]256 norm1
[(specified at a different point in a Makefile.)]245 norm2
[(For Makefile compatibility with many C compilers, this option can also be specified as )2(-U)0(.)]228 norm3
[{/section-2.1.14 xa}(The )2(-e)0( Option: Preprocess Only)](2.1.14)210 subh3
[(NASM allows the )(preprocessor to be run on its own, up to a point. Using the )2(-e)0( option \(which)]193 norm1
[(requires no arguments\) will cause NASM to preprocess its input file, expand all the macro)]182 norm0
[(references, remove all the comments and preprocessor directives, and print the resulting file on)]171 norm0
[(standard output \(or save it to a file, if the )2(-o)0( option is also used\).)]160 norm2
[(This option cannot be applied to programs which require the preprocessor to evaluate )(expressions)]143 norm1
[(which depend on the values of symbols: so code such as)]132 norm2
[2(%assign tablesize \($-tablestart\))]115 code3
(26)pageeven
restore showpage
%%Page: 27 27
%%BeginPageSetup
save
%%EndPageSetup
/27 pa
[(will cause an error in )(preprocess-only mode.)]681 norm3
[{/section-2.1.15 xa}(The )2(-a)0( Option: Don't Preprocess At All)](2.1.15)663 subh3
[(If NASM is being used as the back end to a compiler, it might be desirable to )(suppress)]646 norm1
[(preprocessing completely and assume the compiler has already done it, to save time and increase)]635 norm0
[(compilation speeds. The )2(-a)0( option, requiring no argument, instructs NASM to replace its powerful)]624 norm0
[(preprocessor with a )(stub preprocessor which does nothing.)]613 norm2
[{/section-2.1.16 xa}(The )2(-On)0( Option: Specifying )(Multipass Optimization.)](2.1.16)595 subh3
[(NASM defaults to being a two pass assembler. This means that if you have a complex source file)]578 norm1
[(which needs more than 2 passes to assemble optimally, you have to enable extra passes.)]567 norm2
[(Using the )2(-O)0( option, you can tell NASM to carry out multiple passes. The syntax is:)]550 norm3
[2(-O0)0( strict two-pass assembly, JMP and Jcc are handled more like v0.98, except that backward)]533 bull1
[(JMPs are short, if possible. Immediate operands take their long forms if a short form is not)]522 bull0
[(specified.)]511 bull2
[2(-O1)0( strict two-pass assembly, but forward branches are assembled with code guaranteed to)]494 bull1
[(reach; may produce larger code than \226O0, but will produce successful assembly more often if)]483 bull0
[(branch offset sizes are not specified. Additionally, immediate operands which will fit in a signed)]472 bull0
[(byte are optimised, unless the long form is specified.)]461 bull2
[2(-On)0( multi-pass optimization, minimize branch offsets; also will minimize signed immediate)]444 bull1
[(bytes, overriding size specification unless the )2(strict)0( keyword has been used \(see ){/section-3.7 xl}(section 3.7){el}(\).)]433 bull0
[(The number specifies the maximum number of passes. The more passes, the better the code, but)]422 bull0
[(the slower is the assembly.)]411 bull2
[(Note that this is a capital O, and is different from a small o, which is used to specify the output)]394 norm1
[(format. See ){/section-2.1.1 xl}(section 2.1.1){el}(.)]383 norm2
[{/section-2.1.17 xa}(The )2(-t)0( option: Enable TASM Compatibility Mode)](2.1.17)365 subh3
[(NASM includes a limited form of compatibility with Borland's )2(TASM)0(. When NASM's )2(-t)0( option is)]348 norm1
[(used, the following changes are made:)]337 norm2
[(local labels may be prefixed with )2(@@)0( instead of )2(.)]320 bull3
[(TASM-style response files beginning with )2(@)0( may be specified on the command line. This is)]303 bull1
[(different from the )2(-@resp)0( style that NASM natively supports.)]292 bull2
[(size override is supported within brackets. In TASM compatible mode, a size override inside)]275 bull1
[(square brackets changes the size of the operand, and not the address type of the operand as it)]264 bull0
[(does in NASM syntax. E.g. )2(mov eax,[DWORD val])0( is valid syntax in TASM compatibility)]253 bull0
[(mode. Note that you lose the ability to override the default address type for the instruction.)]242 bull2
[2(%arg)0( preprocessor directive is supported which is similar to TASM's )2(ARG)0( directive.)]225 bull3
[2(%local)0( preprocessor directive)]208 bull3
[2(%stacksize)0( preprocessor directive)]191 bull3
[(unprefixed forms of some directives supported \()2(arg)0(, )2(elif)0(, )2(else)0(, )2(endif)0(, )2(if)0(, )2(ifdef)0(,)]174 bull1
[2(ifdifi)0(, )2(ifndef)0(, )2(include)0(, )2(local)0(\))]163 bull2
[(more...)]146 bull3
[(For more information on the directives, see the section on TASM Compatiblity preprocessor)]129 norm1
[(directives in ){/section-4.9 xl}(section 4.9){el}(.)]118 norm2
(27)pageodd
restore showpage
%%Page: 28 28
%%BeginPageSetup
save
%%EndPageSetup
/28 pa
[{/section-2.1.18 xa}(The )2(-w)0( Option: Enable or Disable Assembly )(Warnings)](2.1.18)680 subh3
[(NASM can observe many conditions during the course of assembly which are worth mentioning to)]663 norm1
[(the user, but not a sufficiently severe error to justify NASM refusing to generate an output file.)]652 norm0
[(These conditions are reported like errors, but come up with the word `warning' before the message.)]641 norm0
[(Warnings do not prevent NASM from generating an output file and returning a success status to the)]630 norm0
[(operating system.)]619 norm2
[(Some conditions are even less severe than that: they are only sometimes worth mentioning to the)]602 norm1
[(user. Therefore NASM supports the )2(-w)0( command-line option, which enables or disables certain)]591 norm0
[(classes of assembly warning. Such warning classes are described by a name, for example)]580 norm0
[2(orphan-labels)0(; you can enable warnings of this class by the command-line option)]569 norm0
[2(-w+orphan-labels)0( and disable it by )2(-w-orphan-labels)0(.)]558 norm2
[(The )(suppressible warning classes are:)]541 norm3
[2(macro-params)0( covers warnings about )(multi-line macros being invoked with the wrong)]524 bull1
[(number of parameters. This warning class is enabled by default; see ){/section-4.3.1 xl}(section 4.3.1){el}( for an example)]513 bull0
[(of why you might want to disable it.)]502 bull2
[2(macro-selfref)0( warns if a macro references itself. This warning class is enabled by default.)]485 bull3
[2(orphan-labels)0( covers warnings about source lines which contain no instruction but define a)]468 bull1
[(label without a trailing colon. NASM does not warn about this somewhat obscure condition by)]457 bull0
[(default; see ){/section-3.1 xl}(section 3.1){el}( for an example of why you might want it to.)]446 bull2
[2(number-overflow)0( covers warnings about numeric constants which don't fit in 32 bits \(for)]429 bull1
[(example, it's easy to type one too many Fs and produce )2(0x7ffffffff)0( by mistake\). This)]418 bull0
[(warning class is enabled by default.)]407 bull2
[2(gnu-elf-extensions)0( warns if 8-bit or 16-bit relocations are used in )2(-f elf)0( format. The)]390 bull1
[(GNU extensions allow this. This warning class is enabled by default.)]379 bull2
[(In addition, warning classes may be enabled or disabled across sections of source code with)]362 bull1
[2([warning +warning-name])0( or )2([warning -warning-name])0(. No "user form")]351 bull0
[(\(without the brackets\) exists.)]340 bull2
[{/section-2.1.19 xa}(The )2(-v)0( Option: Display )(Version Info)](2.1.19)322 subh3
[(Typing )2(NASM -v)0( will display the version of NASM which you are using, and the date on which it)]305 norm1
[(was compiled. This replaces the deprecated )2(-r)0(.)]294 norm2
[(You will need the version number if you report a bug.)]277 norm3
[{/section-2.1.20 xa}(The )2(-y)0( Option: Display Available Debug Info Formats)](2.1.20)259 subh3
[(Typing )2(nasm -f <option> -y)0( will display a list of the available debug info formats for the)]242 norm1
[(given output format. The default format is indicated by an asterisk. E.g. )2(nasm -f obj -y)0( yields)]231 norm0
[2(* borland)0(. \(as of 0.98.35, the )1(only)0( debug info format implemented\).)]220 norm2
[{/section-2.1.21 xa}(The )2(--prefix)0( and )2(--postfix)0( Options.)](2.1.21)202 subh3
[(The )2(--prefix)0( and )2(--postfix)0( options prepend or append \(respectively\) the given argument to)]185 norm1
[(all )2(global)0( or )2(extern)0( variables. E.g. )2(--prefix_)0( will prepend the underscore to all global and)]174 norm0
[(external variables, as C sometimes \(but not always\) likes it.)]163 norm2
[{/section-2.1.22 xa}(The )2(NASMENV)0( )(Environment Variable)](2.1.22)145 subh3
[(If you define an environment variable called )2(NASMENV)0(, the program will interpret it as a list of)]128 norm1
[(extra command-line options, which are processed before the real command line. You can use this to)]117 norm0
[(define standard search directories for include files, by putting )2(-i)0( options in the )2(NASMENV)0( variable.)]106 norm2
(28)pageeven
restore showpage
%%Page: 29 29
%%BeginPageSetup
save
%%EndPageSetup
/29 pa
[(The value of the variable is split up at white space, so that the value )2(-s -ic:\\nasmlib)0( will be)]681 norm1
[(treated as two separate options. However, that means that the value )2(-dNAME="my name")0( won't)]670 norm0
[(do what you might want, because it will be split at the space and the NASM command-line)]659 norm0
[(processing will get confused by the two nonsensical words )2(-dNAME="my)0( and )2(name")0(.)]648 norm2
[(To get round this, NASM provides a feature whereby, if you begin the )2(NASMENV)0( environment)]631 norm1
[(variable with some character that isn't a minus sign, then NASM will treat this character as the)]620 norm0
[(separator character for options. So setting the )2(NASMENV)0( variable to the value)]609 norm0
[2(!-s!-ic:\\nasmlib)0( is equivalent to setting it to )2(-s -ic:\\nasmlib)0(, but)]598 norm0
[2(!-dNAME="my name")0( will work.)]587 norm2
[(This environment variable was previously called )2(NASM)0(. This was changed with version 0.98.31.)]570 norm3
[{/section-2.2 xa}(Quick Start for )(MASM Users)](2.2)550 head3
[(If you're used to writing programs with MASM, or with )(TASM in MASM-compatible \(non-Ideal\))]533 norm1
[(mode, or with )2(a86)0(, this section attempts to outline the major differences between MASM's syntax)]522 norm0
[(and NASM's. If you're not already used to MASM, it's probably worth skipping this section.)]511 norm2
[{/section-2.2.1 xa}(NASM Is )(Case-Sensitive)](2.2.1)493 subh3
[(One simple difference is that NASM is case-sensitive. It makes a difference whether you call your)]476 norm1
[(label )2(foo)0(, )2(Foo)0( or )2(FOO)0(. If you're assembling to )2(DOS)0( or )2(OS/2)0( )2(.OBJ)0( files, you can invoke the)]465 norm0
[2(UPPERCASE)0( directive \(documented in ){/section-6.2 xl}(section 6.2){el}(\) to ensure that all symbols exported to other)]454 norm0
[(code modules are forced to be upper case; but even then, )1(within)0( a single module, NASM will)]443 norm0
[(distinguish between labels differing only in case.)]432 norm2
[{/section-2.2.2 xa}(NASM Requires )(Square Brackets For )(Memory References)](2.2.2)414 subh3
[(NASM was designed with simplicity of syntax in mind. One of the )(design goals of NASM is that it)]397 norm1
[(should be possible, as far as is practical, for the user to look at a single line of NASM code and tell)]386 norm0
[(what opcode is generated by it. You can't do this in MASM: if you declare, for example,)]375 norm2
[2(foo     equ     1 )]358 code1
[2(bar     dw      2)]347 code2
[(then the two lines of code)]330 norm3
[2(        mov     ax,foo )]313 code1
[2(        mov     ax,bar)]302 code2
[(generate completely different opcodes, despite having identical-looking syntaxes.)]285 norm3
[(NASM avoids this undesirable situation by having a much simpler syntax for memory references.)]268 norm1
[(The rule is simply that any access to the )1(contents)0( of a memory location requires square brackets)]257 norm0
[(around the address, and any access to the )1(address)0( of a variable doesn't. So an instruction of the)]246 norm0
[(form )2(mov ax,foo)0( will )1(always)0( refer to a compile-time constant, whether it's an )2(EQU)0( or the)]235 norm0
[(address of a variable; and to access the )1(contents)0( of the variable )2(bar)0(, you must code)]224 norm0
[2(mov ax,[bar])0(.)]213 norm2
[(This also means that NASM has no need for MASM's )2(OFFSET)0( keyword, since the MASM code)]196 norm1
[2(mov ax,offset bar)0( means exactly the same thing as NASM's )2(mov ax,bar)0(. If you're trying)]185 norm0
[(to get large amounts of MASM code to assemble sensibly under NASM, you can always code)]174 norm0
[2(%idefine offset)0( to make the preprocessor treat the )2(OFFSET)0( keyword as a no-op.)]163 norm2
[(This issue is even more confusing in )2(a86)0(, where declaring a label with a trailing colon defines it to)]146 norm1
[(be a `label' as opposed to a `variable' and causes )2(a86)0( to adopt NASM-style semantics; so in )2(a86)0(,)]135 norm0
[2(mov ax,var)0( has different behaviour depending on whether )2(var)0( was declared as )2(var: dw 0)0( \(a)]124 norm0
[(label\) or )2(var dw 0)0( \(a word-size variable\). NASM is very simple by comparison: )1(everything)0( is a)]113 norm0
[(label.)]102 norm2
(29)pageodd
restore showpage
%%Page: 30 30
%%BeginPageSetup
save
%%EndPageSetup
/30 pa
[(NASM, in the interests of simplicity, also does not support the )(hybrid syntaxes supported by)]681 norm1
[(MASM and its clones, such as )2(mov ax,table[bx])0(, where a memory reference is denoted by)]670 norm0
[(one portion outside square brackets and another portion inside. The correct syntax for the above is)]659 norm0
[2(mov ax,[table+bx])0(. Likewise, )2(mov ax,es:[di])0( is wrong and )2(mov ax,[es:di])0( is)]648 norm0
[(right.)]637 norm2
[{/section-2.2.3 xa}(NASM Doesn't Store )(Variable Types)](2.2.3)619 subh3
[(NASM, by design, chooses not to remember the types of variables you declare. Whereas MASM)]602 norm1
[(will remember, on seeing )2(var dw 0)0(, that you declared )2(var)0( as a word-size variable, and will then)]591 norm0
[(be able to fill in the )(ambiguity in the size of the instruction )2(mov var,2)0(, NASM will deliberately)]580 norm0
[(remember nothing about the symbol )2(var)0( except where it begins, and so you must explicitly code)]569 norm0
[2(mov word [var],2)0(.)]558 norm2
[(For this reason, NASM doesn't support the )2(LODS)0(, )2(MOVS)0(, )2(STOS)0(, )2(SCAS)0(, )2(CMPS)0(, )2(INS)0(, or )2(OUTS)]541 norm1
[(instructions, but only supports the forms such as )2(LODSB)0(, )2(MOVSW)0(, and )2(SCASD)0(, which explicitly)]530 norm0
[(specify the size of the components of the strings being manipulated.)]519 norm2
[{/section-2.2.4 xa}(NASM Doesn't )2(ASSUME)](2.2.4)501 subh3
[(As part of NASM's drive for simplicity, it also does not support the )2(ASSUME)0( directive. NASM will)]484 norm1
[(not keep track of what values you choose to put in your segment registers, and will never)]473 norm0
[1(automatically)0( generate a )(segment override prefix.)]462 norm2
[{/section-2.2.5 xa}(NASM Doesn't Support )(Memory Models)](2.2.5)444 subh3
[(NASM also does not have any directives to support different 16-bit memory models. The)]427 norm1
[(programmer has to keep track of which functions are supposed to be called with a )(far call and which)]416 norm0
[(with a )(near call, and is responsible for putting the correct form of )2(RET)0( instruction \()2(RETN)0( or )2(RETF)0(;)]405 norm0
[(NASM accepts )2(RET)0( itself as an alternate form for )2(RETN)0(\); in addition, the programmer is)]394 norm0
[(responsible for coding CALL FAR instructions where necessary when calling )1(external)0( functions,)]383 norm0
[(and must also keep track of which external variable definitions are far and which are near.)]372 norm2
[{/section-2.2.6 xa}(Floating-Point Differences)](2.2.6)354 subh3
[(NASM uses different names to refer to floating-point registers from MASM: where MASM would)]337 norm1
[(call them )2(ST\(0\))0(, )2(ST\(1\))0( and so on, and )2(a86)0( would call them simply )2(0)0(, )2(1)0( and so on, NASM)]326 norm0
[(chooses to call them )2(st0)0(, )2(st1)0( etc.)]315 norm2
[(As of version 0.96, NASM now treats the instructions with )(`nowait' forms in the same way as)]298 norm1
[(MASM-compatible assemblers. The idiosyncratic treatment employed by 0.95 and earlier was)]287 norm0
[(based on a misunderstanding by the authors.)]276 norm2
[{/section-2.2.7 xa}(Other Differences)](2.2.7)258 subh3
[(For historical reasons, NASM uses the keyword )2(TWORD)0( where MASM and compatible assemblers)]241 norm1
[(use )2(TBYTE)0(.)]230 norm2
[(NASM does not declare )(uninitialised storage in the same way as MASM: where a MASM)]213 norm1
[(programmer might use )2(stack db 64 dup \(?\))0(, NASM requires )2(stack resb 64)0(, intended)]202 norm0
[(to be read as `reserve 64 bytes'. For a limited amount of compatibility, since NASM treats )2(?)0( as a)]191 norm0
[(valid character in symbol names, you can code )2(? equ 0)0( and then writing )2(dw ?)0( will at least do)]180 norm0
[(something vaguely useful. )2(DUP)0( is still not a supported syntax, however.)]169 norm2
[(In addition to all of this, macros and directives work completely differently to MASM. See ){/chapter-4 xl}(chapter){el}]152 norm1
[{/chapter-4 xl}(4){el}( and ){/chapter-5 xl}(chapter 5){el}( for further details.)]141 norm2
(30)pageeven
restore showpage
%%Page: 31 31
%%BeginPageSetup
save
%%EndPageSetup
/31 pa
[{/chapter-3 xa}(Chapter 3: The NASM Language)]644 chap3
[{/section-3.1 xa}(Layout of a NASM Source Line)](3.1)606 head3
[(Like most assemblers, each NASM source line contains \(unless it is a macro, a preprocessor)]589 norm1
[(directive or an assembler directive: see ){/chapter-4 xl}(chapter 4){el}( and ){/chapter-5 xl}(chapter 5){el}(\) some combination of the four fields)]578 norm2
[2(label:    instruction operands        ; comment)]561 code3
[(As usual, most of these fields are optional; the presence or absence of any combination of a label,)]544 norm1
[(an instruction and a comment is allowed. Of course, the operand field is either required or forbidden)]533 norm0
[(by the presence and nature of the instruction field.)]522 norm2
[(NASM uses backslash \(\\\) as the line continuation character; if a line ends with backslash, the next)]505 norm1
[(line is considered to be a part of the backslash-ended line.)]494 norm2
[(NASM places no restrictions on white space within a line: labels may have white space before)]477 norm1
[(them, or instructions may have no space before them, or anything. The )(colon after a label is also)]466 norm0
[(optional. \(Note that this means that if you intend to code )2(lodsb)0( alone on a line, and type )2(lodab)]455 norm0
[(by accident, then that's still a valid source line which does nothing but define a label. Running)]444 norm0
[(NASM with the command-line option )2(-w+orphan-labels)0( will cause it to warn you if you)]433 norm0
[(define a label alone on a line without a )(trailing colon.\))]422 norm2
[(Valid characters in labels are letters, numbers, )2(_)0(, )2($)0(, )2(#)0(, )2(@)0(, )2(~)0(, )2(.)0(, and )2(?)0(. The only characters which)]405 norm1
[(may be used as the )1(first)0( character of an identifier are letters, )2(.)0( \(with special meaning: see ){/section-3.9 xl}(section){el}]394 norm0
[{/section-3.9 xl}(3.9){el}(\), )2(_)0( and )2(?)0(. An identifier may also be prefixed with a )2($)0( to indicate that it is intended to be read as)]383 norm0
[(an identifier and not a reserved word; thus, if some other module you are linking with defines a)]372 norm0
[(symbol called )2(eax)0(, you can refer to )2($eax)0( in NASM code to distinguish the symbol from the)]361 norm0
[(register. Maximum length of an identifier is 4095 characters.)]350 norm2
[(The instruction field may contain any machine instruction: Pentium and P6 instructions, FPU)]333 norm1
[(instructions, MMX instructions and even undocumented instructions are all supported. The)]322 norm0
[(instruction may be prefixed by )2(LOCK)0(, )2(REP)0(, )2(REPE)0(/)2(REPZ)0( or )2(REPNE)0(/)2(REPNZ)0(, in the usual way.)]311 norm0
[(Explicit )(address-size and )(operand-size prefixes )2(A16)0(, )2(A32)0(, )2(O16)0( and )2(O32)0( are provided \226 one)]300 norm0
[(example of their use is given in ){/chapter-9 xl}(chapter 9){el}(. You can also use the name of a )(segment register as an)]289 norm0
[(instruction prefix: coding )2(es mov [bx],ax)0( is equivalent to coding )2(mov [es:bx],ax)0(. We)]278 norm0
[(recommend the latter syntax, since it is consistent with other syntactic features of the language, but)]267 norm0
[(for instructions such as )2(LODSB)0(, which has no operands and yet can require a segment override,)]256 norm0
[(there is no clean syntactic way to proceed apart from )2(es lodsb)0(.)]245 norm2
[(An instruction is not required to use a prefix: prefixes such as )2(CS)0(, )2(A32)0(, )2(LOCK)0( or )2(REPE)0( can appear)]228 norm1
[(on a line by themselves, and NASM will just generate the prefix bytes.)]217 norm2
[(In addition to actual machine instructions, NASM also supports a number of pseudo-instructions,)]200 norm1
[(described in ){/section-3.2 xl}(section 3.2){el}(.)]189 norm2
[(Instruction )(operands may take a number of forms: they can be registers, described simply by the)]172 norm1
[(register name \(e.g. )2(ax)0(, )2(bp)0(, )2(ebx)0(, )2(cr0)0(: NASM does not use the )2(gas)0(\226style syntax in which register)]161 norm0
[(names must be prefixed by a )2(%)0( sign\), or they can be )(effective addresses \(see ){/section-3.3 xl}(section 3.3){el}(\), constants)]150 norm0
[(\(){/section-3.4 xl}(section 3.4){el}(\) or expressions \(){/section-3.5 xl}(section 3.5){el}(\).)]139 norm2
[(For )(floating-point instructions, NASM accepts a wide range of syntaxes: you can use two-operand)]122 norm1
[(forms like MASM supports, or you can use NASM's native single-operand forms in most cases.)]111 norm0
(31)pageodd
restore showpage
%%Page: 32 32
%%BeginPageSetup
save
%%EndPageSetup
/32 pa
[(Details of all forms of each supported instruction are given in ){/appendix-B xl}(appendix B){el}(. For example, you can)]681 norm0
[(code:)]670 norm2
[2(        fadd    st1             ; this sets st0 := st0 + st1 )]653 code1
[2(        fadd    st0,st1         ; so does this )]642 code0
[2()]631 code0
[2(        fadd    st1,st0         ; this sets st1 := st1 + st0 )]620 code0
[2(        fadd    to st1          ; so does this)]609 code2
[(Almost any floating-point instruction that references memory must use one of the prefixes )2(DWORD)0(,)]592 norm1
[2(QWORD)0( or )2(TWORD)0( to indicate what size of )(memory operand it refers to.)]581 norm2
[{/section-3.2 xa}(Pseudo-Instructions)](3.2)561 head3
[(Pseudo-instructions are things which, though not real x86 machine instructions, are used in the)]544 norm1
[(instruction field anyway because that's the most convenient place to put them. The current)]533 norm0
[(pseudo-instructions are )2(DB)0(, )2(DW)0(, )2(DD)0(, )2(DQ)0( and )2(DT)0(, their )(uninitialised counterparts )2(RESB)0(, )2(RESW)0(,)]522 norm0
[2(RESD)0(, )2(RESQ)0( and )2(REST)0(, the )2(INCBIN)0( command, the )2(EQU)0( command, and the )2(TIMES)0( prefix.)]511 norm2
[{/section-3.2.1 xa}2(DB)0( and friends: Declaring Initialised Data)](3.2.1)493 subh3
[2(DB)0(, )2(DW)0(, )2(DD)0(, )2(DQ)0( and )2(DT)0( are used, much as in MASM, to declare initialised data in the output file.)]476 norm1
[(They can be invoked in a wide range of ways: )]465 norm2
[2(      db    0x55                ; just the byte 0x55 )]448 code1
[2(      db    0x55,0x56,0x57      ; three bytes in succession )]437 code0
[2(      db    'a',0x55            ; character constants are OK )]426 code0
[2(      db    'hello',13,10,'$'   ; so are string constants )]415 code0
[2(      dw    0x1234              ; 0x34 0x12 )]404 code0
[2(      dw    'a'                 ; 0x61 0x00 \(it's just a number\) )]393 code0
[2(      dw    'ab'                ; 0x61 0x62 \(character constant\) )]382 code0
[2(      dw    'abc'               ; 0x61 0x62 0x63 0x00 \(string\) )]371 code0
[2(      dd    0x12345678          ; 0x78 0x56 0x34 0x12 )]360 code0
[2(      dd    1.234567e20         ; floating-point constant )]349 code0
[2(      dq    1.234567e20         ; double-precision float )]338 code0
[2(      dt    1.234567e20         ; extended-precision float)]327 code2
[2(DQ)0( and )2(DT)0( do not accept )(numeric constants or string constants as operands.)]310 norm3
[{/section-3.2.2 xa}2(RESB)0( and friends: Declaring )(Uninitialised Data)](3.2.2)292 subh3
[2(RESB)0(, )2(RESW)0(, )2(RESD)0(, )2(RESQ)0( and )2(REST)0( are designed to be used in the BSS section of a module: they)]275 norm1
[(declare )1(uninitialised)0( storage space. Each takes a single operand, which is the number of bytes,)]264 norm0
[(words, doublewords or whatever to reserve. As stated in ){/section-2.2.7 xl}(section 2.2.7){el}(, NASM does not support the)]253 norm0
[(MASM/TASM syntax of reserving uninitialised space by writing )2(DW ?)0( or similar things: this is)]242 norm0
[(what it does instead. The operand to a )2(RESB)0(\226type pseudo-instruction is a )1(critical expression)0(: see)]231 norm0
[{/section-3.8 xl}(section 3.8){el}(.)]220 norm2
[(For example:)]203 norm3
[2(buffer:         resb    64              ; reserve 64 bytes )]186 code1
[2(wordvar:        resw    1               ; reserve a word )]175 code0
[2(realarray       resq    10              ; array of ten reals)]164 code2
[{/section-3.2.3 xa}2(INCBIN)0(: Including External )(Binary Files)](3.2.3)146 subh3
[2(INCBIN)0( is borrowed from the old Amiga assembler )(DevPac: it includes a binary file verbatim into)]129 norm1
[(the output file. This can be handy for \(for example\) including )(graphics and )(sound data directly into)]118 norm0
[(a game executable file. It can be called in one of these three ways:)]107 norm2
(32)pageeven
restore showpage
%%Page: 33 33
%%BeginPageSetup
save
%%EndPageSetup
/33 pa
[2(    incbin  "file.dat"             ; include the whole file )]681 code1
[2(    incbin  "file.dat",1024        ; skip the first 1024 bytes )]670 code0
[2(    incbin  "file.dat",1024,512    ; skip the first 1024, and )]659 code0
[2(                                   ; actually include at most 512)]648 code2
[{/section-3.2.4 xa}2(EQU)0(: Defining Constants)](3.2.4)630 subh3
[2(EQU)0( defines a symbol to a given constant value: when )2(EQU)0( is used, the source line must contain a)]613 norm1
[(label. The action of )2(EQU)0( is to define the given label name to the value of its \(only\) operand. This)]602 norm0
[(definition is absolute, and cannot change later. So, for example,)]591 norm2
[2(message         db      'hello, world' )]574 code1
[2(msglen          equ     $-message)]563 code2
[(defines )2(msglen)0( to be the constant 12. )2(msglen)0( may not then be redefined later. This is not a)]546 norm1
[(preprocessor definition either: the value of )2(msglen)0( is evaluated )1(once)0(, using the value of )2($)0( \(see)]535 norm0
[{/section-3.5 xl}(section 3.5){el}( for an explanation of )2($)0(\) at the point of definition, rather than being evaluated wherever)]524 norm0
[(it is referenced and using the value of )2($)0( at the point of reference. Note that the operand to an )2(EQU)0( is)]513 norm0
[(also a )(critical expression \(){/section-3.8 xl}(section 3.8){el}(\).)]502 norm2
[{/section-3.2.5 xa}2(TIMES)0(: )(Repeating Instructions or Data)](3.2.5)484 subh3
[(The )2(TIMES)0( prefix causes the instruction to be assembled multiple times. This is partly present as)]467 norm1
[(NASM's equivalent of the )2(DUP)0( syntax supported by )(MASM\226compatible assemblers, in that you)]456 norm0
[(can code)]445 norm2
[2(zerobuf:        times 64 db 0)]428 code3
[(or similar things; but )2(TIMES)0( is more versatile than that. The argument to )2(TIMES)0( is not just a)]411 norm1
[(numeric constant, but a numeric )1(expression)0(, so you can do things like)]400 norm2
[2(buffer: db      'hello, world' )]383 code1
[2(        times 64-$+buffer db ' ')]372 code2
[(which will store exactly enough spaces to make the total length of )2(buffer)0( up to 64. Finally,)]355 norm1
[2(TIMES)0( can be applied to ordinary instructions, so you can code trivial )(unrolled loops in it:)]344 norm2
[2(        times 100 movsb)]327 code3
[(Note that there is no effective difference between )2(times 100 resb 1)0( and )2(resb 100)0(, except)]310 norm1
[(that the latter will be assembled about 100 times faster due to the internal structure of the assembler.)]299 norm2
[(The operand to )2(TIMES)0(, like that of )2(EQU)0( and those of )2(RESB)0( and friends, is a critical expression)]282 norm1
[(\(){/section-3.8 xl}(section 3.8){el}(\).)]271 norm2
[(Note also that )2(TIMES)0( can't be applied to )(macros: the reason for this is that )2(TIMES)0( is processed)]254 norm1
[(after the macro phase, which allows the argument to )2(TIMES)0( to contain expressions such as)]243 norm0
[2(64-$+buffer)0( as above. To repeat more than one line of code, or a complex macro, use the)]232 norm0
[(preprocessor )2(%rep)0( directive.)]221 norm2
[{/section-3.3 xa}(Effective Addresses)](3.3)201 head3
[(An )(effective address is any operand to an instruction which )(references memory. Effective addresses,)]184 norm1
[(in NASM, have a very simple syntax: they consist of an expression evaluating to the desired)]173 norm0
[(address, enclosed in )(square brackets. For example:)]162 norm2
[2(wordvar dw      123 )]145 code1
[2(        mov     ax,[wordvar] )]134 code0
[2(        mov     ax,[wordvar+1] )]123 code0
[2(        mov     ax,[es:wordvar+bx])]112 code2
(33)pageodd
restore showpage
%%Page: 34 34
%%BeginPageSetup
save
%%EndPageSetup
/34 pa
[(Anything not conforming to this simple system is not a valid memory reference in NASM, for)]681 norm1
[(example )2(es:wordvar[bx])0(.)]670 norm2
[(More complicated effective addresses, such as those involving more than one register, work in)]653 norm1
[(exactly the same way:)]642 norm2
[2(        mov     eax,[ebx*2+ecx+offset] )]625 code1
[2(        mov     ax,[bp+di+8])]614 code2
[(NASM is capable of doing )(algebra on these effective addresses, so that things which don't)]597 norm1
[(necessarily )1(look)0( legal are perfectly all right:)]586 norm2
[2(    mov     eax,[ebx*5]             ; assembles as [ebx*4+ebx] )]569 code1
[2(    mov     eax,[label1*2-label2]   ; ie [label1+\(label1-label2\)])]558 code2
[(Some forms of effective address have more than one assembled form; in most such cases NASM)]541 norm1
[(will generate the smallest form it can. For example, there are distinct assembled forms for the)]530 norm0
[(32-bit effective addresses )2([eax*2+0])0( and )2([eax+eax])0(, and NASM will generally generate the)]519 norm0
[(latter on the grounds that the former requires four bytes to store a zero offset.)]508 norm2
[(NASM has a hinting mechanism which will cause )2([eax+ebx])0( and )2([ebx+eax])0( to generate)]491 norm1
[(different opcodes; this is occasionally useful because )2([esi+ebp])0( and )2([ebp+esi])0( have different)]480 norm0
[(default segment registers.)]469 norm2
[(However, you can force NASM to generate an effective address in a particular form by the use of)]452 norm1
[(the keywords )2(BYTE)0(, )2(WORD)0(, )2(DWORD)0( and )2(NOSPLIT)0(. If you need )2([eax+3])0( to be assembled using a)]441 norm0
[(double-word offset field instead of the one byte NASM will normally generate, you can code)]430 norm0
[2([dword eax+3])0(. Similarly, you can force NASM to use a byte offset for a small value which it)]419 norm0
[(hasn't seen on the first pass \(see ){/section-3.8 xl}(section 3.8){el}( for an example of such a code fragment\) by using)]408 norm0
[2([byte eax+offset])0(. As special cases, )2([byte eax])0( will code )2([eax+0])0( with a byte offset)]397 norm0
[(of zero, and )2([dword eax])0( will code it with a double-word offset of zero. The normal form,)]386 norm0
[2([eax])0(, will be coded with no offset field.)]375 norm2
[(The form described in the previous paragraph is also useful if you are trying to access data in a)]358 norm1
[(32-bit segment from within 16 bit code. For more information on this see the section on)]347 norm0
[(mixed-size addressing \(){/section-9.2 xl}(section 9.2){el}(\). In particular, if you need to access data with a known offset)]336 norm0
[(that is larger than will fit in a 16-bit value, if you don't specify that it is a dword offset, nasm will)]325 norm0
[(cause the high word of the offset to be lost.)]314 norm2
[(Similarly, NASM will split )2([eax*2])0( into )2([eax+eax])0( because that allows the offset field to be)]297 norm1
[(absent and space to be saved; in fact, it will also split )2([eax*2+offset])0( into)]286 norm0
[2([eax+eax+offset])0(. You can combat this behaviour by the use of the )2(NOSPLIT)0( keyword:)]275 norm0
[2([nosplit eax*2])0( will force )2([eax*2+0])0( to be generated literally.)]264 norm2
[{/section-3.4 xa}(Constants)](3.4)244 head3
[(NASM understands four different types of constant: numeric, character, string and floating-point.)]227 norm3
[{/section-3.4.1 xa}(Numeric Constants)](3.4.1)209 subh3
[(A numeric constant is simply a number. NASM allows you to specify numbers in a variety of)]192 norm1
[(number bases, in a variety of ways: you can suffix )2(H)0(, )2(Q)0( or )2(O)0(, and )2(B)0( for )(hex, )(octal and )(binary, or you)]181 norm0
[(can prefix )2(0x)0( for hex in the style of C, or you can prefix )2($)0( for hex in the style of Borland Pascal.)]170 norm0
[(Note, though, that the )2($)0( prefix does double duty as a prefix on identifiers \(see ){/section-3.1 xl}(section 3.1){el}(\), so a hex)]159 norm0
[(number prefixed with a )2($)0( sign must have a digit after the )2($)0( rather than a letter.)]148 norm2
[(Some examples:)]131 norm3
[2(        mov     ax,100          ; decimal )]114 code1
[2(        mov     ax,0a2h         ; hex )]103 code0
(34)pageeven
restore showpage
%%Page: 35 35
%%BeginPageSetup
save
%%EndPageSetup
/35 pa
[2(        mov     ax,$0a2         ; hex again: the 0 is required )]681 code0
[2(        mov     ax,0xa2         ; hex yet again )]670 code0
[2(        mov     ax,777q         ; octal )]659 code0
[2(        mov     ax,777o         ; octal again )]648 code0
[2(        mov     ax,10010011b    ; binary)]637 code2
[{/section-3.4.2 xa}(Character Constants)](3.4.2)619 subh3
[(A character constant consists of up to four characters enclosed in either single or double quotes. The)]602 norm1
[(type of quote makes no difference to NASM, except of course that surrounding the constant with)]591 norm0
[(single quotes allows double quotes to appear within it and vice versa.)]580 norm2
[(A character constant with more than one character will be arranged with )(little-endian order in mind:)]563 norm1
[(if you code)]552 norm2
[2(          mov eax,'abcd')]535 code3
[(then the constant generated is not )2(0x61626364)0(, but )2(0x64636261)0(, so that if you were then to)]518 norm1
[(store the value into memory, it would read )2(abcd)0( rather than )2(dcba)0(. This is also the sense of)]507 norm0
[(character constants understood by the Pentium's )2(CPUID)0( instruction \(see ){/section-B.4.34 xl}(section B.4.34){el}(\).)]496 norm2
[{/section-3.4.3 xa}(String Constants)](3.4.3)478 subh3
[(String constants are only acceptable to some pseudo-instructions, namely the )2(DB)0( family and)]461 norm1
[2(INCBIN)0(.)]450 norm2
[(A string constant looks like a character constant, only longer. It is treated as a concatenation of)]433 norm1
[(maximum-size character constants for the conditions. So the following are equivalent:)]422 norm2
[2(      db    'hello'               ; string constant )]405 code1
[2(      db    'h','e','l','l','o'   ; equivalent character constants)]394 code2
[(And the following are also equivalent:)]377 norm3
[2(      dd    'ninechars'           ; doubleword string constant )]360 code1
[2(      dd    'nine','char','s'     ; becomes three doublewords )]349 code0
[2(      db    'ninechars',0,0,0     ; and really looks like this)]338 code2
[(Note that when used as an operand to )2(db)0(, a constant like )2('ab')0( is treated as a string constant)]321 norm1
[(despite being short enough to be a character constant, because otherwise )2(db 'ab')0( would have the)]310 norm0
[(same effect as )2(db 'a')0(, which would be silly. Similarly, three-character or four-character)]299 norm0
[(constants are treated as strings when they are operands to )2(dw)0(.)]288 norm2
[{/section-3.4.4 xa}(Floating-Point Constants)](3.4.4)270 subh3
[(Floating-point constants are acceptable only as arguments to )2(DD)0(, )2(DQ)0( and )2(DT)0(. They are expressed in)]253 norm1
[(the traditional form: digits, then a period, then optionally more digits, then optionally an )2(E)0( followed)]242 norm0
[(by an exponent. The period is mandatory, so that NASM can distinguish between )2(dd 1)0(, which)]231 norm0
[(declares an integer constant, and )2(dd 1.0)0( which declares a floating-point constant.)]220 norm2
[(Some examples:)]203 norm3
[2(      dd    1.2                     ; an easy one )]186 code1
[2(      dq    1.e10                   ; 10,000,000,000 )]175 code0
[2(      dq    1.e+10                  ; synonymous with 1.e10 )]164 code0
[2(      dq    1.e-10                  ; 0.000 000 000 1 )]153 code0
[2(      dt    3.141592653589793238462 ; pi)]142 code2
[(NASM cannot do compile-time arithmetic on floating-point constants. This is because NASM is)]125 norm1
[(designed to be portable \226 although it always generates code to run on x86 processors, the assembler)]114 norm0
[(itself can run on any system with an ANSI C compiler. Therefore, the assembler cannot guarantee)]103 norm0
(35)pageodd
restore showpage
%%Page: 36 36
%%BeginPageSetup
save
%%EndPageSetup
/36 pa
[(the presence of a floating-point unit capable of handling the )(Intel number formats, and so for)]681 norm0
[(NASM to be able to do floating arithmetic it would have to include its own complete set of)]670 norm0
[(floating-point routines, which would significantly increase the size of the assembler for very little)]659 norm0
[(benefit.)]648 norm2
[{/section-3.5 xa}(Expressions)](3.5)628 head3
[(Expressions in NASM are similar in syntax to those in C.)]611 norm3
[(NASM does not guarantee the size of the integers used to evaluate expressions at compile time:)]594 norm1
[(since NASM can compile and run on 64-bit systems quite happily, don't assume that expressions)]583 norm0
[(are evaluated in 32-bit registers and so try to make deliberate use of )(integer overflow. It might not)]572 norm0
[(always work. The only thing NASM will guarantee is what's guaranteed by ANSI C: you always)]561 norm0
[(have )1(at least)0( 32 bits to work in.)]550 norm2
[(NASM supports two special tokens in expressions, allowing calculations to involve the current)]533 norm1
[(assembly position: the )2($)0( and )2($$)0( tokens. )2($)0( evaluates to the assembly position at the beginning of the)]522 norm0
[(line containing the expression; so you can code an )(infinite loop using )2(JMP $)0(. )2($$)0( evaluates to the)]511 norm0
[(beginning of the current section; so you can tell how far into the section you are by using )2(\($-$$\))0(.)]500 norm2
[(The arithmetic )(operators provided by NASM are listed here, in increasing order of )(precedence.)]483 norm3
[{/section-3.5.1 xa}2(|)0(: )(Bitwise OR Operator)](3.5.1)465 subh3
[(The )2(|)0( operator gives a bitwise OR, exactly as performed by the )2(OR)0( machine instruction. Bitwise)]448 norm1
[(OR is the lowest-priority arithmetic operator supported by NASM.)]437 norm2
[{/section-3.5.2 xa}2(^)0(: )(Bitwise XOR Operator)](3.5.2)419 subh3
[2(^)0( provides the bitwise XOR operation.)]402 norm3
[{/section-3.5.3 xa}2(&)0(: )(Bitwise AND Operator)](3.5.3)384 subh3
[2(&)0( provides the bitwise AND operation.)]367 norm3
[{/section-3.5.4 xa}2(<<)0( and )2(>>)0(: )(Bit Shift Operators)](3.5.4)349 subh3
[2(<<)0( gives a bit-shift to the left, just as it does in C. So )2(5<<3)0( evaluates to 5 times 8, or 40. )2(>>)0( gives)]332 norm1
[(a bit-shift to the right; in NASM, such a shift is )1(always)0( unsigned, so that the bits shifted in from the)]321 norm0
[(left-hand end are filled with zero rather than a sign-extension of the previous highest bit.)]310 norm2
[{/section-3.5.5 xa}2(+)0( and )2(-)0(: )(Addition and )(Subtraction Operators)](3.5.5)292 subh3
[(The )2(+)0( and )2(-)0( operators do perfectly ordinary addition and subtraction.)]275 norm3
[{/section-3.5.6 xa}2(*)0(, )2(/)0(, )2(//)0(, )2(%)0( and )2(%%)0(: )(Multiplication and )(Division)](3.5.6)257 subh3
[2(*)0( is the multiplication operator. )2(/)0( and )2(//)0( are both division operators: )2(/)0( is )(unsigned division and )2(//)]240 norm1
[(is )(signed division. Similarly, )2(%)0( and )2(%%)0( provide )(unsigned and )(signed modulo operators respectively.)]229 norm2
[(NASM, like ANSI C, provides no guarantees about the sensible operation of the signed modulo)]212 norm1
[(operator.)]201 norm2
[(Since the )2(%)0( character is used extensively by the macro )(preprocessor, you should ensure that both the)]184 norm1
[(signed and unsigned modulo operators are followed by white space wherever they appear.)]173 norm2
[{/section-3.5.7 xa}(Unary Operators: )2(+)0(, )2(-)0(, )2(~)0( and )2(SEG)](3.5.7)155 subh3
[(The highest-priority operators in NASM's expression grammar are those which only apply to one)]138 norm1
[(argument. )2(-)0( negates its operand, )2(+)0( does nothing \(it's provided for symmetry with )2(-)0(\), )2(~)0( computes)]127 norm0
[(the )(one's complement of its operand, and )2(SEG)0( provides the )(segment address of its operand)]116 norm0
[(\(explained in more detail in ){/section-3.6 xl}(section 3.6){el}(\).)]105 norm2
(36)pageeven
restore showpage
%%Page: 37 37
%%BeginPageSetup
save
%%EndPageSetup
/37 pa
[{/section-3.6 xa}2(SEG)0( and )2(WRT)](3.6)678 head3
[(When writing large 16-bit programs, which must be split into multiple )(segments, it is often)]661 norm1
[(necessary to be able to refer to the )(segment part of the address of a symbol. NASM supports the)]650 norm0
[2(SEG)0( operator to perform this function.)]639 norm2
[(The )2(SEG)0( operator returns the )1(preferred)0( segment base of a symbol, defined as the segment base)]622 norm1
[(relative to which the offset of the symbol makes sense. So the code)]611 norm2
[2(        mov     ax,seg symbol )]594 code1
[2(        mov     es,ax )]583 code0
[2(        mov     bx,symbol)]572 code2
[(will load )2(ES:BX)0( with a valid pointer to the symbol )2(symbol)0(.)]555 norm3
[(Things can be more complex than this: since 16-bit segments and )(groups may )(overlap, you might)]538 norm1
[(occasionally want to refer to some symbol using a different segment base from the preferred one.)]527 norm0
[(NASM lets you do this, by the use of the )2(WRT)0( \(With Reference To\) keyword. So you can do things)]516 norm0
[(like)]505 norm2
[2(        mov     ax,weird_seg        ; weird_seg is a segment base )]488 code1
[2(        mov     es,ax )]477 code0
[2(        mov     bx,symbol wrt weird_seg)]466 code2
[(to load )2(ES:BX)0( with a different, but functionally equivalent, pointer to the symbol )2(symbol)0(.)]449 norm3
[(NASM supports far \(inter-segment\) calls and jumps by means of the syntax)]432 norm1
[2(call segment:offset)0(, where )2(segment)0( and )2(offset)0( both represent immediate values. So to)]421 norm0
[(call a far procedure, you could code either of)]410 norm2
[2(        call    \(seg procedure\):procedure )]393 code1
[2(        call    weird_seg:\(procedure wrt weird_seg\))]382 code2
[(\(The parentheses are included for clarity, to show the intended parsing of the above instructions.)]365 norm1
[(They are not necessary in practice.\))]354 norm2
[(NASM supports the syntax )2(call far procedure)0( as a synonym for the first of the above)]337 norm1
[(usages. )2(JMP)0( works identically to )2(CALL)0( in these examples.)]326 norm2
[(To declare a )(far pointer to a data item in a data segment, you must code)]309 norm3
[2(        dw      symbol, seg symbol)]292 code3
[(NASM supports no convenient synonym for this, though you can always invent one using the)]275 norm1
[(macro processor.)]264 norm2
[{/section-3.7 xa}2(STRICT)0(: Inhibiting Optimization)](3.7)244 head3
[(When assembling with the optimizer set to level 2 or higher \(see ){/section-2.1.16 xl}(section 2.1.16){el}(\), NASM will use)]227 norm1
[(size specifiers \()2(BYTE)0(, )2(WORD)0(, )2(DWORD)0(, )2(QWORD)0(, or )2(TWORD)0(\), but will give them the smallest possible)]216 norm0
[(size. The keyword )2(STRICT)0( can be used to inhibit optimization and force a particular operand to be)]205 norm0
[(emitted in the specified size. For example, with the optimizer on, and in )2(BITS 16)0( mode,)]194 norm2
[2(        push dword 33)]177 code3
[(is encoded in three bytes )2(66 6A 21)0(, whereas)]160 norm3
[2(        push strict dword 33)]143 code3
[(is encoded in six bytes, with a full dword immediate operand )2(66 68 21 00 00 00)0(.)]126 norm3
(37)pageodd
restore showpage
%%Page: 38 38
%%BeginPageSetup
save
%%EndPageSetup
/38 pa
[(With the optimizer off, the same code \(six bytes\) is generated whether the )2(STRICT)0( keyword was)]681 norm1
[(used or not.)]670 norm2
[{/section-3.8 xa}(Critical Expressions)](3.8)650 head3
[(A limitation of NASM is that it is a )(two-pass assembler; unlike TASM and others, it will always do)]633 norm1
[(exactly two )(assembly passes. Therefore it is unable to cope with source files that are complex)]622 norm0
[(enough to require three or more passes.)]611 norm2
[(The first pass is used to determine the size of all the assembled code and data, so that the second)]594 norm1
[(pass, when generating all the code, knows all the symbol addresses the code refers to. So one thing)]583 norm0
[(NASM can't handle is code whose size depends on the value of a symbol declared after the code in)]572 norm0
[(question. For example,)]561 norm2
[2(        times \(label-$\) db 0 )]544 code1
[2(label:  db      'Where am I?')]533 code2
[(The argument to )2(TIMES)0( in this case could equally legally evaluate to anything at all; NASM will)]516 norm1
[(reject this example because it cannot tell the size of the )2(TIMES)0( line when it first sees it. It will just)]505 norm0
[(as firmly reject the slightly )(paradoxical code)]494 norm2
[2(        times \(label-$+1\) db 0 )]477 code1
[2(label:  db      'NOW where am I?')]466 code2
[(in which )1(any)0( value for the )2(TIMES)0( argument is by definition wrong!)]449 norm3
[(NASM rejects these examples by means of a concept called a )1(critical expression)0(, which is defined)]432 norm1
[(to be an expression whose value is required to be computable in the first pass, and which must)]421 norm0
[(therefore depend only on symbols defined before it. The argument to the )2(TIMES)0( prefix is a critical)]410 norm0
[(expression; for the same reason, the arguments to the )2(RESB)0( family of pseudo-instructions are also)]399 norm0
[(critical expressions.)]388 norm2
[(Critical expressions can crop up in other contexts as well: consider the following code.)]371 norm3
[2(                mov     ax,symbol1 )]354 code1
[2(symbol1         equ     symbol2 )]343 code0
[2(symbol2:)]332 code2
[(On the first pass, NASM cannot determine the value of )2(symbol1)0(, because )2(symbol1)0( is defined to)]315 norm1
[(be equal to )2(symbol2)0( which NASM hasn't seen yet. On the second pass, therefore, when it)]304 norm0
[(encounters the line )2(mov ax,symbol1)0(, it is unable to generate the code for it because it still)]293 norm0
[(doesn't know the value of )2(symbol1)0(. On the next line, it would see the )2(EQU)0( again and be able to)]282 norm0
[(determine the value of )2(symbol1)0(, but by then it would be too late.)]271 norm2
[(NASM avoids this problem by defining the right-hand side of an )2(EQU)0( statement to be a critical)]254 norm1
[(expression, so the definition of )2(symbol1)0( would be rejected in the first pass.)]243 norm2
[(There is a related issue involving )(forward references: consider this code fragment.)]226 norm3
[2(        mov     eax,[ebx+offset] )]209 code1
[2(offset  equ     10)]198 code2
[(NASM, on pass one, must calculate the size of the instruction )2(mov eax,[ebx+offset])]181 norm1
[(without knowing the value of )2(offset)0(. It has no way of knowing that )2(offset)0( is small enough to)]170 norm0
[(fit into a one-byte offset field and that it could therefore get away with generating a shorter form of)]159 norm0
[(the )(effective-address encoding; for all it knows, in pass one, )2(offset)0( could be a symbol in the)]148 norm0
[(code segment, and it might need the full four-byte form. So it is forced to compute the size of the)]137 norm0
[(instruction to accommodate a four-byte address part. In pass two, having made this decision, it is)]126 norm0
[(now forced to honour it and keep the instruction large, so the code generated in this case is not as)]115 norm0
(38)pageeven
restore showpage
%%Page: 39 39
%%BeginPageSetup
save
%%EndPageSetup
/39 pa
[(small as it could have been. This problem can be solved by defining )2(offset)0( before using it, or by)]681 norm0
[(forcing byte size in the effective address by coding )2([byte ebx+offset])0(.)]670 norm2
[(Note that use of the )2(-On)0( switch \(with n>=2\) makes some of the above no longer true \(see ){/section-2.1.16 xl}(section){el}]653 norm1
[{/section-2.1.16 xl}(2.1.16){el}(\).)]642 norm2
[{/section-3.9 xa}(Local Labels)](3.9)622 head3
[(NASM gives special treatment to symbols beginning with a )(period. A label beginning with a single)]605 norm1
[(period is treated as a )1(local)0( label, which means that it is associated with the previous non-local label.)]594 norm0
[(So, for example:)]583 norm2
[2(label1  ; some code )]566 code1
[2()]555 code0
[2(.loop )]544 code0
[2(        ; some more code )]533 code0
[2()]522 code0
[2(        jne     .loop )]511 code0
[2(        ret )]500 code0
[2()]489 code0
[2(label2  ; some code )]478 code0
[2()]467 code0
[2(.loop )]456 code0
[2(        ; some more code )]445 code0
[2()]434 code0
[2(        jne     .loop )]423 code0
[2(        ret)]412 code2
[(In the above code fragment, each )2(JNE)0( instruction jumps to the line immediately before it, because)]395 norm1
[(the two definitions of )2(.loop)0( are kept separate by virtue of each being associated with the previous)]384 norm0
[(non-local label.)]373 norm2
[(This form of local label handling is borrowed from the old Amiga assembler )(DevPac; however,)]356 norm1
[(NASM goes one step further, in allowing access to local labels from other parts of the code. This is)]345 norm0
[(achieved by means of )1(defining)0( a local label in terms of the previous non-local label: the first)]334 norm0
[(definition of )2(.loop)0( above is really defining a symbol called )2(label1.loop)0(, and the second)]323 norm0
[(defines a symbol called )2(label2.loop)0(. So, if you really needed to, you could write)]312 norm2
[2(label3  ; some more code )]295 code1
[2(        ; and some more )]284 code0
[2()]273 code0
[2(        jmp label1.loop)]262 code2
[(Sometimes it is useful \226 in a macro, for instance \226 to be able to define a label which can be)]245 norm1
[(referenced from anywhere but which doesn't interfere with the normal local-label mechanism. Such)]234 norm0
[(a label can't be non-local because it would interfere with subsequent definitions of, and references)]223 norm0
[(to, local labels; and it can't be local because the macro that defined it wouldn't know the label's full)]212 norm0
[(name. NASM therefore introduces a third type of label, which is probably only useful in macro)]201 norm0
[(definitions: if a label begins with the )(special prefix )2(..@)0(, then it does nothing to the local label)]190 norm0
[(mechanism. So you could code)]179 norm2
[2(label1:                         ; a non-local label )]162 code1
[2(.local:                         ; this is really label1.local )]151 code0
[2(..@@foo:                         ; this is a special symbol )]140 code0
[2(label2:                         ; another non-local label )]129 code0
[2(.local:                         ; this is really label2.local )]118 code0
(39)pageodd
restore showpage
%%Page: 40 40
%%BeginPageSetup
save
%%EndPageSetup
/40 pa
[2()]681 code0
[2(        jmp     ..@@foo          ; this will jump three lines up)]670 code2
[(NASM has the capacity to define other special symbols beginning with a double period: for)]653 norm1
[(example, )2(..start)0( is used to specify the entry point in the )2(obj)0( output format \(see ){/section-6.2.6 xl}(section 6.2.6){el}(\).)]642 norm2
(40)pageeven
restore showpage
%%Page: 41 41
%%BeginPageSetup
save
%%EndPageSetup
/41 pa
[{/chapter-4 xa}(Chapter 4: The NASM )(Preprocessor)]644 chap3
[(NASM contains a powerful )(macro processor, which supports conditional assembly, multi-level file)]609 norm1
[(inclusion, two forms of macro \(single-line and multi-line\), and a `context stack' mechanism for)]598 norm0
[(extra macro power. Preprocessor directives all begin with a )2(%)0( sign.)]587 norm2
[(The preprocessor collapses all lines which end with a backslash \(\\\) character into a single line. Thus:)]570 norm3
[2(%define THIS_VERY_LONG_MACRO_NAME_IS_DEFINED_TO \\\\ )]553 code1
[2(        THIS_VALUE)]542 code2
[(will work like a single-line macro without the backslash-newline sequence.)]525 norm3
[{/section-4.1 xa}(Single-Line Macros)](4.1)505 head3
[{/section-4.1.1 xa}(The Normal Way: )2(%define)](4.1.1)487 subh3
[(Single-line macros are defined using the )2(%define)0( preprocessor directive. The definitions work in)]470 norm1
[(a similar way to C; so you can do things like)]459 norm2
[2(%define ctrl    0x1F & )]442 code1
[2(%define param\(a,b\) \(\(a\)+\(a\)*\(b\)\) )]431 code0
[2()]420 code0
[2(        mov     byte [param\(2,ebx\)], ctrl 'D')]409 code2
[(which will expand to)]392 norm3
[2(        mov     byte [\(2\)+\(2\)*\(ebx\)], 0x1F & 'D')]375 code3
[(When the expansion of a single-line macro contains tokens which invoke another macro, the)]358 norm1
[(expansion is performed at invocation time, not at definition time. Thus the code)]347 norm2
[2(%define a\(x\)    1+b\(x\) )]330 code1
[2(%define b\(x\)    2*x )]319 code0
[2()]308 code0
[2(        mov     ax,a\(8\))]297 code2
[(will evaluate in the expected way to )2(mov ax,1+2*8)0(, even though the macro )2(b)0( wasn't defined at)]280 norm1
[(the time of definition of )2(a)0(.)]269 norm2
[(Macros defined with )2(%define)0( are )(case sensitive: after )2(%define foo bar)0(, only )2(foo)0( will)]252 norm1
[(expand to )2(bar)0(: )2(Foo)0( or )2(FOO)0( will not. By using )2(%idefine)0( instead of )2(%define)0( \(the `i' stands for)]241 norm0
[(`insensitive'\) you can define all the case variants of a macro at once, so that )2(%idefine foo bar)]230 norm0
[(would cause )2(foo)0(, )2(Foo)0(, )2(FOO)0(, )2(fOO)0( and so on all to expand to )2(bar)0(.)]219 norm2
[(There is a mechanism which detects when a macro call has occurred as a result of a previous)]202 norm1
[(expansion of the same macro, to guard against )(circular references and infinite loops. If this happens,)]191 norm0
[(the preprocessor will only expand the first occurrence of the macro. Hence, if you code)]180 norm2
[2(%define a\(x\)    1+a\(x\) )]163 code1
[2()]152 code0
[2(        mov     ax,a\(3\))]141 code2
[(the macro )2(a\(3\))0( will expand once, becoming )2(1+a\(3\))0(, and will then expand no further. This)]124 norm1
[(behaviour can be useful: see ){/section-8.1 xl}(section 8.1){el}( for an example of its use.)]113 norm2
(41)pageodd
restore showpage
%%Page: 42 42
%%BeginPageSetup
save
%%EndPageSetup
/42 pa
[(You can )(overload single-line macros: if you write)]681 norm3
[2(%define foo\(x\)   1+x )]664 code1
[2(%define foo\(x,y\) 1+x*y)]653 code2
[(the preprocessor will be able to handle both types of macro call, by counting the parameters you)]636 norm1
[(pass; so )2(foo\(3\))0( will become )2(1+3)0( whereas )2(foo\(ebx,2\))0( will become )2(1+ebx*2)0(. However, if)]625 norm0
[(you define)]614 norm2
[2(%define foo bar)]597 code3
[(then no other definition of )2(foo)0( will be accepted: a macro with no parameters prohibits the)]580 norm1
[(definition of the same name as a macro )1(with)0( parameters, and vice versa.)]569 norm2
[(This doesn't prevent single-line macros being )1(redefined)0(: you can perfectly well define a macro with)]552 norm3
[2(%define foo bar)]535 code3
[(and then re-define it later in the same source file with)]518 norm3
[2(%define foo baz)]501 code3
[(Then everywhere the macro )2(foo)0( is invoked, it will be expanded according to the most recent)]484 norm1
[(definition. This is particularly useful when defining single-line macros with )2(%assign)0( \(see ){/section-4.1.5 xl}(section){el}]473 norm0
[{/section-4.1.5 xl}(4.1.5){el}(\).)]462 norm2
[(You can )(pre-define single-line macros using the `-d' option on the NASM command line: see)]445 norm1
[{/section-2.1.12 xl}(section 2.1.12){el}(.)]434 norm2
[{/section-4.1.2 xa}(Enhancing %define: )2(%xdefine)](4.1.2)416 subh3
[(To have a reference to an embedded single-line macro resolved at the time that it is embedded, as)]399 norm1
[(opposed to when the calling macro is expanded, you need a different mechanism to the one offered)]388 norm0
[(by )2(%define)0(. The solution is to use )2(%xdefine)0(, or it's )(case-insensitive counterpart )2(%xidefine)0(.)]377 norm2
[(Suppose you have the following code:)]360 norm3
[2(%define  isTrue  1 )]343 code1
[2(%define  isFalse isTrue )]332 code0
[2(%define  isTrue  0 )]321 code0
[2()]310 code0
[2(val1:    db      isFalse )]299 code0
[2()]288 code0
[2(%define  isTrue  1 )]277 code0
[2()]266 code0
[2(val2:    db      isFalse)]255 code2
[(In this case, )2(val1)0( is equal to 0, and )2(val2)0( is equal to 1. This is because, when a single-line macro)]238 norm1
[(is defined using )2(%define)0(, it is expanded only when it is called. As )2(isFalse)0( expands to)]227 norm0
[2(isTrue)0(, the expansion will be the current value of )2(isTrue)0(. The first time it is called that is 0, and)]216 norm0
[(the second time it is 1.)]205 norm2
[(If you wanted )2(isFalse)0( to expand to the value assigned to the embedded macro )2(isTrue)0( at the)]188 norm1
[(time that )2(isFalse)0( was defined, you need to change the above code to use )2(%xdefine)0(.)]177 norm2
[2(%xdefine isTrue  1 )]160 code1
[2(%xdefine isFalse isTrue )]149 code0
[2(%xdefine isTrue  0 )]138 code0
[2()]127 code0
[2(val1:    db      isFalse )]116 code0
[2()]105 code0
(42)pageeven
restore showpage
%%Page: 43 43
%%BeginPageSetup
save
%%EndPageSetup
/43 pa
[2(%xdefine isTrue  1 )]681 code0
[2()]670 code0
[2(val2:    db      isFalse)]659 code2
[(Now, each time that )2(isFalse)0( is called, it expands to 1, as that is what the embedded macro)]642 norm1
[2(isTrue)0( expanded to at the time that )2(isFalse)0( was defined.)]631 norm2
[{/section-4.1.3 xa}(Concatenating Single Line Macro Tokens: )2(%+)](4.1.3)613 subh3
[(Individual tokens in single line macros can be concatenated, to produce longer tokens for later)]596 norm1
[(processing. This can be useful if there are several similar macros that perform similar functions.)]585 norm2
[(As an example, consider the following:)]568 norm3
[2(%define BDASTART 400h                ; Start of BIOS data area)]551 code3
[2(struc   tBIOSDA                      ; its structure )]534 code1
[2(        .COM1addr       RESW    1 )]523 code0
[2(        .COM2addr       RESW    1 )]512 code0
[2(        ; ..and so on )]501 code0
[2(endstruc)]490 code2
[(Now, if we need to access the elements of tBIOSDA in different places, we can end up with:)]473 norm3
[2(        mov     ax,BDASTART + tBIOSDA.COM1addr )]456 code1
[2(        mov     bx,BDASTART + tBIOSDA.COM2addr)]445 code2
[(This will become pretty ugly \(and tedious\) if used in many places, and can be reduced in size)]428 norm1
[(significantly by using the following macro:)]417 norm2
[2(; Macro to access BIOS variables by their names \(from tBDA\):)]400 code3
[2(%define BDA\(x\)  BDASTART + tBIOSDA. %+ x)]383 code3
[(Now the above code can be written as:)]366 norm3
[2(        mov     ax,BDA\(COM1addr\) )]349 code1
[2(        mov     bx,BDA\(COM2addr\))]338 code2
[(Using this feature, we can simplify references to a lot of macros \(and, in turn, reduce typing errors\).)]321 norm3
[{/section-4.1.4 xa}(Undefining macros: )2(%undef)](4.1.4)303 subh3
[(Single-line macros can be removed with the )2(%undef)0( command. For example, the following)]286 norm1
[(sequence:)]275 norm2
[2(%define foo bar )]258 code1
[2(%undef  foo )]247 code0
[2()]236 code0
[2(        mov     eax, foo)]225 code2
[(will expand to the instruction )2(mov eax, foo)0(, since after )2(%undef)0( the macro )2(foo)0( is no longer)]208 norm1
[(defined.)]197 norm2
[(Macros that would otherwise be pre-defined can be undefined on the command-line using the `-u')]180 norm1
[(option on the NASM command line: see ){/section-2.1.13 xl}(section 2.1.13){el}(.)]169 norm2
[{/section-4.1.5 xa}(Preprocessor Variables: )2(%assign)](4.1.5)151 subh3
[(An alternative way to define single-line macros is by means of the )2(%assign)0( command \(and its)]134 norm1
[(case-insensitive counterpart )2(%iassign)0(, which differs from )2(%assign)0( in exactly the same way)]123 norm0
[(that )2(%idefine)0( differs from )2(%define)0(\).)]112 norm2
(43)pageodd
restore showpage
%%Page: 44 44
%%BeginPageSetup
save
%%EndPageSetup
/44 pa
[2(%assign)0( is used to define single-line macros which take no parameters and have a numeric value.)]681 norm1
[(This value can be specified in the form of an expression, and it will be evaluated once, when the)]670 norm0
[2(%assign)0( directive is processed.)]659 norm2
[(Like )2(%define)0(, macros defined using )2(%assign)0( can be re-defined later, so you can do things like)]642 norm3
[2(%assign i i+1)]625 code3
[(to increment the numeric value of a macro.)]608 norm3
[2(%assign)0( is useful for controlling the termination of )2(%rep)0( preprocessor loops: see ){/section-4.5 xl}(section 4.5){el}( for)]591 norm1
[(an example of this. Another use for )2(%assign)0( is given in ){/section-7.4 xl}(section 7.4){el}( and ){/section-8.1 xl}(section 8.1){el}(.)]580 norm2
[(The expression passed to )2(%assign)0( is a )(critical expression \(see ){/section-3.8 xl}(section 3.8){el}(\), and must also evaluate)]563 norm1
[(to a pure number \(rather than a relocatable reference such as a code or data address, or anything)]552 norm0
[(involving a register\).)]541 norm2
[{/section-4.2 xa}(String Handling in Macros: )2(%strlen)0( and )2(%substr)](4.2)521 head3
[(It's often useful to be able to handle strings in macros. NASM supports two simple string handling)]504 norm1
[(macro operators from which more complex operations can be constructed.)]493 norm2
[{/section-4.2.1 xa}(String Length: )2(%strlen)](4.2.1)475 subh3
[(The )2(%strlen)0( macro is like )2(%assign)0( macro in that it creates \(or redefines\) a numeric value to a)]458 norm1
[(macro. The difference is that with )2(%strlen)0(, the numeric value is the length of a string. An)]447 norm0
[(example of the use of this would be:)]436 norm2
[2(%strlen charcnt 'my string')]419 code3
[(In this example, )2(charcnt)0( would receive the value 8, just as if an )2(%assign)0( had been used. In this)]402 norm1
[(example, )2('my string')0( was a literal string but it could also have been a single-line macro that)]391 norm0
[(expands to a string, as in the following example:)]380 norm2
[2(%define sometext 'my string' )]363 code1
[2(%strlen charcnt sometext)]352 code2
[(As in the first case, this would result in )2(charcnt)0( being assigned the value of 8.)]335 norm3
[{/section-4.2.2 xa}(Sub-strings: )2(%substr)](4.2.2)317 subh3
[(Individual letters in strings can be extracted using )2(%substr)0(. An example of its use is probably)]300 norm1
[(more useful than the description:)]289 norm2
[2(%substr mychar  'xyz' 1         ; equivalent to %define mychar 'x' )]272 code1
[2(%substr mychar  'xyz' 2         ; equivalent to %define mychar 'y' )]261 code0
[2(%substr mychar  'xyz' 3         ; equivalent to %define mychar 'z')]250 code2
[(In this example, mychar gets the value of 'y'. As with )2(%strlen)0( \(see ){/section-4.2.1 xl}(section 4.2.1){el}(\), the first)]233 norm1
[(parameter is the single-line macro to be created and the second is the string. The third parameter)]222 norm0
[(specifies which character is to be selected. Note that the first index is 1, not 0 and the last index is)]211 norm0
[(equal to the value that )2(%strlen)0( would assign given the same string. Index values out of range)]200 norm0
[(result in an empty string.)]189 norm2
[{/section-4.3 xa}(Multi-Line Macros: )2(%macro)](4.3)169 head3
[(Multi-line macros are much more like the type of macro seen in MASM and TASM: a multi-line)]152 norm1
[(macro definition in NASM looks something like this.)]141 norm2
[2(%macro  prologue 1 )]124 code1
[2()]113 code0
[2(        push    ebp )]102 code0
(44)pageeven
restore showpage
%%Page: 45 45
%%BeginPageSetup
save
%%EndPageSetup
/45 pa
[2(        mov     ebp,esp )]681 code0
[2(        sub     esp,%1 )]670 code0
[2()]659 code0
[2(%endmacro)]648 code2
[(This defines a C-like function prologue as a macro: so you would invoke the macro with a call such)]631 norm1
[(as)]620 norm2
[2(myfunc:   prologue 12)]603 code3
[(which would expand to the three lines of code)]586 norm3
[2(myfunc: push    ebp )]569 code1
[2(        mov     ebp,esp )]558 code0
[2(        sub     esp,12)]547 code2
[(The number )2(1)0( after the macro name in the )2(%macro)0( line defines the number of parameters the)]530 norm1
[(macro )2(prologue)0( expects to receive. The use of )2(%1)0( inside the macro definition refers to the first)]519 norm0
[(parameter to the macro call. With a macro taking more than one parameter, subsequent parameters)]508 norm0
[(would be referred to as )2(%2)0(, )2(%3)0( and so on.)]497 norm2
[(Multi-line macros, like single-line macros, are )(case-sensitive, unless you define them using the)]480 norm1
[(alternative directive )2(%imacro)0(.)]469 norm2
[(If you need to pass a comma as )1(part)0( of a parameter to a multi-line macro, you can do that by)]452 norm1
[(enclosing the entire parameter in )(braces. So you could code things like)]441 norm2
[2(%macro  silly 2 )]424 code1
[2()]413 code0
[2(    %2: db      %1 )]402 code0
[2()]391 code0
[2(%endmacro )]380 code0
[2()]369 code0
[2(        silly 'a', letter_a             ; letter_a:  db 'a' )]358 code0
[2(        silly 'ab', string_ab           ; string_ab: db 'ab' )]347 code0
[2(        silly @\\{13,10@\\}, crlf             ; crlf:      db 13,10)]336 code2
[{/section-4.3.1 xa}(Overloading Multi-Line Macros)](4.3.1)318 subh3
[(As with single-line macros, multi-line macros can be overloaded by defining the same macro name)]301 norm1
[(several times with different numbers of parameters. This time, no exception is made for macros)]290 norm0
[(with no parameters at all. So you could define)]279 norm2
[2(%macro  prologue 0 )]262 code1
[2()]251 code0
[2(        push    ebp )]240 code0
[2(        mov     ebp,esp )]229 code0
[2()]218 code0
[2(%endmacro)]207 code2
[(to define an alternative form of the function prologue which allocates no local stack space.)]190 norm3
[(Sometimes, however, you might want to `overload' a machine instruction; for example, you might)]173 norm1
[(want to define)]162 norm2
[2(%macro  push 2 )]145 code1
[2()]134 code0
[2(        push    %1 )]123 code0
[2(        push    %2 )]112 code0
(45)pageodd
restore showpage
%%Page: 46 46
%%BeginPageSetup
save
%%EndPageSetup
/46 pa
[2()]681 code0
[2(%endmacro)]670 code2
[(so that you could code)]653 norm3
[2(        push    ebx             ; this line is not a macro call )]636 code1
[2(        push    eax,ecx         ; but this one is)]625 code2
[(Ordinarily, NASM will give a warning for the first of the above two lines, since )2(push)0( is now)]608 norm1
[(defined to be a macro, and is being invoked with a number of parameters for which no definition)]597 norm0
[(has been given. The correct code will still be generated, but the assembler will give a warning. This)]586 norm0
[(warning can be disabled by the use of the )2(-w-macro-params)0( command-line option \(see ){/section-2.1.18 xl}(section){el}]575 norm0
[{/section-2.1.18 xl}(2.1.18){el}(\).)]564 norm2
[{/section-4.3.2 xa}(Macro-Local Labels)](4.3.2)546 subh3
[(NASM allows you to define labels within a multi-line macro definition in such a way as to make)]529 norm1
[(them local to the macro call: so calling the same macro multiple times will use a different label each)]518 norm0
[(time. You do this by prefixing )2(%%)0( to the label name. So you can invent an instruction which)]507 norm0
[(executes a )2(RET)0( if the )2(Z)0( flag is set by doing this:)]496 norm2
[2(%macro  retz 0 )]479 code1
[2()]468 code0
[2(        jnz     %%skip )]457 code0
[2(        ret )]446 code0
[2(    %%skip: )]435 code0
[2()]424 code0
[2(%endmacro)]413 code2
[(You can call this macro as many times as you want, and every time you call it NASM will make up)]396 norm1
[(a different `real' name to substitute for the label )2(%%skip)0(. The names NASM invents are of the)]385 norm0
[(form )2(..@2345.skip)0(, where the number 2345 changes with every macro call. The )2(..@)0( prefix)]374 norm0
[(prevents macro-local labels from interfering with the local label mechanism, as described in ){/section-3.9 xl}(section){el}]363 norm0
[{/section-3.9 xl}(3.9){el}(. You should avoid defining your own labels in this form \(the )2(..@)0( prefix, then a number, then)]352 norm0
[(another period\) in case they interfere with macro-local labels.)]341 norm2
[{/section-4.3.3 xa}(Greedy Macro Parameters)](4.3.3)323 subh3
[(Occasionally it is useful to define a macro which lumps its entire command line into one parameter)]306 norm1
[(definition, possibly after extracting one or two smaller parameters from the front. An example)]295 norm0
[(might be a macro to write a text string to a file in MS-DOS, where you might want to be able to)]284 norm0
[(write)]273 norm2
[2(        writefile [filehandle],"hello, world",13,10)]256 code3
[(NASM allows you to define the last parameter of a macro to be )1(greedy)0(, meaning that if you invoke)]239 norm1
[(the macro with more parameters than it expects, all the spare parameters get lumped into the last)]228 norm0
[(defined one along with the separating commas. So if you code:)]217 norm2
[2(%macro  writefile 2+ )]200 code1
[2()]189 code0
[2(        jmp     %%endstr )]178 code0
[2(  %%str:        db      %2 )]167 code0
[2(  %%endstr: )]156 code0
[2(        mov     dx,%%str )]145 code0
[2(        mov     cx,%%endstr-%%str )]134 code0
[2(        mov     bx,%1 )]123 code0
[2(        mov     ah,0x40 )]112 code0
[2(        int     0x21 )]101 code0
(46)pageeven
restore showpage
%%Page: 47 47
%%BeginPageSetup
save
%%EndPageSetup
/47 pa
[2()]681 code0
[2(%endmacro)]670 code2
[(then the example call to )2(writefile)0( above will work as expected: the text before the first comma,)]653 norm1
[2([filehandle])0(, is used as the first macro parameter and expanded when )2(%1)0( is referred to, and all)]642 norm0
[(the subsequent text is lumped into )2(%2)0( and placed after the )2(db)0(.)]631 norm2
[(The greedy nature of the macro is indicated to NASM by the use of the )2(+)0( sign after the parameter)]614 norm1
[(count on the )2(%macro)0( line.)]603 norm2
[(If you define a greedy macro, you are effectively telling NASM how it should expand the macro)]586 norm1
[(given )1(any)0( number of parameters from the actual number specified up to infinity; in this case, for)]575 norm0
[(example, NASM now knows what to do when it sees a call to )2(writefile)0( with 2, 3, 4 or more)]564 norm0
[(parameters. NASM will take this into account when overloading macros, and will not allow you to)]553 norm0
[(define another form of )2(writefile)0( taking 4 parameters \(for example\).)]542 norm2
[(Of course, the above macro could have been implemented as a non-greedy macro, in which case)]525 norm1
[(the call to it would have had to look like)]514 norm2
[2(          writefile [filehandle], @\\{"hello, world",13,10@\\})]497 code3
[(NASM provides both mechanisms for putting )(commas in macro parameters, and you choose which)]480 norm1
[(one you prefer for each macro definition.)]469 norm2
[(See ){/section-5.2.1 xl}(section 5.2.1){el}( for a better way to write the above macro.)]452 norm3
[{/section-4.3.4 xa}(Default Macro Parameters)](4.3.4)434 subh3
[(NASM also allows you to define a multi-line macro with a )1(range)0( of allowable parameter counts. If)]417 norm1
[(you do this, you can specify defaults for )(omitted parameters. So, for example:)]406 norm2
[2(%macro  die 0-1 "Painful program death has occurred." )]389 code1
[2()]378 code0
[2(        writefile 2,%1 )]367 code0
[2(        mov     ax,0x4c01 )]356 code0
[2(        int     0x21 )]345 code0
[2()]334 code0
[2(%endmacro)]323 code2
[(This macro \(which makes use of the )2(writefile)0( macro defined in ){/section-4.3.3 xl}(section 4.3.3){el}(\) can be called)]306 norm1
[(with an explicit error message, which it will display on the error output stream before exiting, or it)]295 norm0
[(can be called with no parameters, in which case it will use the default error message supplied in the)]284 norm0
[(macro definition.)]273 norm2
[(In general, you supply a minimum and maximum number of parameters for a macro of this type; the)]256 norm1
[(minimum number of parameters are then required in the macro call, and then you provide defaults)]245 norm0
[(for the optional ones. So if a macro definition began with the line)]234 norm2
[2(%macro foobar 1-3 eax,[ebx+2])]217 code3
[(then it could be called with between one and three parameters, and )2(%1)0( would always be taken from)]200 norm1
[(the macro call. )2(%2)0(, if not specified by the macro call, would default to )2(eax)0(, and )2(%3)0( if not specified)]189 norm0
[(would default to )2([ebx+2])0(.)]178 norm2
[(You may omit parameter defaults from the macro definition, in which case the parameter default is)]161 norm1
[(taken to be blank. This can be useful for macros which can take a variable number of parameters,)]150 norm0
[(since the )2(%0)0( token \(see ){/section-4.3.5 xl}(section 4.3.5){el}(\) allows you to determine how many parameters were really)]139 norm0
[(passed to the macro call.)]128 norm2
(47)pageodd
restore showpage
%%Page: 48 48
%%BeginPageSetup
save
%%EndPageSetup
/48 pa
[(This defaulting mechanism can be combined with the greedy-parameter mechanism; so the )2(die)]681 norm1
[(macro above could be made more powerful, and more useful, by changing the first line of the)]670 norm0
[(definition to)]659 norm2
[2(%macro die 0-1+ "Painful program death has occurred.",13,10)]642 code3
[(The maximum parameter count can be infinite, denoted by )2(*)0(. In this case, of course, it is impossible)]625 norm1
[(to provide a )1(full)0( set of default parameters. Examples of this usage are shown in ){/section-4.3.6 xl}(section 4.3.6){el}(.)]614 norm2
[{/section-4.3.5 xa}2(%0)0(: )(Macro Parameter Counter)](4.3.5)596 subh3
[(For a macro which can take a variable number of parameters, the parameter reference )2(%0)0( will return)]579 norm1
[(a numeric constant giving the number of parameters passed to the macro. This can be used as an)]568 norm0
[(argument to )2(%rep)0( \(see ){/section-4.5 xl}(section 4.5){el}(\) in order to iterate through all the parameters of a macro.)]557 norm0
[(Examples are given in ){/section-4.3.6 xl}(section 4.3.6){el}(.)]546 norm2
[{/section-4.3.6 xa}2(%rotate)0(: )(Rotating Macro Parameters)](4.3.6)528 subh3
[(Unix shell programmers will be familiar with the )2(shift)0( shell command, which allows the)]511 norm1
[(arguments passed to a shell script \(referenced as )2($1)0(, )2($2)0( and so on\) to be moved left by one place,)]500 norm0
[(so that the argument previously referenced as )2($2)0( becomes available as )2($1)0(, and the argument)]489 norm0
[(previously referenced as )2($1)0( is no longer available at all.)]478 norm2
[(NASM provides a similar mechanism, in the form of )2(%rotate)0(. As its name suggests, it differs)]461 norm1
[(from the Unix )2(shift)0( in that no parameters are lost: parameters rotated off the left end of the)]450 norm0
[(argument list reappear on the right, and vice versa.)]439 norm2
[2(%rotate)0( is invoked with a single numeric argument \(which may be an expression\). The macro)]422 norm1
[(parameters are rotated to the left by that many places. If the argument to )2(%rotate)0( is negative, the)]411 norm0
[(macro parameters are rotated to the right.)]400 norm2
[(So a pair of macros to save and restore a set of registers might work as follows:)]383 norm3
[2(%macro  multipush 1-* )]366 code1
[2()]355 code0
[2(  %rep  %0 )]344 code0
[2(        push    %1 )]333 code0
[2(  %rotate 1 )]322 code0
[2(  %endrep )]311 code0
[2()]300 code0
[2(%endmacro)]289 code2
[(This macro invokes the )2(PUSH)0( instruction on each of its arguments in turn, from left to right. It)]272 norm1
[(begins by pushing its first argument, )2(%1)0(, then invokes )2(%rotate)0( to move all the arguments one)]261 norm0
[(place to the left, so that the original second argument is now available as )2(%1)0(. Repeating this)]250 norm0
[(procedure as many times as there were arguments \(achieved by supplying )2(%0)0( as the argument to)]239 norm0
[2(%rep)0(\) causes each argument in turn to be pushed.)]228 norm2
[(Note also the use of )2(*)0( as the maximum parameter count, indicating that there is no upper limit on)]211 norm1
[(the number of parameters you may supply to the )2(multipush)0( macro.)]200 norm2
[(It would be convenient, when using this macro, to have a )2(POP)0( equivalent, which )1(didn't)0( require the)]183 norm1
[(arguments to be given in reverse order. Ideally, you would write the )2(multipush)0( macro call, then)]172 norm0
[(cut-and-paste the line to where the pop needed to be done, and change the name of the called)]161 norm0
[(macro to )2(multipop)0(, and the macro would take care of popping the registers in the opposite order)]150 norm0
[(from the one in which they were pushed.)]139 norm2
[(This can be done by the following definition:)]122 norm3
(48)pageeven
restore showpage
%%Page: 49 49
%%BeginPageSetup
save
%%EndPageSetup
/49 pa
[2(%macro  multipop 1-* )]681 code1
[2()]670 code0
[2(  %rep %0 )]659 code0
[2(  %rotate -1 )]648 code0
[2(        pop     %1 )]637 code0
[2(  %endrep )]626 code0
[2()]615 code0
[2(%endmacro)]604 code2
[(This macro begins by rotating its arguments one place to the )1(right)0(, so that the original )1(last)0( argument)]587 norm1
[(appears as )2(%1)0(. This is then popped, and the arguments are rotated right again, so the second-to-last)]576 norm0
[(argument becomes )2(%1)0(. Thus the arguments are iterated through in reverse order.)]565 norm2
[{/section-4.3.7 xa}(Concatenating Macro Parameters)](4.3.7)547 subh3
[(NASM can concatenate macro parameters on to other text surrounding them. This allows you to)]530 norm1
[(declare a family of symbols, for example, in a macro definition. If, for example, you wanted to)]519 norm0
[(generate a table of key codes along with offsets into the table, you could code something like)]508 norm2
[2(%macro keytab_entry 2 )]491 code1
[2()]480 code0
[2(    keypos%1    equ     $-keytab )]469 code0
[2(                db      %2 )]458 code0
[2()]447 code0
[2(%endmacro )]436 code0
[2()]425 code0
[2(keytab: )]414 code0
[2(          keytab_entry F1,128+1 )]403 code0
[2(          keytab_entry F2,128+2 )]392 code0
[2(          keytab_entry Return,13)]381 code2
[(which would expand to)]364 norm3
[2(keytab: )]347 code1
[2(keyposF1        equ     $-keytab )]336 code0
[2(                db     128+1 )]325 code0
[2(keyposF2        equ     $-keytab )]314 code0
[2(                db      128+2 )]303 code0
[2(keyposReturn    equ     $-keytab )]292 code0
[2(                db      13)]281 code2
[(You can just as easily concatenate text on to the other end of a macro parameter, by writing )2(%1foo)0(.)]264 norm3
[(If you need to append a )1(digit)0( to a macro parameter, for example defining labels )2(foo1)0( and )2(foo2)]247 norm1
[(when passed the parameter )2(foo)0(, you can't code )2(%11)0( because that would be taken as the eleventh)]236 norm0
[(macro parameter. Instead, you must code )2(%{1}1)0(, which will separate the first )2(1)0( \(giving the number)]225 norm0
[(of the macro parameter\) from the second \(literal text to be concatenated to the parameter\).)]214 norm2
[(This concatenation can also be applied to other preprocessor in-line objects, such as macro-local)]197 norm1
[(labels \(){/section-4.3.2 xl}(section 4.3.2){el}(\) and context-local labels \(){/section-4.7.2 xl}(section 4.7.2){el}(\). In all cases, ambiguities in syntax can)]186 norm0
[(be resolved by enclosing everything after the )2(%)0( sign and before the literal text in braces: so)]175 norm0
[2(%{%foo}bar)0( concatenates the text )2(bar)0( to the end of the real name of the macro-local label)]164 norm0
[2(%%foo)0(. \(This is unnecessary, since the form NASM uses for the real names of macro-local labels)]153 norm0
[(means that the two usages )2(%{%foo}bar)0( and )2(%%foobar)0( would both expand to the same thing)]142 norm0
[(anyway; nevertheless, the capability is there.\))]131 norm2
(49)pageodd
restore showpage
%%Page: 50 50
%%BeginPageSetup
save
%%EndPageSetup
/50 pa
[{/section-4.3.8 xa}(Condition Codes as Macro Parameters)](4.3.8)680 subh3
[(NASM can give special treatment to a macro parameter which contains a condition code. For a)]663 norm1
[(start, you can refer to the macro parameter )2(%1)0( by means of the alternative syntax )2(%+1)0(, which)]652 norm0
[(informs NASM that this macro parameter is supposed to contain a condition code, and will cause)]641 norm0
[(the preprocessor to report an error message if the macro is called with a parameter which is )1(not)0( a)]630 norm0
[(valid condition code.)]619 norm2
[(Far more usefully, though, you can refer to the macro parameter by means of )2(%-1)0(, which NASM)]602 norm1
[(will expand as the )1(inverse)0( condition code. So the )2(retz)0( macro defined in ){/section-4.3.2 xl}(section 4.3.2){el}( can be)]591 norm0
[(replaced by a general )(conditional-return macro like this:)]580 norm2
[2(%macro  retc 1 )]563 code1
[2()]552 code0
[2(        j%-1    %%skip )]541 code0
[2(        ret )]530 code0
[2(  %%skip: )]519 code0
[2()]508 code0
[2(%endmacro)]497 code2
[(This macro can now be invoked using calls like )2(retc ne)0(, which will cause the conditional-jump)]480 norm1
[(instruction in the macro expansion to come out as )2(JE)0(, or )2(retc po)0( which will make the jump a)]469 norm0
[2(JPE)0(.)]458 norm2
[(The )2(%+1)0( macro-parameter reference is quite happy to interpret the arguments )2(CXZ)0( and )2(ECXZ)0( as)]441 norm1
[(valid condition codes; however, )2(%-1)0( will report an error if passed either of these, because no)]430 norm0
[(inverse condition code exists.)]419 norm2
[{/section-4.3.9 xa}(Disabling Listing Expansion)](4.3.9)401 subh3
[(When NASM is generating a listing file from your program, it will generally expand multi-line)]384 norm1
[(macros by means of writing the macro call and then listing each line of the expansion. This allows)]373 norm0
[(you to see which instructions in the macro expansion are generating what code; however, for some)]362 norm0
[(macros this clutters the listing up unnecessarily.)]351 norm2
[(NASM therefore provides the )2(.nolist)0( qualifier, which you can include in a macro definition to)]334 norm1
[(inhibit the expansion of the macro in the listing file. The )2(.nolist)0( qualifier comes directly after)]323 norm0
[(the number of parameters, like this:)]312 norm2
[2(%macro foo 1.nolist)]295 code3
[(Or like this:)]278 norm3
[2(%macro bar 1-5+.nolist a,b,c,d,e,f,g,h)]261 code3
[{/section-4.4 xa}(Conditional Assembly)](4.4)241 head3
[(Similarly to the C preprocessor, NASM allows sections of a source file to be assembled only if)]224 norm1
[(certain conditions are met. The general syntax of this feature looks like this:)]213 norm2
[2(%if<condition> )]196 code1
[2(    ; some code which only appears if <condition> is met )]185 code0
[2(%elif<condition2> )]174 code0
[2(    ; only appears if <condition> is not met but <condition2> is )]163 code0
[2(%else )]152 code0
[2(    ; this appears if neither <condition> nor <condition2> was met )]141 code0
[2(%endif)]130 code2
[(The )2(%else)0( clause is optional, as is the )2(%elif)0( clause. You can have more than one )2(%elif)0( clause)]113 norm1
[(as well.)]102 norm2
(50)pageeven
restore showpage
%%Page: 51 51
%%BeginPageSetup
save
%%EndPageSetup
/51 pa
[{/section-4.4.1 xa}2(%ifdef)0(: Testing Single-Line Macro Existence)](4.4.1)680 subh3
[(Beginning a conditional-assembly block with the line )2(%ifdef MACRO)0( will assemble the)]663 norm1
[(subsequent code if, and only if, a single-line macro called )2(MACRO)0( is defined. If not, then the)]652 norm0
[2(%elif)0( and )2(%else)0( blocks \(if any\) will be processed instead.)]641 norm2
[(For example, when debugging a program, you might want to write code such as)]624 norm3
[2(          ; perform some function )]607 code1
[2(%ifdef DEBUG )]596 code0
[2(          writefile 2,"Function performed successfully",13,10 )]585 code0
[2(%endif )]574 code0
[2(          ; go and do something else)]563 code2
[(Then you could use the command-line option )2(-dDEBUG)0( to create a version of the program which)]546 norm1
[(produced debugging messages, and remove the option to generate the final release version of the)]535 norm0
[(program.)]524 norm2
[(You can test for a macro )1(not)0( being defined by using )2(%ifndef)0( instead of )2(%ifdef)0(. You can also)]507 norm1
[(test for macro definitions in )2(%elif)0( blocks by using )2(%elifdef)0( and )2(%elifndef)0(.)]496 norm2
[{/section-4.4.2 xa}2(ifmacro)0(: Testing Multi-Line Macro Existence)](4.4.2)478 subh3
[(The )2(%ifmacro)0( directive operates in the same way as the )2(%ifdef)0( directive, except that it checks)]461 norm1
[(for the existence of a multi-line macro.)]450 norm2
[(For example, you may be working with a large project and not have control over the macros in a)]433 norm1
[(library. You may want to create a macro with one name if it doesn't already exist, and another name)]422 norm0
[(if one with that name does exist.)]411 norm2
[(The )2(%ifmacro)0( is considered true if defining a macro with the given name and number of)]394 norm1
[(arguments would cause a definitions conflict. For example:)]383 norm2
[2(%ifmacro MyMacro 1-3 )]366 code1
[2()]355 code0
[2(     %error "MyMacro 1-3" causes a conflict with an existing macro. )]344 code0
[2()]333 code0
[2(%else )]322 code0
[2()]311 code0
[2(     %macro MyMacro 1-3 )]300 code0
[2()]289 code0
[2(             ; insert code to define the macro )]278 code0
[2()]267 code0
[2(     %endmacro )]256 code0
[2()]245 code0
[2(%endif)]234 code2
[(This will create the macro "MyMacro 1-3" if no macro already exists which would conflict with it,)]217 norm1
[(and emits a warning if there would be a definition conflict.)]206 norm2
[(You can test for the macro not existing by using the )2(%ifnmacro)0( instead of )2(%ifmacro)0(.)]189 norm1
[(Additional tests can be performed in )2(%elif)0( blocks by using )2(%elifmacro)0( and )2(%elifnmacro)0(.)]178 norm2
[{/section-4.4.3 xa}2(%ifctx)0(: Testing the Context Stack)](4.4.3)160 subh3
[(The conditional-assembly construct )2(%ifctx ctxname)0( will cause the subsequent code to be)]143 norm1
[(assembled if and only if the top context on the preprocessor's context stack has the name)]132 norm0
[2(ctxname)0(. As with )2(%ifdef)0(, the inverse and )2(%elif)0( forms )2(%ifnctx)0(, )2(%elifctx)0( and)]121 norm0
[2(%elifnctx)0( are also supported.)]110 norm2
(51)pageodd
restore showpage
%%Page: 52 52
%%BeginPageSetup
save
%%EndPageSetup
/52 pa
[(For more details of the context stack, see ){/section-4.7 xl}(section 4.7){el}(. For a sample use of )2(%ifctx)0(, see ){/section-4.7.5 xl}(section){el}]681 norm1
[{/section-4.7.5 xl}(4.7.5){el}(.)]670 norm2
[{/section-4.4.4 xa}2(%if)0(: Testing Arbitrary Numeric Expressions)](4.4.4)652 subh3
[(The conditional-assembly construct )2(%if expr)0( will cause the subsequent code to be assembled if)]635 norm1
[(and only if the value of the numeric expression )2(expr)0( is non-zero. An example of the use of this)]624 norm0
[(feature is in deciding when to break out of a )2(%rep)0( preprocessor loop: see ){/section-4.5 xl}(section 4.5){el}( for a detailed)]613 norm0
[(example.)]602 norm2
[(The expression given to )2(%if)0(, and its counterpart )2(%elif)0(, is a critical expression \(see ){/section-3.8 xl}(section 3.8){el}(\).)]585 norm3
[2(%if)0( extends the normal NASM expression syntax, by providing a set of )(relational operators which)]568 norm1
[(are not normally available in expressions. The operators )2(=)0(, )2(<)0(, )2(>)0(, )2(<=)0(, )2(>=)0( and )2(<>)0( test equality,)]557 norm0
[(less-than, greater-than, less-or-equal, greater-or-equal and not-equal respectively. The C-like)]546 norm0
[(forms )2(==)0( and )2(!=)0( are supported as alternative forms of )2(=)0( and )2(<>)0(. In addition, low-priority logical)]535 norm0
[(operators )2(&&)0(, )2(^^)0( and )2(||)0( are provided, supplying )(logical AND, )(logical XOR and )(logical OR. These)]524 norm0
[(work like the C logical operators \(although C has no logical XOR\), in that they always return either)]513 norm0
[(0 or 1, and treat any non-zero input as 1 \(so that )2(^^)0(, for example, returns 1 if exactly one of its)]502 norm0
[(inputs is zero, and 0 otherwise\). The relational operators also return 1 for true and 0 for false.)]491 norm2
[{/section-4.4.5 xa}2(%ifidn)0( and )2(%ifidni)0(: Testing Exact Text Identity)](4.4.5)473 subh3
[(The construct )2(%ifidn text1,text2)0( will cause the subsequent code to be assembled if and)]456 norm1
[(only if )2(text1)0( and )2(text2)0(, after expanding single-line macros, are identical pieces of text.)]445 norm0
[(Differences in white space are not counted.)]434 norm2
[2(%ifidni)0( is similar to )2(%ifidn)0(, but is )(case-insensitive.)]417 norm3
[(For example, the following macro pushes a register or number on the stack, and allows you to treat)]400 norm1
[2(IP)0( as a real register:)]389 norm2
[2(%macro  pushparam 1 )]372 code1
[2()]361 code0
[2(  %ifidni %1,ip )]350 code0
[2(        call    %%label )]339 code0
[2(  %%label: )]328 code0
[2(  %else )]317 code0
[2(        push    %1 )]306 code0
[2(  %endif )]295 code0
[2()]284 code0
[2(%endmacro)]273 code2
[(Like most other )2(%if)0( constructs, )2(%ifidn)0( has a counterpart )2(%elifidn)0(, and negative forms)]256 norm1
[2(%ifnidn)0( and )2(%elifnidn)0(. Similarly, )2(%ifidni)0( has counterparts )2(%elifidni)0(, )2(%ifnidni)0( and)]245 norm0
[2(%elifnidni)0(.)]234 norm2
[{/section-4.4.6 xa}2(%ifid)0(, )2(%ifnum)0(, )2(%ifstr)0(: Testing Token Types)](4.4.6)216 subh3
[(Some macros will want to perform different tasks depending on whether they are passed a number,)]199 norm1
[(a string, or an identifier. For example, a string output macro might want to be able to cope with)]188 norm0
[(being passed either a string constant or a pointer to an existing string.)]177 norm2
[(The conditional assembly construct )2(%ifid)0(, taking one parameter \(which may be blank\), assembles)]160 norm1
[(the subsequent code if and only if the first token in the parameter exists and is an identifier.)]149 norm0
[2(%ifnum)0( works similarly, but tests for the token being a numeric constant; )2(%ifstr)0( tests for it)]138 norm0
[(being a string.)]127 norm2
(52)pageeven
restore showpage
%%Page: 53 53
%%BeginPageSetup
save
%%EndPageSetup
/53 pa
[(For example, the )2(writefile)0( macro defined in ){/section-4.3.3 xl}(section 4.3.3){el}( can be extended to take advantage of)]681 norm1
[2(%ifstr)0( in the following fashion:)]670 norm2
[2(%macro writefile 2-3+ )]653 code1
[2()]642 code0
[2(  %ifstr %2 )]631 code0
[2(        jmp     %%endstr )]620 code0
[2(    %if %0 = 3 )]609 code0
[2(      %%str:    db      %2,%3 )]598 code0
[2(    %else )]587 code0
[2(      %%str:    db      %2 )]576 code0
[2(    %endif )]565 code0
[2(      %%endstr: mov     dx,%%str )]554 code0
[2(                mov     cx,%%endstr-%%str )]543 code0
[2(  %else )]532 code0
[2(                mov     dx,%2 )]521 code0
[2(                mov     cx,%3 )]510 code0
[2(  %endif )]499 code0
[2(                mov     bx,%1 )]488 code0
[2(                mov     ah,0x40 )]477 code0
[2(                int     0x21 )]466 code0
[2()]455 code0
[2(%endmacro)]444 code2
[(Then the )2(writefile)0( macro can cope with being called in either of the following two ways:)]427 norm3
[2(        writefile [file], strpointer, length )]410 code1
[2(        writefile [file], "hello", 13, 10)]399 code2
[(In the first, )2(strpointer)0( is used as the address of an already-declared string, and )2(length)0( is)]382 norm1
[(used as its length; in the second, a string is given to the macro, which therefore declares it itself and)]371 norm0
[(works out the address and length for itself.)]360 norm2
[(Note the use of )2(%if)0( inside the )2(%ifstr)0(: this is to detect whether the macro was passed two)]343 norm1
[(arguments \(so the string would be a single string constant, and )2(db %2)0( would be adequate\) or more)]332 norm0
[(\(in which case, all but the first two would be lumped together into )2(%3)0(, and )2(db %2,%3)0( would be)]321 norm0
[(required\).)]310 norm2
[( )( The usual )2(%elifXXX)0(, )2(%ifnXXX)0( and )2(%elifnXXX)0( versions exist for each of )2(%ifid)0(, )2(%ifnum)]293 norm1
[(and )2(%ifstr)0(.)]282 norm2
[{/section-4.4.7 xa}2(%error)0(: Reporting )(User-Defined Errors)](4.4.7)264 subh3
[(The preprocessor directive )2(%error)0( will cause NASM to report an error if it occurs in assembled)]247 norm1
[(code. So if other users are going to try to assemble your source files, you can ensure that they define)]236 norm0
[(the right macros by means of code like this:)]225 norm2
[2(%ifdef SOME_MACRO )]208 code1
[2(    ; do some setup )]197 code0
[2(%elifdef SOME_OTHER_MACRO )]186 code0
[2(    ; do some different setup )]175 code0
[2(%else )]164 code0
[2(    %error Neither SOME_MACRO nor SOME_OTHER_MACRO was defined. )]153 code0
[2(%endif)]142 code2
[(Then any user who fails to understand the way your code is supposed to be assembled will be)]125 norm1
[(quickly warned of their mistake, rather than having to wait until the program crashes on being run)]114 norm0
[(and then not knowing what went wrong.)]103 norm2
(53)pageodd
restore showpage
%%Page: 54 54
%%BeginPageSetup
save
%%EndPageSetup
/54 pa
[{/section-4.5 xa}(Preprocessor Loops)(: )2(%rep)](4.5)678 head3
[(NASM's )2(TIMES)0( prefix, though useful, cannot be used to invoke a multi-line macro multiple times,)]661 norm1
[(because it is processed by NASM after macros have already been expanded. Therefore NASM)]650 norm0
[(provides another form of loop, this time at the preprocessor level: )2(%rep)0(.)]639 norm2
[(The directives )2(%rep)0( and )2(%endrep)0( \()2(%rep)0( takes a numeric argument, which can be an expression;)]622 norm1
[2(%endrep)0( takes no arguments\) can be used to enclose a chunk of code, which is then replicated as)]611 norm0
[(many times as specified by the preprocessor:)]600 norm2
[2(%assign i 0 )]583 code1
[2(%rep    64 )]572 code0
[2(        inc     word [table+2*i] )]561 code0
[2(%assign i i+1 )]550 code0
[2(%endrep)]539 code2
[(This will generate a sequence of 64 )2(INC)0( instructions, incrementing every word of memory from)]522 norm1
[2([table])0( to )2([table+126])0(.)]511 norm2
[(For more complex termination conditions, or to break out of a repeat loop part way along, you can)]494 norm1
[(use the )2(%exitrep)0( directive to terminate the loop, like this:)]483 norm2
[2(fibonacci: )]466 code1
[2(%assign i 0 )]455 code0
[2(%assign j 1 )]444 code0
[2(%rep 100 )]433 code0
[2(%if j > 65535 )]422 code0
[2(    %exitrep )]411 code0
[2(%endif )]400 code0
[2(        dw j )]389 code0
[2(%assign k j+i )]378 code0
[2(%assign i j )]367 code0
[2(%assign j k )]356 code0
[2(%endrep )]345 code0
[2()]334 code0
[2(fib_number equ \($-fibonacci\)/2)]323 code2
[(This produces a list of all the Fibonacci numbers that will fit in 16 bits. Note that a maximum repeat)]306 norm1
[(count must still be given to )2(%rep)0(. This is to prevent the possibility of NASM getting into an)]295 norm0
[(infinite loop in the preprocessor, which \(on multitasking or multi-user systems\) would typically)]284 norm0
[(cause all the system memory to be gradually used up and other applications to start crashing.)]273 norm2
[{/section-4.6 xa}(Including Other Files)](4.6)253 head3
[(Using, once again, a very similar syntax to the C preprocessor, NASM's preprocessor lets you)]236 norm1
[(include other source files into your code. This is done by the use of the )2(%include)0( directive:)]225 norm2
[2(%include "macros.mac")]208 code3
[(will include the contents of the file )2(macros.mac)0( into the source file containing the )2(%include)]191 norm1
[(directive.)]180 norm2
[(Include files are )(searched for in the current directory \(the directory you're in when you run NASM,)]163 norm1
[(as opposed to the location of the NASM executable or the location of the source file\), plus any)]152 norm0
[(directories specified on the NASM command line using the )2(-i)0( option.)]141 norm2
[(The standard C idiom for preventing a file being included more than once is just as applicable in)]124 norm1
[(NASM: if the file )2(macros.mac)0( has the form)]113 norm2
(54)pageeven
restore showpage
%%Page: 55 55
%%BeginPageSetup
save
%%EndPageSetup
/55 pa
[2(%ifndef MACROS_MAC )]681 code1
[2(    %define MACROS_MAC )]670 code0
[2(    ; now define some macros )]659 code0
[2(%endif)]648 code2
[(then including the file more than once will not cause errors, because the second time the file is)]631 norm1
[(included nothing will happen because the macro )2(MACROS_MAC)0( will already be defined.)]620 norm2
[(You can force a file to be included even if there is no )2(%include)0( directive that explicitly includes)]603 norm1
[(it, by using the )2(-p)0( option on the NASM command line \(see ){/section-2.1.11 xl}(section 2.1.11){el}(\).)]592 norm2
[{/section-4.7 xa}(The )(Context Stack)](4.7)572 head3
[(Having labels that are local to a macro definition is sometimes not quite powerful enough:)]555 norm1
[(sometimes you want to be able to share labels between several macro calls. An example might be a)]544 norm0
[2(REPEAT)0( ... )2(UNTIL)0( loop, in which the expansion of the )2(REPEAT)0( macro would need to be able to)]533 norm0
[(refer to a label which the )2(UNTIL)0( macro had defined. However, for such a macro you would also)]522 norm0
[(want to be able to nest these loops.)]511 norm2
[(NASM provides this level of power by means of a )1(context stack)0(. The preprocessor maintains a stack)]494 norm1
[(of )1(contexts)0(, each of which is characterised by a name. You add a new context to the stack using the)]483 norm0
[2(%push)0( directive, and remove one using )2(%pop)0(. You can define labels that are local to a particular)]472 norm0
[(context on the stack.)]461 norm2
[{/section-4.7.1 xa}2(%push)0( and )2(%pop)0(: )(Creating and Removing Contexts)](4.7.1)443 subh3
[(The )2(%push)0( directive is used to create a new context and place it on the top of the context stack.)]426 norm1
[2(%push)0( requires one argument, which is the name of the context. For example:)]415 norm2
[2(%push    foobar)]398 code3
[(This pushes a new context called )2(foobar)0( on the stack. You can have several contexts on the stack)]381 norm1
[(with the same name: they can still be distinguished.)]370 norm2
[(The directive )2(%pop)0(, requiring no arguments, removes the top context from the context stack and)]353 norm1
[(destroys it, along with any labels associated with it.)]342 norm2
[{/section-4.7.2 xa}(Context-Local Labels)](4.7.2)324 subh3
[(Just as the usage )2(%%foo)0( defines a label which is local to the particular macro call in which it is)]307 norm1
[(used, the usage )2(%$foo)0( is used to define a label which is local to the context on the top of the)]296 norm0
[(context stack. So the )2(REPEAT)0( and )2(UNTIL)0( example given above could be implemented by means of:)]285 norm2
[2(%macro repeat 0 )]268 code1
[2()]257 code0
[2(    %push   repeat )]246 code0
[2(    %$begin: )]235 code0
[2()]224 code0
[2(%endmacro )]213 code0
[2()]202 code0
[2(%macro until 1 )]191 code0
[2()]180 code0
[2(        j%-1    %$begin )]169 code0
[2(    %pop )]158 code0
[2()]147 code0
[2(%endmacro)]136 code2
[(and invoked by means of, for example,)]119 norm3
(55)pageodd
restore showpage
%%Page: 56 56
%%BeginPageSetup
save
%%EndPageSetup
/56 pa
[2(        mov     cx,string )]681 code1
[2(        repeat )]670 code0
[2(        add     cx,3 )]659 code0
[2(        scasb )]648 code0
[2(        until   e)]637 code2
[(which would scan every fourth byte of a string in search of the byte in )2(AL)0(.)]620 norm3
[(If you need to define, or access, labels local to the context )1(below)0( the top one on the stack, you can)]603 norm1
[(use )2(%$$foo)0(, or )2(%$$$foo)0( for the context below that, and so on.)]592 norm2
[{/section-4.7.3 xa}(Context-Local Single-Line Macros)](4.7.3)574 subh3
[(NASM also allows you to define single-line macros which are local to a particular context, in just)]557 norm1
[(the same way:)]546 norm2
[2(%define %$localmac 3)]529 code3
[(will define the single-line macro )2(%$localmac)0( to be local to the top context on the stack. Of)]512 norm1
[(course, after a subsequent )2(%push)0(, it can then still be accessed by the name )2(%$$localmac)0(.)]501 norm2
[{/section-4.7.4 xa}2(%repl)0(: )(Renaming a Context)](4.7.4)483 subh3
[(If you need to change the name of the top context on the stack \(in order, for example, to have it)]466 norm1
[(respond differently to )2(%ifctx)0(\), you can execute a )2(%pop)0( followed by a )2(%push)0(; but this will have)]455 norm0
[(the side effect of destroying all context-local labels and macros associated with the context that was)]444 norm0
[(just popped.)]433 norm2
[(NASM provides the directive )2(%repl)0(, which )1(replaces)0( a context with a different name, without)]416 norm1
[(touching the associated macros and labels. So you could replace the destructive code)]405 norm2
[2(%pop )]388 code1
[2(%push   newname)]377 code2
[(with the non-destructive version )2(%repl newname)0(.)]360 norm3
[{/section-4.7.5 xa}(Example Use of the )(Context Stack: )(Block IFs)](4.7.5)342 subh3
[(This example makes use of almost all the context-stack features, including the)]325 norm1
[(conditional-assembly construct )2(%ifctx)0(, to implement a block IF statement as a set of macros.)]314 norm2
[2(%macro if 1 )]297 code1
[2()]286 code0
[2(    %push if )]275 code0
[2(    j%-1  %$ifnot )]264 code0
[2()]253 code0
[2(%endmacro )]242 code0
[2()]231 code0
[2(%macro else 0 )]220 code0
[2()]209 code0
[2(  %ifctx if )]198 code0
[2(        %repl   else )]187 code0
[2(        jmp     %$ifend )]176 code0
[2(        %$ifnot: )]165 code0
[2(  %else )]154 code0
[2(        %error  "expected `if' before `else'" )]143 code0
[2(  %endif )]132 code0
[2()]121 code0
[2(%endmacro )]110 code0
(56)pageeven
restore showpage
%%Page: 57 57
%%BeginPageSetup
save
%%EndPageSetup
/57 pa
[2()]681 code0
[2(%macro endif 0 )]670 code0
[2()]659 code0
[2(  %ifctx if )]648 code0
[2(        %$ifnot: )]637 code0
[2(        %pop )]626 code0
[2(  %elifctx      else )]615 code0
[2(        %$ifend: )]604 code0
[2(        %pop )]593 code0
[2(  %else )]582 code0
[2(        %error  "expected `if' or `else' before `endif'" )]571 code0
[2(  %endif )]560 code0
[2()]549 code0
[2(%endmacro)]538 code2
[(This code is more robust than the )2(REPEAT)0( and )2(UNTIL)0( macros given in ){/section-4.7.2 xl}(section 4.7.2){el}(, because it)]521 norm1
[(uses conditional assembly to check that the macros are issued in the right order \(for example, not)]510 norm0
[(calling )2(endif)0( before )2(if)0(\) and issues a )2(%error)0( if they're not.)]499 norm2
[(In addition, the )2(endif)0( macro has to be able to cope with the two distinct cases of either directly)]482 norm1
[(following an )2(if)0(, or following an )2(else)0(. It achieves this, again, by using conditional assembly to do)]471 norm0
[(different things depending on whether the context on top of the stack is )2(if)0( or )2(else)0(.)]460 norm2
[(The )2(else)0( macro has to preserve the context on the stack, in order to have the )2(%$ifnot)0( referred to)]443 norm1
[(by the )2(if)0( macro be the same as the one defined by the )2(endif)0( macro, but has to change the)]432 norm0
[(context's name so that )2(endif)0( will know there was an intervening )2(else)0(. It does this by the use of)]421 norm0
[2(%repl)0(.)]410 norm2
[(A sample usage of these macros might look like:)]393 norm3
[2(        cmp     ax,bx )]376 code1
[2()]365 code0
[2(        if ae )]354 code0
[2(               cmp     bx,cx )]343 code0
[2()]332 code0
[2(               if ae )]321 code0
[2(                       mov     ax,cx )]310 code0
[2(               else )]299 code0
[2(                       mov     ax,bx )]288 code0
[2(               endif )]277 code0
[2()]266 code0
[2(        else )]255 code0
[2(               cmp     ax,cx )]244 code0
[2()]233 code0
[2(               if ae )]222 code0
[2(                       mov     ax,cx )]211 code0
[2(               endif )]200 code0
[2()]189 code0
[2(        endif)]178 code2
[(The block-)2(IF)0( macros handle nesting quite happily, by means of pushing another context,)]161 norm1
[(describing the inner )2(if)0(, on top of the one describing the outer )2(if)0(; thus )2(else)0( and )2(endif)0( always)]150 norm0
[(refer to the last unmatched )2(if)0( or )2(else)0(.)]139 norm2
(57)pageodd
restore showpage
%%Page: 58 58
%%BeginPageSetup
save
%%EndPageSetup
/58 pa
[{/section-4.8 xa}(Standard Macros)](4.8)678 head3
[(NASM defines a set of standard macros, which are already defined when it starts to process any)]661 norm1
[(source file. If you really need a program to be assembled with no pre-defined macros, you can use)]650 norm0
[(the )2(%clear)0( directive to empty the preprocessor of everything but context-local preprocessor)]639 norm0
[(variables and single-line macros.)]628 norm2
[(Most )(user-level assembler directives \(see ){/chapter-5 xl}(chapter 5){el}(\) are implemented as macros which invoke)]611 norm1
[(primitive directives; these are described in ){/chapter-5 xl}(chapter 5){el}(. The rest of the standard macro set is described)]600 norm0
[(here.)]589 norm2
[{/section-4.8.1 xa}2(__NASM_MAJOR__)0(, )2(__NASM_MINOR__)0(, )2(__NASM_SUBMINOR__)0( and)](4.8.1)571 subh1
[2(___NASM_PATCHLEVEL__)0(: )(NASM Version)]559 subh2
[(The single-line macros )2(__NASM_MAJOR__)0(, )2(__NASM_MINOR__)0(, )2(__NASM_SUBMINOR__)0( and)]542 norm1
[2(___NASM_PATCHLEVEL__)0( expand to the major, minor, subminor and patch level parts of the)]531 norm0
[(version number of NASM being used. So, under NASM 0.98.32p1 for example,)]520 norm0
[2(__NASM_MAJOR__)0( would be defined to be 0, )2(__NASM_MINOR__)0( would be defined as 98,)]509 norm0
[2(__NASM_SUBMINOR__)0( would be defined to 32, and )2(___NASM_PATCHLEVEL__)0( would be)]498 norm0
[(defined as 1.)]487 norm2
[{/section-4.8.2 xa}2(__NASM_VERSION_ID__)0(: )(NASM Version ID)](4.8.2)469 subh3
[(The single-line macro )2(__NASM_VERSION_ID__)0( expands to a dword integer representing the full)]452 norm1
[(version number of the version of nasm being used. The value is the equivalent to)]441 norm0
[2(__NASM_MAJOR__)0(, )2(__NASM_MINOR__)0(, )2(__NASM_SUBMINOR__)0( and)]430 norm0
[2(___NASM_PATCHLEVEL__)0( concatenated to produce a single doubleword. Hence, for 0.98.32p1,)]419 norm0
[(the returned number would be equivalent to:)]408 norm2
[2(        dd      0x00622001)]391 code3
[(or)]374 norm3
[2(        db      1,32,98,0)]357 code3
[(Note that the above lines are generate exactly the same code, the second line is used just to give an)]340 norm1
[(indication of the order that the separate values will be present in memory.)]329 norm2
[{/section-4.8.3 xa}2(__NASM_VER__)0(: )(NASM Version string)](4.8.3)311 subh3
[(The single-line macro )2(__NASM_VER__)0( expands to a string which defines the version number of)]294 norm1
[(nasm being used. So, under NASM 0.98.32 for example,)]283 norm2
[2(        db      __NASM_VER__)]266 code3
[(would expand to)]249 norm3
[2(        db      "0.98.32")]232 code3
[{/section-4.8.4 xa}2(__FILE__)0( and )2(__LINE__)0(: File Name and Line Number)](4.8.4)214 subh3
[(Like the C preprocessor, NASM allows the user to find out the file name and line number)]197 norm1
[(containing the current instruction. The macro )2(__FILE__)0( expands to a string constant giving the)]186 norm0
[(name of the current input file \(which may change through the course of assembly if )2(%include)]175 norm0
[(directives are used\), and )2(__LINE__)0( expands to a numeric constant giving the current line number)]164 norm0
[(in the input file.)]153 norm2
[(These macros could be used, for example, to communicate debugging information to a macro, since)]136 norm1
[(invoking )2(__LINE__)0( inside a macro definition \(either single-line or multi-line\) will return the line)]125 norm0
[(number of the macro )1(call)0(, rather than )1(definition)0(. So to determine where in a piece of code a crash is)]114 norm0
(58)pageeven
restore showpage
%%Page: 59 59
%%BeginPageSetup
save
%%EndPageSetup
/59 pa
[(occurring, for example, one could write a routine )2(stillhere)0(, which is passed a line number in)]681 norm0
[2(EAX)0( and outputs something like `line 155: still here'. You could then write a macro)]670 norm2
[2(%macro  notdeadyet 0 )]653 code1
[2()]642 code0
[2(        push    eax )]631 code0
[2(        mov     eax,__LINE__ )]620 code0
[2(        call    stillhere )]609 code0
[2(        pop     eax )]598 code0
[2()]587 code0
[2(%endmacro)]576 code2
[(and then pepper your code with calls to )2(notdeadyet)0( until you find the crash point.)]559 norm3
[{/section-4.8.5 xa}2(STRUC)0( and )2(ENDSTRUC)0(: )(Declaring Structure Data Types)](4.8.5)541 subh3
[(The core of NASM contains no intrinsic means of defining data structures; instead, the preprocessor)]524 norm1
[(is sufficiently powerful that data structures can be implemented as a set of macros. The macros)]513 norm0
[2(STRUC)0( and )2(ENDSTRUC)0( are used to define a structure data type.)]502 norm2
[2(STRUC)0( takes one parameter, which is the name of the data type. This name is defined as a symbol)]485 norm1
[(with the value zero, and also has the suffix )2(_size)0( appended to it and is then defined as an )2(EQU)]474 norm0
[(giving the size of the structure. Once )2(STRUC)0( has been issued, you are defining the structure, and)]463 norm0
[(should define fields using the )2(RESB)0( family of pseudo-instructions, and then invoke )2(ENDSTRUC)0( to)]452 norm0
[(finish the definition.)]441 norm2
[(For example, to define a structure called )2(mytype)0( containing a longword, a word, a byte and a)]424 norm1
[(string of bytes, you might code)]413 norm2
[2(struc   mytype )]396 code1
[2()]385 code0
[2(  mt_long:      resd    1 )]374 code0
[2(  mt_word:      resw    1 )]363 code0
[2(  mt_byte:      resb    1 )]352 code0
[2(  mt_str:       resb    32 )]341 code0
[2()]330 code0
[2(endstruc)]319 code2
[(The above code defines six symbols: )2(mt_long)0( as 0 \(the offset from the beginning of a )2(mytype)]302 norm1
[(structure to the longword field\), )2(mt_word)0( as 4, )2(mt_byte)0( as 6, )2(mt_str)0( as 7, )2(mytype_size)0( as)]291 norm0
[(39, and )2(mytype)0( itself as zero.)]280 norm2
[(The reason why the structure type name is defined at zero is a side effect of allowing structures to)]263 norm1
[(work with the local label mechanism: if your structure members tend to have the same names in)]252 norm0
[(more than one structure, you can define the above structure like this:)]241 norm2
[2(struc mytype )]224 code1
[2()]213 code0
[2(  .long:        resd    1 )]202 code0
[2(  .word:        resw    1 )]191 code0
[2(  .byte:        resb    1 )]180 code0
[2(  .str:         resb    32 )]169 code0
[2()]158 code0
[2(endstruc)]147 code2
[(This defines the offsets to the structure fields as )2(mytype.long)0(, )2(mytype.word)0(, )2(mytype.byte)]130 norm1
[(and )2(mytype.str)0(.)]119 norm2
(59)pageodd
restore showpage
%%Page: 60 60
%%BeginPageSetup
save
%%EndPageSetup
/60 pa
[(NASM, since it has no )1(intrinsic)0( structure support, does not support any form of period notation to)]681 norm1
[(refer to the elements of a structure once you have one \(except the above local-label notation\), so)]670 norm0
[(code such as )2(mov ax,[mystruc.mt_word])0( is not valid. )2(mt_word)0( is a constant just like any)]659 norm0
[(other constant, so the correct syntax is )2(mov ax,[mystruc+mt_word])0( or)]648 norm0
[2(mov ax,[mystruc+mytype.word])0(.)]637 norm2
[{/section-4.8.6 xa}2(ISTRUC)0(, )2(AT)0( and )2(IEND)0(: Declaring )(Instances of Structures)](4.8.6)619 subh3
[(Having defined a structure type, the next thing you typically want to do is to declare instances of)]602 norm1
[(that structure in your data segment. NASM provides an easy way to do this in the )2(ISTRUC)]591 norm0
[(mechanism. To declare a structure of type )2(mytype)0( in a program, you code something like this:)]580 norm2
[2(mystruc: )]563 code1
[2(    istruc mytype )]552 code0
[2()]541 code0
[2(        at mt_long, dd      123456 )]530 code0
[2(        at mt_word, dw      1024 )]519 code0
[2(        at mt_byte, db      'x' )]508 code0
[2(        at mt_str,  db      'hello, world', 13, 10, 0 )]497 code0
[2()]486 code0
[2(    iend)]475 code2
[(The function of the )2(AT)0( macro is to make use of the )2(TIMES)0( prefix to advance the assembly position)]458 norm1
[(to the correct point for the specified structure field, and then to declare the specified data. Therefore)]447 norm0
[(the structure fields must be declared in the same order as they were specified in the structure)]436 norm0
[(definition.)]425 norm2
[(If the data to go in a structure field requires more than one source line to specify, the remaining)]408 norm1
[(source lines can easily come after the )2(AT)0( line. For example:)]397 norm2
[2(        at mt_str,  db      123,134,145,156,167,178,189 )]380 code1
[2(                    db      190,100,0)]369 code2
[(Depending on personal taste, you can also omit the code part of the )2(AT)0( line completely, and start the)]352 norm1
[(structure field on the next line:)]341 norm2
[2(        at mt_str )]324 code1
[2(                db      'hello, world' )]313 code0
[2(                db      13,10,0)]302 code2
[{/section-4.8.7 xa}2(ALIGN)0( and )2(ALIGNB)0(: Data Alignment)](4.8.7)284 subh3
[(The )2(ALIGN)0( and )2(ALIGNB)0( macros provides a convenient way to align code or data on a word,)]267 norm1
[(longword, paragraph or other boundary. \(Some assemblers call this directive )2(EVEN)0(.\) The syntax of)]256 norm0
[(the )2(ALIGN)0( and )2(ALIGNB)0( macros is)]245 norm2
[2(        align   4               ; align on 4-byte boundary )]228 code1
[2(        align   16              ; align on 16-byte boundary )]217 code0
[2(        align   8,db 0          ; pad with 0s rather than NOPs )]206 code0
[2(        align   4,resb 1        ; align to 4 in the BSS )]195 code0
[2(        alignb  4               ; equivalent to previous line)]184 code2
[(Both macros require their first argument to be a power of two; they both compute the number of)]167 norm1
[(additional bytes required to bring the length of the current section up to a multiple of that power of)]156 norm0
[(two, and then apply the )2(TIMES)0( prefix to their second argument to perform the alignment.)]145 norm2
[(If the second argument is not specified, the default for )2(ALIGN)0( is )2(NOP)0(, and the default for )2(ALIGNB)]128 norm1
[(is )2(RESB 1)0(. So if the second argument is specified, the two macros are equivalent. Normally, you)]117 norm0
(60)pageeven
restore showpage
%%Page: 61 61
%%BeginPageSetup
save
%%EndPageSetup
/61 pa
[(can just use )2(ALIGN)0( in code and data sections and )2(ALIGNB)0( in BSS sections, and never need the)]681 norm0
[(second argument except for special purposes.)]670 norm2
[2(ALIGN)0( and )2(ALIGNB)0(, being simple macros, perform no error checking: they cannot warn you if)]653 norm1
[(their first argument fails to be a power of two, or if their second argument generates more than one)]642 norm0
[(byte of code. In each of these cases they will silently do the wrong thing.)]631 norm2
[2(ALIGNB)0( \(or )2(ALIGN)0( with a second argument of )2(RESB 1)0(\) can be used within structure definitions:)]614 norm3
[2(struc mytype2 )]597 code1
[2()]586 code0
[2(  mt_byte: )]575 code0
[2(        resb 1 )]564 code0
[2(        alignb 2 )]553 code0
[2(  mt_word: )]542 code0
[2(        resw 1 )]531 code0
[2(        alignb 4 )]520 code0
[2(  mt_long: )]509 code0
[2(        resd 1 )]498 code0
[2(  mt_str: )]487 code0
[2(        resb 32 )]476 code0
[2()]465 code0
[2(endstruc)]454 code2
[(This will ensure that the structure members are sensibly aligned relative to the base of the structure.)]437 norm3
[(A final caveat: )2(ALIGN)0( and )2(ALIGNB)0( work relative to the beginning of the )1(section)0(, not the beginning)]420 norm1
[(of the address space in the final executable. Aligning to a 16-byte boundary when the section)]409 norm0
[(you're in is only guaranteed to be aligned to a 4-byte boundary, for example, is a waste of effort.)]398 norm0
[(Again, NASM does not check that the section's alignment characteristics are sensible for the use of)]387 norm0
[2(ALIGN)0( or )2(ALIGNB)0(.)]376 norm2
[{/section-4.9 xa}(TASM Compatible Preprocessor Directives)](4.9)356 head3
[(The following preprocessor directives may only be used when TASM compatibility is turned on)]339 norm1
[(using the )2(-t)0( command line switch \(This switch is described in ){/section-2.1.17 xl}(section 2.1.17){el}(.\))]328 norm2
[2(%arg)0( \(see ){/section-4.9.1 xl}(section 4.9.1){el}(\))]311 bull3
[2(%stacksize)0( \(see ){/section-4.9.2 xl}(section 4.9.2){el}(\))]294 bull3
[2(%local)0( \(see ){/section-4.9.3 xl}(section 4.9.3){el}(\))]277 bull3
[{/section-4.9.1 xa}2(%arg)0( Directive)](4.9.1)259 subh3
[(The )2(%arg)0( directive is used to simplify the handling of parameters passed on the stack. Stack based)]242 norm1
[(parameter passing is used by many high level languages, including C, C++ and Pascal.)]231 norm2
[(While NASM comes with macros which attempt to duplicate this functionality \(see ){/section-7.4.5 xl}(section 7.4.5){el}(\),)]214 norm1
[(the syntax is not particularly convenient to use and is not TASM compatible. Here is an example)]203 norm0
[(which shows the use of )2(%arg)0( without any external macros:)]192 norm2
[2(some_function: )]175 code1
[2()]164 code0
[2(    %push     mycontext        ; save the current context )]153 code0
[2(    %stacksize large           ; tell NASM to use bp )]142 code0
[2(    %arg      i:word, j_ptr:word )]131 code0
[2()]120 code0
[2(        mov     ax,[i] )]109 code0
(61)pageodd
restore showpage
%%Page: 62 62
%%BeginPageSetup
save
%%EndPageSetup
/62 pa
[2(        mov     bx,[j_ptr] )]681 code0
[2(        add     ax,[bx] )]670 code0
[2(        ret )]659 code0
[2()]648 code0
[2(    %pop                       ; restore original context)]637 code2
[(This is similar to the procedure defined in ){/section-7.4.5 xl}(section 7.4.5){el}( and adds the value in i to the value pointed)]620 norm1
[(to by j_ptr and returns the sum in the ax register. See ){/section-4.7.1 xl}(section 4.7.1){el}( for an explanation of )2(push)0( and)]609 norm0
[2(pop)0( and the use of context stacks.)]598 norm2
[{/section-4.9.2 xa}2(%stacksize)0( Directive)](4.9.2)580 subh3
[(The )2(%stacksize)0( directive is used in conjunction with the )2(%arg)0( \(see ){/section-4.9.1 xl}(section 4.9.1){el}(\) and the)]563 norm1
[2(%local)0( \(see ){/section-4.9.3 xl}(section 4.9.3){el}(\) directives. It tells NASM the default size to use for subsequent )2(%arg)]552 norm0
[(and )2(%local)0( directives. The )2(%stacksize)0( directive takes one required argument which is one of)]541 norm0
[2(flat)0(, )2(large)0( or )2(small)0(.)]530 norm2
[2(%stacksize flat)]513 code3
[(This form causes NASM to use stack-based parameter addressing relative to )2(ebp)0( and it assumes)]496 norm1
[(that a near form of call was used to get to this label \(i.e. that )2(eip)0( is on the stack\).)]485 norm2
[2(%stacksize large)]468 code3
[(This form uses )2(bp)0( to do stack-based parameter addressing and assumes that a far form of call was)]451 norm1
[(used to get to this address \(i.e. that )2(ip)0( and )2(cs)0( are on the stack\).)]440 norm2
[2(%stacksize small)]423 code3
[(This form also uses )2(bp)0( to address stack parameters, but it is different from )2(large)0( because it also)]406 norm1
[(assumes that the old value of bp is pushed onto the stack \(i.e. it expects an )2(ENTER)0( instruction\). In)]395 norm0
[(other words, it expects that )2(bp)0(, )2(ip)0( and )2(cs)0( are on the top of the stack, underneath any local space)]384 norm0
[(which may have been allocated by )2(ENTER)0(. This form is probably most useful when used in)]373 norm0
[(combination with the )2(%local)0( directive \(see ){/section-4.9.3 xl}(section 4.9.3){el}(\).)]362 norm2
[{/section-4.9.3 xa}2(%local)0( Directive)](4.9.3)344 subh3
[(The )2(%local)0( directive is used to simplify the use of local temporary stack variables allocated in a)]327 norm1
[(stack frame. Automatic local variables in C are an example of this kind of variable. The )2(%local)]316 norm0
[(directive is most useful when used with the )2(%stacksize)0( \(see ){/section-4.9.2 xl}(section 4.9.2){el}( and is also compatible)]305 norm0
[(with the )2(%arg)0( directive \(see ){/section-4.9.1 xl}(section 4.9.1){el}(\). It allows simplified reference to variables on the stack)]294 norm0
[(which have been allocated typically by using the )2(ENTER)0( instruction \(see ){/section-B.4.65 xl}(section B.4.65){el}( for a)]283 norm0
[(description of that instruction\). An example of its use is the following:)]272 norm2
[2(silly_swap: )]255 code1
[2()]244 code0
[2(    %push mycontext             ; save the current context )]233 code0
[2(    %stacksize small            ; tell NASM to use bp )]222 code0
[2(    %assign %$localsize 0       ; see text for explanation )]211 code0
[2(    %local old_ax:word, old_dx:word )]200 code0
[2()]189 code0
[2(        enter   %$localsize,0   ; see text for explanation )]178 code0
[2(        mov     [old_ax],ax     ; swap ax & bx )]167 code0
[2(        mov     [old_dx],dx     ; and swap dx & cx )]156 code0
[2(        mov     ax,bx )]145 code0
[2(        mov     dx,cx )]134 code0
[2(        mov     bx,[old_ax] )]123 code0
[2(        mov     cx,[old_dx] )]112 code0
[2(        leave                   ; restore old bp )]101 code0
(62)pageeven
restore showpage
%%Page: 63 63
%%BeginPageSetup
save
%%EndPageSetup
/63 pa
[2(        ret                     ; )]681 code0
[2()]670 code0
[2(    %pop                        ; restore original context)]659 code2
[(The )2(%$localsize)0( variable is used internally by the )2(%local)0( directive and )1(must)0( be defined)]642 norm1
[(within the current context before the )2(%local)0( directive may be used. Failure to do so will result in)]631 norm0
[(one expression syntax error for each )2(%local)0( variable declared. It then may be used in the)]620 norm0
[(construction of an appropriately sized ENTER instruction as shown in the example.)]609 norm2
[{/section-4.10 xa}(Other Preprocessor Directives)](4.10)589 head3
[(NASM also has preprocessor directives which allow access to information from external sources.)]572 norm1
[(Currently they include:)]561 norm2
[(The following preprocessor directive is supported to allow NASM to correctly handle output of the)]544 norm1
[(cpp C language preprocessor.)]533 norm2
[2(%line)0( enables NAsM to correctly handle the output of the cpp C language preprocessor \(see)]516 bull1
[{/section-4.10.1 xl}(section 4.10.1){el}(\).)]505 bull2
[2(%!)0( enables NASM to read in the value of an environment variable, which can then be used in)]488 bull1
[(your program \(see ){/section-4.10.2 xl}(section 4.10.2){el}(\).)]477 bull2
[{/section-4.10.1 xa}2(%line)0( Directive)](4.10.1)459 subh3
[(The )2(%line)0( directive is used to notify NASM that the input line corresponds to a specific line)]442 norm1
[(number in another file. Typically this other file would be an original source file, with the current)]431 norm0
[(NASM input being the output of a pre-processor. The )2(%line)0( directive allows NASM to output)]420 norm0
[(messages which indicate the line number of the original source file, instead of the file that is being)]409 norm0
[(read by NASM.)]398 norm2
[(This preprocessor directive is not generally of use to programmers, by may be of interest to)]381 norm1
[(preprocessor authors. The usage of the )2(%line)0( preprocessor directive is as follows:)]370 norm2
[2(%line nnn[+mmm] [filename])]353 code3
[(In this directive, )2(nnn)0( indentifies the line of the original source file which this line corresponds to.)]336 norm1
[2(mmm)0( is an optional parameter which specifies a line increment value; each line of the input file read)]325 norm0
[(in is considered to correspond to )2(mmm)0( lines of the original source file. Finally, )2(filename)0( is an)]314 norm0
[(optional parameter which specifies the file name of the original source file.)]303 norm2
[(After reading a )2(%line)0( preprocessor directive, NASM will report all file name and line numbers)]286 norm1
[(relative to the values specified therein.)]275 norm2
[{/section-4.10.2 xa}2(%!<env>)0(: Read an environment variable.)](4.10.2)257 subh3
[(The )2(%!<env>)0( directive makes it possible to read the value of an environment variable at assembly)]240 norm1
[(time. This could, for example, be used to store the contents of an environment variable into a string,)]229 norm0
[(which could be used at some other point in your code.)]218 norm2
[(For example, suppose that you have an environment variable )2(FOO)0(, and you want the contents of)]201 norm1
[2(FOO)0( to be embedded in your program. You could do that as follows:)]190 norm2
[2(%define FOO    %!FOO )]173 code1
[2(%define quote   ' )]162 code0
[2()]151 code0
[2(tmpstr  db      quote FOO quote)]140 code2
[(At the time of writing, this will generate an "unterminated string" warning at the time of defining)]123 norm1
[("quote", and it will add a space before and after the string that is read in. I was unable to find a)]112 norm0
[(simple workaround \(although a workaround can be created using a multi-line macro\), so I believe)]101 norm0
(63)pageodd
restore showpage
%%Page: 64 64
%%BeginPageSetup
save
%%EndPageSetup
/64 pa
[(that you will need to either learn how to create more complex macros, or allow for the extra spaces)]681 norm0
[(if you make use of this feature in that way.)]670 norm2
(64)pageeven
restore showpage
%%Page: 65 65
%%BeginPageSetup
save
%%EndPageSetup
/65 pa
[{/chapter-5 xa}(Chapter 5: )(Assembler Directives)]644 chap3
[(NASM, though it attempts to avoid the bureaucracy of assemblers like MASM and TASM, is)]609 norm1
[(nevertheless forced to support a )1(few)0( directives. These are described in this chapter.)]598 norm2
[(NASM's directives come in two types: )1(user-level)0( directives and )1(primitive)0( directives. Typically,)]581 norm1
[(each directive has a user-level form and a primitive form. In almost all cases, we recommend that)]570 norm0
[(users use the user-level forms of the directives, which are implemented as macros which call the)]559 norm0
[(primitive forms.)]548 norm2
[(Primitive directives are enclosed in square brackets; user-level directives are not.)]531 norm3
[(In addition to the universal directives described in this chapter, each object file format can)]514 norm1
[(optionally supply extra directives in order to control particular features of that file format. These)]503 norm0
[1(format-specific)0( directives are documented along with the formats that implement them, in ){/chapter-6 xl}(chapter 6){el}(.)]492 norm2
[{/section-5.1 xa}2(BITS)0(: Specifying Target )(Processor Mode)](5.1)472 head3
[(The )2(BITS)0( directive specifies whether NASM should generate code )(designed to run on a processor)]455 norm1
[(operating in 16-bit mode, or code designed to run on a processor operating in 32-bit mode. The)]444 norm0
[(syntax is )2(BITS 16)0( or )2(BITS 32)0(.)]433 norm2
[(In most cases, you should not need to use )2(BITS)0( explicitly. The )2(aout)0(, )2(coff)0(, )2(elf)0( and )2(win32)]416 norm1
[(object formats, which are designed for use in 32-bit operating systems, all cause NASM to select)]405 norm0
[(32-bit mode by default. The )2(obj)0( object format allows you to specify each segment you define as)]394 norm0
[(either )2(USE16)0( or )2(USE32)0(, and NASM will set its operating mode accordingly, so the use of the)]383 norm0
[2(BITS)0( directive is once again unnecessary.)]372 norm2
[(The most likely reason for using the )2(BITS)0( directive is to write 32-bit code in a flat binary file; this)]355 norm1
[(is because the )2(bin)0( output format defaults to 16-bit mode in anticipation of it being used most)]344 norm0
[(frequently to write DOS )2(.COM)0( programs, DOS )2(.SYS)0( device drivers and boot loader software.)]333 norm2
[(You do )1(not)0( need to specify )2(BITS 32)0( merely in order to use 32-bit instructions in a 16-bit DOS)]316 norm1
[(program; if you do, the assembler will generate incorrect code because it will be writing code)]305 norm0
[(targeted at a 32-bit platform, to be run on a 16-bit one.)]294 norm2
[(When NASM is in )2(BITS 16)0( state, instructions which use 32-bit data are prefixed with an 0x66)]277 norm1
[(byte, and those referring to 32-bit addresses have an 0x67 prefix. In )2(BITS 32)0( state, the reverse is)]266 norm0
[(true: 32-bit instructions require no prefixes, whereas instructions using 16-bit data need an 0x66)]255 norm0
[(and those working on 16-bit addresses need an 0x67.)]244 norm2
[(The )2(BITS)0( directive has an exactly equivalent primitive form, )2([BITS 16])0( and )2([BITS 32])0(. The)]227 norm1
[(user-level form is a macro which has no function other than to call the primitive form.)]216 norm2
[(Note that the space is neccessary, )2(BITS32)0( will )1(not)0( work!)]199 norm3
[{/section-5.1.1 xa}2(USE16)0( & )2(USE32)0(: Aliases for BITS)](5.1.1)181 subh3
[(The `)2(USE16)0(' and `)2(USE32)0(' directives can be used in place of `)2(BITS 16)0(' and `)2(BITS 32)0(', for)]164 norm1
[(compatibility with other assemblers.)]153 norm2
[{/section-5.2 xa}2(SECTION)0( or )2(SEGMENT)0(: Changing and )(Defining Sections)](5.2)133 head3
[(The )2(SECTION)0( directive \()2(SEGMENT)0( is an exactly equivalent synonym\) changes which section of)]116 norm1
[(the output file the code you write will be assembled into. In some object file formats, the number)]105 norm0
(65)pageodd
restore showpage
%%Page: 66 66
%%BeginPageSetup
save
%%EndPageSetup
/66 pa
[(and names of sections are fixed; in others, the user may make up as many as they wish. Hence)]681 norm0
[2(SECTION)0( may sometimes give an error message, or may define a new section, if you try to switch)]670 norm0
[(to a section that does not \(yet\) exist.)]659 norm2
[(The Unix object formats, and the )2(bin)0( object format \(but see ){/section-6.1.3 xl}(section 6.1.3){el}(, all support the)]642 norm1
[(standardised section names )2(.text)0(, )2(.data)0( and )2(.bss)0( for the code, data and uninitialised-data)]631 norm0
[(sections. The )2(obj)0( format, by contrast, does not recognise these section names as being special, and)]620 norm0
[(indeed will strip off the leading period of any section name that has one.)]609 norm2
[{/section-5.2.1 xa}(The )2(__SECT__)0( Macro)](5.2.1)591 subh3
[(The )2(SECTION)0( directive is unusual in that its user-level form functions differently from its)]574 norm1
[(primitive form. The primitive form, )2([SECTION xyz])0(, simply switches the current target section)]563 norm0
[(to the one given. The user-level form, )2(SECTION xyz)0(, however, first defines the single-line)]552 norm0
[(macro )2(__SECT__)0( to be the primitive )2([SECTION])0( directive which it is about to issue, and then)]541 norm0
[(issues it. So the user-level directive)]530 norm2
[2(        SECTION .text)]513 code3
[(expands to the two lines)]496 norm3
[2(%define __SECT__        [SECTION .text] )]479 code1
[2(        [SECTION .text])]468 code2
[(Users may find it useful to make use of this in their own macros. For example, the )2(writefile)]451 norm1
[(macro defined in ){/section-4.3.3 xl}(section 4.3.3){el}( can be usefully rewritten in the following more sophisticated form:)]440 norm2
[2(%macro  writefile 2+ )]423 code1
[2()]412 code0
[2(        [section .data] )]401 code0
[2()]390 code0
[2(  %%str:        db      %2 )]379 code0
[2(  %%endstr: )]368 code0
[2()]357 code0
[2(        __SECT__ )]346 code0
[2()]335 code0
[2(        mov     dx,%%str )]324 code0
[2(        mov     cx,%%endstr-%%str )]313 code0
[2(        mov     bx,%1 )]302 code0
[2(        mov     ah,0x40 )]291 code0
[2(        int     0x21 )]280 code0
[2()]269 code0
[2(%endmacro)]258 code2
[(This form of the macro, once passed a string to output, first switches temporarily to the data section)]241 norm1
[(of the file, using the primitive form of the )2(SECTION)0( directive so as not to modify )2(__SECT__)0(. It)]230 norm0
[(then declares its string in the data section, and then invokes )2(__SECT__)0( to switch back to)]219 norm0
[1(whichever)0( section the user was previously working in. It thus avoids the need, in the previous)]208 norm0
[(version of the macro, to include a )2(JMP)0( instruction to jump over the data, and also does not fail if, in)]197 norm0
[(a complicated )2(OBJ)0( format module, the user could potentially be assembling the code in any of)]186 norm0
[(several separate code sections.)]175 norm2
[{/section-5.3 xa}2(ABSOLUTE)0(: Defining Absolute Labels)](5.3)155 head3
[(The )2(ABSOLUTE)0( directive can be thought of as an alternative form of )2(SECTION)0(: it causes the)]138 norm1
[(subsequent code to be directed at no physical section, but at the hypothetical section starting at the)]127 norm0
[(given absolute address. The only instructions you can use in this mode are the )2(RESB)0( family.)]116 norm2
(66)pageeven
restore showpage
%%Page: 67 67
%%BeginPageSetup
save
%%EndPageSetup
/67 pa
[2(ABSOLUTE)0( is used as follows:)]681 norm3
[2(absolute 0x1A )]664 code1
[2()]653 code0
[2(    kbuf_chr    resw    1 )]642 code0
[2(    kbuf_free   resw    1 )]631 code0
[2(    kbuf        resw    16)]620 code2
[(This example describes a section of the PC BIOS data area, at segment address 0x40: the above)]603 norm1
[(code defines )2(kbuf_chr)0( to be 0x1A, )2(kbuf_free)0( to be 0x1C, and )2(kbuf)0( to be 0x1E.)]592 norm2
[(The user-level form of )2(ABSOLUTE)0(, like that of )2(SECTION)0(, redefines the )2(__SECT__)0( macro when)]575 norm1
[(it is invoked.)]564 norm2
[2(STRUC)0( and )2(ENDSTRUC)0( are defined as macros which use )2(ABSOLUTE)0( \(and also )2(__SECT__)0(\).)]547 norm3
[2(ABSOLUTE)0( doesn't have to take an absolute constant as an argument: it can take an expression)]530 norm1
[(\(actually, a )(critical expression: see ){/section-3.8 xl}(section 3.8){el}(\) and it can be a value in a segment. For example, a)]519 norm0
[(TSR can re-use its setup code as run-time BSS like this:)]508 norm2
[2(        org     100h               ; it's a .COM program )]491 code1
[2()]480 code0
[2(        jmp     setup              ; setup code comes last )]469 code0
[2()]458 code0
[2(        ; the resident part of the TSR goes here )]447 code0
[2(setup: )]436 code0
[2(        ; now write the code that installs the TSR here )]425 code0
[2()]414 code0
[2(absolute setup )]403 code0
[2()]392 code0
[2(runtimevar1     resw    1 )]381 code0
[2(runtimevar2     resd    20 )]370 code0
[2()]359 code0
[2(tsr_end:)]348 code2
[(This defines some variables `on top of' the setup code, so that after the setup has finished running,)]331 norm1
[(the space it took up can be re-used as data storage for the running TSR. The symbol `tsr_end' can)]320 norm0
[(be used to calculate the total size of the part of the TSR that needs to be made resident.)]309 norm2
[{/section-5.4 xa}2(EXTERN)0(: )(Importing Symbols from Other Modules)](5.4)289 head3
[2(EXTERN)0( is similar to the MASM directive )2(EXTRN)0( and the C keyword )2(extern)0(: it is used to)]272 norm1
[(declare a symbol which is not defined anywhere in the module being assembled, but is assumed to)]261 norm0
[(be defined in some other module and needs to be referred to by this one. Not every object-file)]250 norm0
[(format can support external variables: the )2(bin)0( format cannot.)]239 norm2
[(The )2(EXTERN)0( directive takes as many arguments as you like. Each argument is the name of a)]222 norm1
[(symbol:)]211 norm2
[2(extern  _printf )]194 code1
[2(extern  _sscanf,_fscanf)]183 code2
[(Some object-file formats provide extra features to the )2(EXTERN)0( directive. In all cases, the extra)]166 norm1
[(features are used by suffixing a colon to the symbol name followed by object-format specific text.)]155 norm0
[(For example, the )2(obj)0( format allows you to declare that the default segment base of an external)]144 norm0
[(should be the group )2(dgroup)0( by means of the directive)]133 norm2
[2(extern  _variable:wrt dgroup)]116 code3
(67)pageodd
restore showpage
%%Page: 68 68
%%BeginPageSetup
save
%%EndPageSetup
/68 pa
[(The primitive form of )2(EXTERN)0( differs from the user-level form only in that it can take only one)]681 norm1
[(argument at a time: the support for multiple arguments is implemented at the preprocessor level.)]670 norm2
[(You can declare the same variable as )2(EXTERN)0( more than once: NASM will quietly ignore the)]653 norm1
[(second and later redeclarations. You can't declare a variable as )2(EXTERN)0( as well as something else,)]642 norm0
[(though.)]631 norm2
[{/section-5.5 xa}2(GLOBAL)0(: )(Exporting Symbols to Other Modules)](5.5)611 head3
[2(GLOBAL)0( is the other end of )2(EXTERN)0(: if one module declares a symbol as )2(EXTERN)0( and refers to it,)]594 norm1
[(then in order to prevent linker errors, some other module must actually )1(define)0( the symbol and)]583 norm0
[(declare it as )2(GLOBAL)0(. Some assemblers use the name )2(PUBLIC)0( for this purpose.)]572 norm2
[(The )2(GLOBAL)0( directive applying to a symbol must appear )1(before)0( the definition of the symbol.)]555 norm3
[2(GLOBAL)0( uses the same syntax as )2(EXTERN)0(, except that it must refer to symbols which )1(are)0( defined)]538 norm1
[(in the same module as the )2(GLOBAL)0( directive. For example:)]527 norm2
[2(global _main )]510 code1
[2(_main: )]499 code0
[2(        ; some code)]488 code2
[2(GLOBAL)0(, like )2(EXTERN)0(, allows object formats to define private extensions by means of a colon. The)]471 norm1
[2(elf)0( object format, for example, lets you specify whether global data items are functions or data:)]460 norm2
[2(global  hashlookup:function, hashtable:data)]443 code3
[(Like )2(EXTERN)0(, the primitive form of )2(GLOBAL)0( differs from the user-level form only in that it can)]426 norm1
[(take only one argument at a time.)]415 norm2
[{/section-5.6 xa}2(COMMON)0(: Defining Common Data Areas)](5.6)395 head3
[(The )2(COMMON)0( directive is used to declare )1(common variables)0(. A common variable is much like a)]378 norm1
[(global variable declared in the uninitialised data section, so that)]367 norm2
[2(common  intvar  4)]350 code3
[(is similar in function to)]333 norm3
[2(global  intvar )]316 code1
[2(section .bss )]305 code0
[2()]294 code0
[2(intvar  resd    1)]283 code2
[(The difference is that if more than one module defines the same common variable, then at link time)]266 norm1
[(those variables will be )1(merged)0(, and references to )2(intvar)0( in all modules will point at the same)]255 norm0
[(piece of memory.)]244 norm2
[(Like )2(GLOBAL)0( and )2(EXTERN)0(, )2(COMMON)0( supports object-format specific extensions. For example, the)]227 norm1
[2(obj)0( format allows common variables to be NEAR or FAR, and the )2(elf)0( format allows you to)]216 norm0
[(specify the alignment requirements of a common variable:)]205 norm2
[2(common  commvar  4:near  ; works in OBJ )]188 code1
[2(common  intarray 100:4   ; works in ELF: 4 byte aligned)]177 code2
[(Once again, like )2(EXTERN)0( and )2(GLOBAL)0(, the primitive form of )2(COMMON)0( differs from the user-level)]160 norm1
[(form only in that it can take only one argument at a time.)]149 norm2
[{/section-5.7 xa}2(CPU)0(: Defining CPU Dependencies)](5.7)129 head3
[(The )2(CPU)0( directive restricts assembly to those instructions which are available on the specified CPU.)]112 norm3
(68)pageeven
restore showpage
%%Page: 69 69
%%BeginPageSetup
save
%%EndPageSetup
/69 pa
[(Options are:)]681 norm3
[2(CPU 8086)0( Assemble only 8086 instruction set)]664 bull3
[2(CPU 186)0( Assemble instructions up to the 80186 instruction set)]647 bull3
[2(CPU 286)0( Assemble instructions up to the 286 instruction set)]630 bull3
[2(CPU 386)0( Assemble instructions up to the 386 instruction set)]613 bull3
[2(CPU 486)0( 486 instruction set)]596 bull3
[2(CPU 586)0( Pentium instruction set)]579 bull3
[2(CPU PENTIUM)0( Same as 586)]562 bull3
[2(CPU 686)0( P6 instruction set)]545 bull3
[2(CPU PPRO)0( Same as 686)]528 bull3
[2(CPU P2)0( Same as 686)]511 bull3
[2(CPU P3)0( Pentium III \(Katmai\) instruction sets)]494 bull3
[2(CPU KATMAI)0( Same as P3)]477 bull3
[2(CPU P4)0( Pentium 4 \(Willamette\) instruction set)]460 bull3
[2(CPU WILLAMETTE)0( Same as P4)]443 bull3
[2(CPU PRESCOTT)0( Prescott instruction set)]426 bull3
[2(CPU IA64)0( IA64 CPU \(in x86 mode\) instruction set)]409 bull3
[(All options are case insensitive. All instructions will be selected only if they apply to the selected)]392 norm1
[(CPU or lower. By default, all instructions are available.)]381 norm2
(69)pageodd
restore showpage
%%Page: 70 70
%%BeginPageSetup
save
%%EndPageSetup
/70 pa
[{/chapter-6 xa}(Chapter 6: )(Output Formats)]644 chap3
[(NASM is a portable assembler, designed to be able to compile on any ANSI C-supporting platform)]609 norm1
[(and produce output to run on a variety of Intel x86 operating systems. For this reason, it has a large)]598 norm0
[(number of available output formats, selected using the )2(-f)0( option on the NASM )(command line.)]587 norm0
[(Each of these formats, along with its extensions to the base NASM syntax, is detailed in this chapter.)]576 norm2
[(As stated in ){/section-2.1.1 xl}(section 2.1.1){el}(, NASM chooses a )(default name for your output file based on the input file)]559 norm1
[(name and the chosen output format. This will be generated by removing the )(extension \()2(.asm)0(, )2(.s)0(,)]548 norm0
[(or whatever you like to use\) from the input file name, and substituting an extension defined by the)]537 norm0
[(output format. The extensions are given with each format below.)]526 norm2
[{/section-6.1 xa}2(bin)0(: )(Flat-Form Binary)( Output)](6.1)506 head3
[(The )2(bin)0( format does not produce object files: it generates nothing in the output file except the code)]489 norm1
[(you wrote. Such `pure binary' files are used by )(MS-DOS: )2(.COM)0( executables and )2(.SYS)0( device)]478 norm0
[(drivers are pure binary files. Pure binary output is also useful for )(operating system and )(boot loader)]467 norm0
[(development.)]456 norm2
[(The )2(bin)0( format supports )(multiple section names. For details of how nasm handles sections in the)]439 norm1
[2(bin)0( format, see ){/section-6.1.3 xl}(section 6.1.3){el}(.)]428 norm2
[(Using the )2(bin)0( format puts NASM by default into 16-bit mode \(see ){/section-5.1 xl}(section 5.1){el}(\). In order to use)]411 norm1
[2(bin)0( to write 32-bit code such as an OS kernel, you need to explicitly issue the )2(BITS 32)0( directive.)]400 norm2
[2(bin)0( has no default output file name extension: instead, it leaves your file name as it is once the)]383 norm1
[(original extension has been removed. Thus, the default is for NASM to assemble )2(binprog.asm)]372 norm0
[(into a binary file called )2(binprog)0(.)]361 norm2
[{/section-6.1.1 xa}2(ORG)0(: Binary File )(Program Origin)](6.1.1)343 subh3
[(The )2(bin)0( format provides an additional directive to the list given in ){/chapter-5 xl}(chapter 5){el}(: )2(ORG)0(. The function of)]326 norm1
[(the )2(ORG)0( directive is to specify the origin address which NASM will assume the program begins at)]315 norm0
[(when it is loaded into memory.)]304 norm2
[(For example, the following code will generate the longword )2(0x00000104)0(:)]287 norm3
[2(        org     0x100 )]270 code1
[2(        dd      label )]259 code0
[2(label:)]248 code2
[(Unlike the )2(ORG)0( directive provided by MASM-compatible assemblers, which allows you to jump)]231 norm1
[(around in the object file and overwrite code you have already generated, NASM's )2(ORG)0( does exactly)]220 norm0
[(what the directive says: )1(origin)0(. Its sole function is to specify one offset which is added to all internal)]209 norm0
[(address references within the section; it does not permit any of the trickery that MASM's version)]198 norm0
[(does. See ){/section-10.1.3 xl}(section 10.1.3){el}( for further comments.)]187 norm2
[{/section-6.1.2 xa}2(bin)0( Extensions to the )2(SECTION)0( Directive)](6.1.2)169 subh3
[(The )2(bin)0( output format extends the )2(SECTION)0( \(or )2(SEGMENT)0(\) directive to allow you to specify the)]152 norm1
[(alignment requirements of segments. This is done by appending the )2(ALIGN)0( qualifier to the end of)]141 norm0
[(the section-definition line. For example,)]130 norm2
[2(section .data   align=16)]113 code3
(70)pageeven
restore showpage
%%Page: 71 71
%%BeginPageSetup
save
%%EndPageSetup
/71 pa
[(switches to the section )2(.data)0( and also specifies that it must be aligned on a 16-byte boundary.)]681 norm3
[(The parameter to )2(ALIGN)0( specifies how many low bits of the section start address must be forced to)]664 norm1
[(zero. The alignment value given may be any power of two.)]653 norm2
[{/section-6.1.3 xa}2(Multisection)0( support for the BIN format.)](6.1.3)635 subh3
[(The )2(bin)0( format allows the use of multiple sections, of arbitrary names, besides the "known")]618 norm1
[2(.text)0(, )2(.data)0(, and )2(.bss)0( names.)]607 norm2
[(Sections may be designated )2(progbits)0( or )2(nobits)0(. Default is )2(progbits)0( \(except )2(.bss)0(,)]590 bull1
[(which defaults to )2(nobits)0(, of course\).)]579 bull2
[(Sections can be aligned at a specified boundary following the previous section with )2(align=)0(, or)]562 bull1
[(at an arbitrary byte-granular position with )2(start=)0(.)]551 bull2
[(Sections can be given a virtual start address, which will be used for the calculation of all memory)]534 bull1
[(references within that section with )2(vstart=)0(.)]523 bull2
[(Sections can be ordered using )2(follows=<section>)0( or )2(vfollows=<section>)0( as an)]506 bull1
[(alternative to specifying an explicit start address.)]495 bull2
[(Arguments to )2(org)0(, )2(start)0(, )2(vstart)0(, and )2(align=)0( are critical expressions. See ){/section-3.8 xl}(section 3.8){el}(. E.g.)]478 bull1
[2(align=\(1 << ALIGN_SHIFT\))0( \226 )2(ALIGN_SHIFT)0( must be defined before it is used here.)]467 bull2
[(Any code which comes before an explicit )2(SECTION)0( directive is directed by default into the)]450 bull1
[2(.text)0( section.)]439 bull2
[(If an )2(ORG)0( statement is not given, )2(ORG 0)0( is used by default.)]422 bull3
[(The )2(.bss)0( section will be placed after the last )2(progbits)0( section, unless )2(start=)0(, )2(vstart=)0(,)]405 bull1
[2(follows=)0(, or )2(vfollows=)0( has been specified.)]394 bull2
[(All sections are aligned on dword boundaries, unless a different alignment has been specified.)]377 bull3
[(Sections may not overlap.)]360 bull3
[(Nasm creates the )2(section.<secname>.start)0( for each section, which may be used in your)]343 bull1
[(code.)]332 bull2
[{/section-6.1.4 xa}(Map files)](6.1.4)314 subh3
[(Map files can be generated in )2(-f bin)0( format by means of the )2([map])0( option. Map types of )2(all)]297 norm1
[(\(default\), )2(brief)0(, )2(sections)0(, )2(segments)0(, or )2(symbols)0( may be specified. Output may be)]286 norm0
[(directed to )2(stdout)0( \(default\), )2(stderr)0(, or a specified file. E.g.)]275 norm0
[2([map symbols myfile.map])0(. No "user form" exists, the square brackets must be used.)]264 norm2
[{/section-6.2 xa}2(obj)0(: )(Microsoft OMF)( Object Files)](6.2)244 head3
[(The )2(obj)0( file format \(NASM calls it )2(obj)0( rather than )2(omf)0( for historical reasons\) is the one produced)]227 norm1
[(by )(MASM and )(TASM, which is typically fed to 16-bit DOS linkers to produce )2(.EXE)0( files. It is)]216 norm0
[(also the format used by )(OS/2.)]205 norm2
[2(obj)0( provides a default output file-name extension of )2(.obj)0(.)]188 norm3
[2(obj)0( is not exclusively a 16-bit format, though: NASM has full support for the 32-bit extensions to)]171 norm1
[(the format. In particular, 32-bit )2(obj)0( format files are used by )(Borland's Win32 compilers, instead of)]160 norm0
[(using Microsoft's newer )2(win32)0( object file format.)]149 norm2
[(The )2(obj)0( format does not define any special segment names: you can call your segments anything)]132 norm1
[(you like. Typical names for segments in )2(obj)0( format files are )2(CODE)0(, )2(DATA)0( and )2(BSS)0(.)]121 norm2
(71)pageodd
restore showpage
%%Page: 72 72
%%BeginPageSetup
save
%%EndPageSetup
/72 pa
[(If your source file contains code before specifying an explicit )2(SEGMENT)0( directive, then NASM will)]681 norm1
[(invent its own segment called )2(__NASMDEFSEG)0( for you.)]670 norm2
[(When you define a segment in an )2(obj)0( file, NASM defines the segment name as a symbol as well,)]653 norm1
[(so that you can access the segment address of the segment. So, for example:)]642 norm2
[2(segment data )]625 code1
[2()]614 code0
[2(dvar:   dw      1234 )]603 code0
[2()]592 code0
[2(segment code )]581 code0
[2()]570 code0
[2(function: )]559 code0
[2(        mov     ax,data         ; get segment address of data )]548 code0
[2(        mov     ds,ax           ; and move it into DS )]537 code0
[2(        inc     word [dvar]     ; now this reference will work )]526 code0
[2(        ret)]515 code2
[(The )2(obj)0( format also enables the use of the )2(SEG)0( and )2(WRT)0( operators, so that you can write code)]498 norm1
[(which does things like)]487 norm2
[2(extern  foo )]470 code1
[2()]459 code0
[2(      mov   ax,seg foo            ; get preferred segment of foo )]448 code0
[2(      mov   ds,ax )]437 code0
[2(      mov   ax,data               ; a different segment )]426 code0
[2(      mov   es,ax )]415 code0
[2(      mov   ax,[ds:foo]           ; this accesses `foo' )]404 code0
[2(      mov   [es:foo wrt data],bx  ; so does this)]393 code2
[{/section-6.2.1 xa}2(obj)0( Extensions to the )2(SEGMENT)0( Directive)](6.2.1)375 subh3
[(The )2(obj)0( output format extends the )2(SEGMENT)0( \(or )2(SECTION)0(\) directive to allow you to specify)]358 norm1
[(various properties of the segment you are defining. This is done by appending extra qualifiers to the)]347 norm0
[(end of the segment-definition line. For example,)]336 norm2
[2(segment code private align=16)]319 code3
[(defines the segment )2(code)0(, but also declares it to be a private segment, and requires that the portion)]302 norm1
[(of it described in this code module must be aligned on a 16-byte boundary.)]291 norm2
[(The available qualifiers are:)]274 norm3
[2(PRIVATE)0(, )2(PUBLIC)0(, )2(COMMON)0( and )2(STACK)0( specify the combination characteristics of the)]257 bull1
[(segment. )2(PRIVATE)0( segments do not get combined with any others by the linker; )2(PUBLIC)0( and)]246 bull0
[2(STACK)0( segments get concatenated together at link time; and )2(COMMON)0( segments all get overlaid)]235 bull0
[(on top of each other rather than stuck end-to-end.)]224 bull2
[2(ALIGN)0( is used, as shown above, to specify how many low bits of the segment start address must)]207 bull1
[(be forced to zero. The alignment value given may be any power of two from 1 to 4096; in reality,)]196 bull0
[(the only values supported are 1, 2, 4, 16, 256 and 4096, so if 8 is specified it will be rounded up)]185 bull0
[(to 16, and 32, 64 and 128 will all be rounded up to 256, and so on. Note that alignment to)]174 bull0
[(4096-byte boundaries is a )(PharLap extension to the format and may not be supported by all)]163 bull0
[(linkers.)]152 bull2
[2(CLASS)0( can be used to specify the segment class; this feature indicates to the linker that segments)]135 bull1
[(of the same class should be placed near each other in the output file. The class name can be any)]124 bull0
[(word, e.g. )2(CLASS=CODE)0(.)]113 bull2
(72)pageeven
restore showpage
%%Page: 73 73
%%BeginPageSetup
save
%%EndPageSetup
/73 pa
[2(OVERLAY)0(, like )2(CLASS)0(, is specified with an arbitrary word as an argument, and provides overlay)]681 bull1
[(information to an overlay-capable linker.)]670 bull2
[(Segments can be declared as )2(USE16)0( or )2(USE32)0(, which has the effect of recording the choice in)]653 bull1
[(the object file and also ensuring that NASM's default assembly mode when assembling in that)]642 bull0
[(segment is 16-bit or 32-bit respectively.)]631 bull2
[(When writing )(OS/2 object files, you should declare 32-bit segments as )2(FLAT)0(, which causes the)]614 bull1
[(default segment base for anything in the segment to be the special group )2(FLAT)0(, and also defines)]603 bull0
[(the group if it is not already defined.)]592 bull2
[(The )2(obj)0( file format also allows segments to be declared as having a pre-defined absolute)]575 bull1
[(segment address, although no linkers are currently known to make sensible use of this feature;)]564 bull0
[(nevertheless, NASM allows you to declare a segment such as)]553 bull0
[2(SEGMENT SCREEN ABSOLUTE=0xB800)0( if you need to. The )2(ABSOLUTE)0( and )2(ALIGN)]542 bull0
[(keywords are mutually exclusive.)]531 bull2
[(NASM's default segment attributes are )2(PUBLIC)0(, )2(ALIGN=1)0(, no class, no overlay, and )2(USE16)0(.)]514 norm3
[{/section-6.2.2 xa}2(GROUP)0(: Defining Groups of Segments)](6.2.2)496 subh3
[(The )2(obj)0( format also allows segments to be grouped, so that a single segment register can be used)]479 norm1
[(to refer to all the segments in a group. NASM therefore supplies the )2(GROUP)0( directive, whereby you)]468 norm0
[(can code)]457 norm2
[2(segment data )]440 code1
[2()]429 code0
[2(        ; some data )]418 code0
[2()]407 code0
[2(segment bss )]396 code0
[2()]385 code0
[2(        ; some uninitialised data )]374 code0
[2()]363 code0
[2(group dgroup data bss)]352 code2
[(which will define a group called )2(dgroup)0( to contain the segments )2(data)0( and )2(bss)0(. Like )2(SEGMENT)0(,)]335 norm1
[2(GROUP)0( causes the group name to be defined as a symbol, so that you can refer to a variable )2(var)0( in)]324 norm0
[(the )2(data)0( segment as )2(var wrt data)0( or as )2(var wrt dgroup)0(, depending on which segment)]313 norm0
[(value is currently in your segment register.)]302 norm2
[(If you just refer to )2(var)0(, however, and )2(var)0( is declared in a segment which is part of a group, then)]285 norm1
[(NASM will default to giving you the offset of )2(var)0( from the beginning of the )1(group)0(, not the)]274 norm0
[1(segment)0(. Therefore )2(SEG var)0(, also, will return the group base rather than the segment base.)]263 norm2
[(NASM will allow a segment to be part of more than one group, but will generate a warning if you)]246 norm1
[(do this. Variables declared in a segment which is part of more than one group will default to being)]235 norm0
[(relative to the first group that was defined to contain the segment.)]224 norm2
[(A group does not have to contain any segments; you can still make )2(WRT)0( references to a group which)]207 norm1
[(does not contain the variable you are referring to. OS/2, for example, defines the special group)]196 norm0
[2(FLAT)0( with no segments in it.)]185 norm2
[{/section-6.2.3 xa}2(UPPERCASE)0(: Disabling Case Sensitivity in Output)](6.2.3)167 subh3
[(Although NASM itself is )(case sensitive, some OMF linkers are not; therefore it can be useful for)]150 norm1
[(NASM to output single-case object files. The )2(UPPERCASE)0( format-specific directive causes all)]139 norm0
[(segment, group and symbol names that are written to the object file to be forced to upper case just)]128 norm0
[(before being written. Within a source file, NASM is still case-sensitive; but the object file can be)]117 norm0
[(written entirely in upper case if desired.)]106 norm2
(73)pageodd
restore showpage
%%Page: 74 74
%%BeginPageSetup
save
%%EndPageSetup
/74 pa
[2(UPPERCASE)0( is used alone on a line; it requires no parameters.)]681 norm3
[{/section-6.2.4 xa}2(IMPORT)0(: Importing DLL Symbols)](6.2.4)663 subh3
[(The )2(IMPORT)0( format-specific directive defines a symbol to be imported from a DLL, for use if you)]646 norm1
[(are writing a DLL's )(import library in NASM. You still need to declare the symbol as )2(EXTERN)0( as)]635 norm0
[(well as using the )2(IMPORT)0( directive.)]624 norm2
[(The )2(IMPORT)0( directive takes two required parameters, separated by white space, which are)]607 norm1
[(\(respectively\) the name of the symbol you wish to import and the name of the library you wish to)]596 norm0
[(import it from. For example:)]585 norm2
[2(    import  WSAStartup wsock32.dll)]568 code3
[(A third optional parameter gives the name by which the symbol is known in the library you are)]551 norm1
[(importing it from, in case this is not the same as the name you wish the symbol to be known by to)]540 norm0
[(your code once you have imported it. For example:)]529 norm2
[2(    import  asyncsel wsock32.dll WSAAsyncSelect)]512 code3
[{/section-6.2.5 xa}2(EXPORT)0(: Exporting DLL Symbols)](6.2.5)494 subh3
[(The )2(EXPORT)0( format-specific directive defines a global symbol to be exported as a DLL symbol,)]477 norm1
[(for use if you are writing a DLL in NASM. You still need to declare the symbol as )2(GLOBAL)0( as well)]466 norm0
[(as using the )2(EXPORT)0( directive.)]455 norm2
[2(EXPORT)0( takes one required parameter, which is the name of the symbol you wish to export, as it)]438 norm1
[(was defined in your source file. An optional second parameter \(separated by white space from the)]427 norm0
[(first\) gives the )1(external)0( name of the symbol: the name by which you wish the symbol to be known)]416 norm0
[(to programs using the DLL. If this name is the same as the internal name, you may leave the second)]405 norm0
[(parameter off.)]394 norm2
[(Further parameters can be given to define attributes of the exported symbol. These parameters, like)]377 norm1
[(the second, are separated by white space. If further parameters are given, the external name must)]366 norm0
[(also be specified, even if it is the same as the internal name. The available attributes are:)]355 norm2
[2(resident)0( indicates that the exported name is to be kept resident by the system loader. This is)]338 bull1
[(an optimisation for frequently used symbols imported by name.)]327 bull2
[2(nodata)0( indicates that the exported symbol is a function which does not make use of any)]310 bull1
[(initialised data.)]299 bull2
[2(parm=NNN)0(, where )2(NNN)0( is an integer, sets the number of parameter words for the case in which)]282 bull1
[(the symbol is a call gate between 32-bit and 16-bit segments.)]271 bull2
[(An attribute which is just a number indicates that the symbol should be exported with an)]254 bull1
[(identifying number \(ordinal\), and gives the desired number.)]243 bull2
[(For example:)]226 norm3
[2(    export  myfunc )]209 code1
[2(    export  myfunc TheRealMoreFormalLookingFunctionName )]198 code0
[2(    export  myfunc myfunc 1234  ; export by ordinal )]187 code0
[2(    export  myfunc myfunc resident parm=23 nodata)]176 code2
[{/section-6.2.6 xa}2(..start)0(: Defining the )(Program Entry Point)](6.2.6)158 subh3
[2(OMF)0( linkers require exactly one of the object files being linked to define the program entry point,)]141 norm1
[(where execution will begin when the program is run. If the object file that defines the entry point is)]130 norm0
[(assembled using NASM, you specify the entry point by declaring the special symbol )2(..start)0( at)]119 norm0
[(the point where you wish execution to begin.)]108 norm2
(74)pageeven
restore showpage
%%Page: 75 75
%%BeginPageSetup
save
%%EndPageSetup
/75 pa
[{/section-6.2.7 xa}2(obj)0( Extensions to the )2(EXTERN)0( Directive)](6.2.7)680 subh3
[(If you declare an external symbol with the directive)]663 norm3
[2(    extern  foo)]646 code3
[(then references such as )2(mov ax,foo)0( will give you the offset of )2(foo)0( from its preferred segment)]629 norm1
[(base \(as specified in whichever module )2(foo)0( is actually defined in\). So to access the contents of)]618 norm0
[2(foo)0( you will usually need to do something like)]607 norm2
[2(        mov     ax,seg foo      ; get preferred segment base )]590 code1
[2(        mov     es,ax           ; move it into ES )]579 code0
[2(        mov     ax,[es:foo]     ; and use offset `foo' from it)]568 code2
[(This is a little unwieldy, particularly if you know that an external is going to be accessible from a)]551 norm1
[(given segment or group, say )2(dgroup)0(. So if )2(DS)0( already contained )2(dgroup)0(, you could simply code)]540 norm2
[2(        mov     ax,[foo wrt dgroup])]523 code3
[(However, having to type this every time you want to access )2(foo)0( can be a pain; so NASM allows)]506 norm1
[(you to declare )2(foo)0( in the alternative form)]495 norm2
[2(    extern  foo:wrt dgroup)]478 code3
[(This form causes NASM to pretend that the preferred segment base of )2(foo)0( is in fact )2(dgroup)0(; so)]461 norm1
[(the expression )2(seg foo)0( will now return )2(dgroup)0(, and the expression )2(foo)0( is equivalent to)]450 norm0
[2(foo wrt dgroup)0(.)]439 norm2
[(This )(default-)2(WRT)0( mechanism can be used to make externals appear to be relative to any group or)]422 norm1
[(segment in your program. It can also be applied to common variables: see ){/section-6.2.8 xl}(section 6.2.8){el}(.)]411 norm2
[{/section-6.2.8 xa}2(obj)0( Extensions to the )2(COMMON)0( Directive)](6.2.8)393 subh3
[(The )2(obj)0( format allows common variables to be either near)( or far)(; NASM allows you to specify)]376 norm1
[(which your variables should be by the use of the syntax)]365 norm2
[2(common  nearvar 2:near   ; `nearvar' is a near common )]348 code1
[2(common  farvar  10:far   ; and `farvar' is far)]337 code2
[(Far common variables may be greater in size than 64Kb, and so the OMF specification says that)]320 norm1
[(they are declared as a number of )1(elements)0( of a given size. So a 10-byte far common variable could)]309 norm0
[(be declared as ten one-byte elements, five two-byte elements, two five-byte elements or one)]298 norm0
[(ten-byte element.)]287 norm2
[(Some )2(OMF)0( linkers require the )(element size, as well as the variable size, to match when resolving)]270 norm1
[(common variables declared in more than one module. Therefore NASM must allow you to specify)]259 norm0
[(the element size on your far common variables. This is done by the following syntax:)]248 norm2
[2(common  c_5by2  10:far 5        ; two five-byte elements )]231 code1
[2(common  c_2by5  10:far 2        ; five two-byte elements)]220 code2
[(If no element size is specified, the default is 1. Also, the )2(FAR)0( keyword is not required when an)]203 norm1
[(element size is specified, since only far commons may have element sizes at all. So the above)]192 norm0
[(declarations could equivalently be)]181 norm2
[2(common  c_5by2  10:5            ; two five-byte elements )]164 code1
[2(common  c_2by5  10:2            ; five two-byte elements)]153 code2
[(In addition to these extensions, the )2(COMMON)0( directive in )2(obj)0( also supports default-)2(WRT)]136 norm1
[(specification like )2(EXTERN)0( does \(explained in ){/section-6.2.7 xl}(section 6.2.7){el}(\). So you can also declare things like)]125 norm2
(75)pageodd
restore showpage
%%Page: 76 76
%%BeginPageSetup
save
%%EndPageSetup
/76 pa
[2(common  foo     10:wrt dgroup )]681 code1
[2(common  bar     16:far 2:wrt data )]670 code0
[2(common  baz     24:wrt data:6)]659 code2
[{/section-6.3 xa}2(win32)0(: Microsoft Win32 Object Files)](6.3)639 head3
[(The )2(win32)0( output format generates Microsoft Win32 object files, suitable for passing to Microsoft)]622 norm1
[(linkers such as )(Visual C++. Note that Borland Win32 compilers do not use this format, but use )2(obj)]611 norm0
[(instead \(see ){/section-6.2 xl}(section 6.2){el}(\).)]600 norm2
[2(win32)0( provides a default output file-name extension of )2(.obj)0(.)]583 norm3
[(Note that although Microsoft say that Win32 object files follow the )2(COFF)0( \(Common Object File)]566 norm1
[(Format\) standard, the object files produced by Microsoft Win32 compilers are not compatible with)]555 norm0
[(COFF linkers such as DJGPP's, and vice versa. This is due to a difference of opinion over the)]544 norm0
[(precise semantics of PC-relative relocations. To produce COFF files suitable for DJGPP, use)]533 norm0
[(NASM's )2(coff)0( output format; conversely, the )2(coff)0( format does not produce object files that)]522 norm0
[(Win32 linkers can generate correct output from.)]511 norm2
[{/section-6.3.1 xa}2(win32)0( Extensions to the )2(SECTION)0( Directive)](6.3.1)493 subh3
[(Like the )2(obj)0( format, )2(win32)0( allows you to specify additional information on the )2(SECTION)]476 norm1
[(directive line, to control the type and properties of sections you declare. Section types and)]465 norm0
[(properties are generated automatically by NASM for the )(standard section names )2(.text)0(, )2(.data)]454 norm0
[(and )2(.bss)0(, but may still be overridden by these qualifiers.)]443 norm2
[(The available qualifiers are:)]426 norm3
[2(code)0(, or equivalently )2(text)0(, defines the section to be a code section. This marks the section as)]409 bull1
[(readable and executable, but not writable, and also indicates to the linker that the type of the)]398 bull0
[(section is code.)]387 bull2
[2(data)0( and )2(bss)0( define the section to be a data section, analogously to )2(code)0(. Data sections are)]370 bull1
[(marked as readable and writable, but not executable. )2(data)0( declares an initialised data section,)]359 bull0
[(whereas )2(bss)0( declares an uninitialised data section.)]348 bull2
[2(rdata)0( declares an initialised data section that is readable but not writable. Microsoft compilers)]331 bull1
[(use this section to place constants in it.)]320 bull2
[2(info)0( defines the section to be an )(informational section, which is not included in the executable)]303 bull1
[(file by the linker, but may \(for example\) pass information )1(to)0( the linker. For example, declaring an)]292 bull0
[2(info)0(\226type section called )2(.drectve)0( causes the linker to interpret the contents of the section as)]281 bull0
[(command-line options.)]270 bull2
[2(align=)0(, used with a trailing number as in )2(obj)0(, gives the )(alignment requirements of the section.)]253 bull1
[(The maximum you may specify is 64: the Win32 object file format contains no means to request)]242 bull0
[(a greater section alignment than this. If alignment is not explicitly specified, the defaults are)]231 bull0
[(16-byte alignment for code sections, 8-byte alignment for rdata sections and 4-byte alignment)]220 bull0
[(for data \(and BSS\) sections. Informational sections get a default alignment of 1 byte \(no)]209 bull0
[(alignment\), though the value does not matter.)]198 bull2
[(The defaults assumed by NASM if you do not specify the above qualifiers are:)]181 norm3
[2(section .text    code  align=16 )]164 code1
[2(section .data    data  align=4 )]153 code0
[2(section .rdata   rdata align=8 )]142 code0
[2(section .bss     bss   align=4)]131 code2
[(Any other section name is treated by default like )2(.text)0(.)]114 norm3
(76)pageeven
restore showpage
%%Page: 77 77
%%BeginPageSetup
save
%%EndPageSetup
/77 pa
[{/section-6.4 xa}2(coff)0(: )(Common Object File Format)](6.4)678 head3
[(The )2(coff)0( output type produces )2(COFF)0( object files suitable for linking with the )(DJGPP linker.)]661 norm3
[2(coff)0( provides a default output file-name extension of )2(.o)0(.)]644 norm3
[(The )2(coff)0( format supports the same extensions to the )2(SECTION)0( directive as )2(win32)0( does, except)]627 norm1
[(that the )2(align)0( qualifier and the )2(info)0( section type are not supported.)]616 norm2
[{/section-6.5 xa}2(elf)0(: )(Executable and Linkable Format Object Files)](6.5)596 head3
[(The )2(elf)0( output format generates )2(ELF32)0( \(Executable and Linkable Format\) object files, as used by)]579 norm1
[(Linux as well as )(Unix System V, including )(Solaris x86, )(UnixWare and )(SCO Unix. )2(elf)0( provides a)]568 norm0
[(default output file-name extension of )2(.o)0(.)]557 norm2
[{/section-6.5.1 xa}2(elf)0( Extensions to the )2(SECTION)0( Directive)](6.5.1)539 subh3
[(Like the )2(obj)0( format, )2(elf)0( allows you to specify additional information on the )2(SECTION)0( directive)]522 norm1
[(line, to control the type and properties of sections you declare. Section types and properties are)]511 norm0
[(generated automatically by NASM for the )(standard section names )2(.text)0(, )2(.data)0( and )2(.bss)0(, but)]500 norm0
[(may still be overridden by these qualifiers.)]489 norm2
[(The available qualifiers are:)]472 norm3
[2(alloc)0( defines the section to be one which is loaded into memory when the program is run.)]455 bull1
[2(noalloc)0( defines it to be one which is not, such as an informational or comment section.)]444 bull2
[2(exec)0( defines the section to be one which should have execute permission when the program is)]427 bull1
[(run. )2(noexec)0( defines it as one which should not.)]416 bull2
[2(write)0( defines the section to be one which should be writable when the program is run.)]399 bull1
[2(nowrite)0( defines it as one which should not.)]388 bull2
[2(progbits)0( defines the section to be one with explicit contents stored in the object file: an)]371 bull1
[(ordinary code or data section, for example, )2(nobits)0( defines the section to be one with no)]360 bull0
[(explicit contents given, such as a BSS section.)]349 bull2
[2(align=)0(, used with a trailing number as in )2(obj)0(, gives the )(alignment requirements of the section.)]332 bull3
[(The defaults assumed by NASM if you do not specify the above qualifiers are:)]315 norm3
[2(section .text    progbits  alloc  exec    nowrite  align=16 )]298 code1
[2(section .rodata  progbits  alloc  noexec  nowrite  align=4 )]287 code0
[2(section .data    progbits  alloc  noexec  write    align=4 )]276 code0
[2(section .bss     nobits    alloc  noexec  write    align=4 )]265 code0
[2(section other    progbits  alloc  noexec  nowrite  align=1)]254 code2
[(\(Any section name other than )2(.text)0(, )2(.rodata)0(, )2(.data)0( and )2(.bss)0( is treated by default like)]237 norm1
[2(other)0( in the above code.\))]226 norm2
[{/section-6.5.2 xa}(Position-Independent Code)(: )2(elf)0( Special Symbols and )2(WRT)](6.5.2)208 subh3
[(The )2(ELF)0( specification contains enough features to allow position-independent code \(PIC\) to be)]191 norm1
[(written, which makes )(ELF shared libraries very flexible. However, it also means NASM has to be)]180 norm0
[(able to generate a variety of strange relocation types in ELF object files, if it is to be an assembler)]169 norm0
[(which can write PIC.)]158 norm2
[(Since )2(ELF)0( does not support segment-base references, the )2(WRT)0( operator is not used for its normal)]141 norm1
[(purpose; therefore NASM's )2(elf)0( output format makes use of )2(WRT)0( for a different purpose, namely)]130 norm0
[(the PIC-specific )(relocation types.)]119 norm2
(77)pageodd
restore showpage
%%Page: 78 78
%%BeginPageSetup
save
%%EndPageSetup
/78 pa
[2(elf)0( defines five special symbols which you can use as the right-hand side of the )2(WRT)0( operator to)]681 norm1
[(obtain PIC relocation types. They are )2(..gotpc)0(, )2(..gotoff)0(, )2(..got)0(, )2(..plt)0( and )2(..sym)0(. Their)]670 norm0
[(functions are summarised here:)]659 norm2
[(Referring to the symbol marking the global offset table base using )2(wrt ..gotpc)0( will end up)]642 bull1
[(giving the distance from the beginning of the current section to the global offset table.)]631 bull0
[(\()2(_GLOBAL_OFFSET_TABLE_)0( is the standard symbol name used to refer to the )(GOT.\) So you)]620 bull0
[(would then need to add )2($$)0( to the result to get the real address of the GOT.)]609 bull2
[(Referring to a location in one of your own sections using )2(wrt ..gotoff)0( will give the distance)]592 bull1
[(from the beginning of the GOT to the specified location, so that adding on the address of the)]581 bull0
[(GOT would give the real address of the location you wanted.)]570 bull2
[(Referring to an external or global symbol using )2(wrt ..got)0( causes the linker to build an entry)]553 bull1
[1(in)0( the GOT containing the address of the symbol, and the reference gives the distance from the)]542 bull0
[(beginning of the GOT to the entry; so you can add on the address of the GOT, load from the)]531 bull0
[(resulting address, and end up with the address of the symbol.)]520 bull2
[(Referring to a procedure name using )2(wrt ..plt)0( causes the linker to build a )(procedure linkage)]503 bull1
[(table entry for the symbol, and the reference gives the address of the )(PLT entry. You can only)]492 bull0
[(use this in contexts which would generate a PC-relative relocation normally \(i.e. as the)]481 bull0
[(destination for )2(CALL)0( or )2(JMP)0(\), since ELF contains no relocation type to refer to PLT entries)]470 bull0
[(absolutely.)]459 bull2
[(Referring to a symbol name using )2(wrt ..sym)0( causes NASM to write an ordinary relocation,)]442 bull1
[(but instead of making the relocation relative to the start of the section and then adding on the)]431 bull0
[(offset to the symbol, it will write a relocation record aimed directly at the symbol in question.)]420 bull0
[(The distinction is a necessary one due to a peculiarity of the dynamic linker.)]409 bull2
[(A fuller explanation of how to use these relocation types to write shared libraries entirely in NASM)]392 norm1
[(is given in ){/section-8.2 xl}(section 8.2){el}(.)]381 norm2
[{/section-6.5.3 xa}2(elf)0( Extensions to the )2(GLOBAL)0( Directive)](6.5.3)363 subh3
[2(ELF)0( object files can contain more information about a global symbol than just its address: they can)]346 norm1
[(contain the )(size of the symbol and its )(type as well. These are not merely debugger conveniences, but)]335 norm0
[(are actually necessary when the program being written is a )(shared library. NASM therefore supports)]324 norm0
[(some extensions to the )2(GLOBAL)0( directive, allowing you to specify these features.)]313 norm2
[(You can specify whether a global variable is a function or a data object by suffixing the name with a)]296 norm1
[(colon and the word )2(function)0( or )2(data)0(. \()2(object)0( is a synonym for )2(data)0(.\) For example:)]285 norm2
[2(global   hashlookup:function, hashtable:data)]268 code3
[(exports the global symbol )2(hashlookup)0( as a function and )2(hashtable)0( as a data object.)]251 norm3
[(You can also specify the size of the data associated with the symbol, as a numeric expression)]234 norm1
[(\(which may involve labels, and even forward references\) after the type specifier. Like this:)]223 norm2
[2(global  hashtable:data \(hashtable.end - hashtable\) )]206 code1
[2()]195 code0
[2(hashtable: )]184 code0
[2(        db this,that,theother  ; some data here )]173 code0
[2(.end:)]162 code2
[(This makes NASM automatically calculate the length of the table and place that information into)]145 norm1
[(the )2(ELF)0( symbol table.)]134 norm2
[(Declaring the type and size of global symbols is necessary when writing shared library code. For)]117 norm1
[(more information, see ){/section-8.2.4 xl}(section 8.2.4){el}(.)]106 norm2
(78)pageeven
restore showpage
%%Page: 79 79
%%BeginPageSetup
save
%%EndPageSetup
/79 pa
[{/section-6.5.4 xa}2(elf)0( Extensions to the )2(COMMON)0( Directive )](6.5.4)680 subh3
[2(ELF)0( also allows you to specify alignment requirements )(on common variables. This is done by)]663 norm1
[(putting a number \(which must be a power of two\) after the name and size of the common variable,)]652 norm0
[(separated \(as usual\) by a colon. For example, an array of doublewords would benefit from 4-byte)]641 norm0
[(alignment:)]630 norm2
[2(common  dwordarray 128:4)]613 code3
[(This declares the total size of the array to be 128 bytes, and requires that it be aligned on a 4-byte)]596 norm1
[(boundary.)]585 norm2
[{/section-6.5.5 xa}(16-bit code and ELF )](6.5.5)567 subh3
[(The )2(ELF32)0( specification doesn't provide relocations for 8- and 16-bit values, but the GNU )2(ld)]550 norm1
[(linker adds these as an extension. NASM can generate GNU-compatible relocations, to allow)]539 norm0
[(16-bit code to be linked as ELF using GNU )2(ld)0(. If NASM is used with the)]528 norm0
[2(-w+gnu-elf-extensions)0( option, a warning is issued when one of these relocations is)]517 norm0
[(generated.)]506 norm2
[{/section-6.6 xa}2(aout)0(: Linux )2(a.out)0( Object Files)](6.6)486 head3
[(The )2(aout)0( format generates )2(a.out)0( object files, in the form used by early Linux systems \(current)]469 norm1
[(Linux systems use ELF, see ){/section-6.5 xl}(section 6.5){el}(.\) These differ from other )2(a.out)0( object files in that the)]458 norm0
[(magic number in the first four bytes of the file is different; also, some implementations of )2(a.out)0(,)]447 norm0
[(for example NetBSD's, support position-independent code, which Linux's implementation does not.)]436 norm2
[2(a.out)0( provides a default output file-name extension of )2(.o)0(.)]419 norm3
[2(a.out)0( is a very simple object format. It supports no special directives, no special symbols, no use)]402 norm1
[(of )2(SEG)0( or )2(WRT)0(, and no extensions to any standard directives. It supports only the three )(standard)]391 norm0
[(section names )2(.text)0(, )2(.data)0( and )2(.bss)0(.)]380 norm2
[{/section-6.7 xa}2(aoutb)0(: )(NetBSD/)(FreeBSD/)(OpenBSD )2(a.out)0( Object Files)](6.7)360 head3
[(The )2(aoutb)0( format generates )2(a.out)0( object files, in the form used by the various free )2(BSD Unix)]343 norm1
[(clones, )2(NetBSD)0(, )2(FreeBSD)0( and )2(OpenBSD)0(. For simple object files, this object format is exactly the)]332 norm0
[(same as )2(aout)0( except for the magic number in the first four bytes of the file. However, the )2(aoutb)]321 norm0
[(format supports )(position-independent code in the same way as the )2(elf)0( format, so you can use it to)]310 norm0
[(write )2(BSD)0( )(shared libraries.)]299 norm2
[2(aoutb)0( provides a default output file-name extension of )2(.o)0(.)]282 norm3
[2(aoutb)0( supports no special directives, no special symbols, and only the three )(standard section)]265 norm1
[(names )2(.text)0(, )2(.data)0( and )2(.bss)0(. However, it also supports the same use of )2(WRT)0( as )2(elf)0( does, to)]254 norm0
[(provide position-independent code relocation types. See ){/section-6.5.2 xl}(section 6.5.2){el}( for full documentation of this)]243 norm0
[(feature.)]232 norm2
[2(aoutb)0( also supports the same extensions to the )2(GLOBAL)0( directive as )2(elf)0( does: see ){/section-6.5.3 xl}(section 6.5.3){el}]215 norm1
[(for documentation of this.)]204 norm2
[{/section-6.8 xa}2(as86)0(: )(Minix/Linux)( )2(as86)0( Object Files)](6.8)184 head3
[(The Minix/Linux 16-bit assembler )2(as86)0( has its own non-standard object file format. Although its)]167 norm1
[(companion linker )2(ld86)0( produces something close to ordinary )2(a.out)0( binaries as output, the object)]156 norm0
[(file format used to communicate between )2(as86)0( and )2(ld86)0( is not itself )2(a.out)0(.)]145 norm2
[(NASM supports this format, just in case it is useful, as )2(as86)0(. )2(as86)0( provides a default output)]128 norm1
[(file-name extension of )2(.o)0(.)]117 norm2
(79)pageodd
restore showpage
%%Page: 80 80
%%BeginPageSetup
save
%%EndPageSetup
/80 pa
[2(as86)0( is a very simple object format \(from the NASM user's point of view\). It supports no special)]681 norm1
[(directives, no special symbols, no use of )2(SEG)0( or )2(WRT)0(, and no extensions to any standard directives.)]670 norm0
[(It supports only the three )(standard section names )2(.text)0(, )2(.data)0( and )2(.bss)0(.)]659 norm2
[{/section-6.9 xa}2(rdf)0(: )(Relocatable Dynamic Object File Format)](6.9)639 head3
[(The )2(rdf)0( output format produces )2(RDOFF)0( object files. )2(RDOFF)0( \(Relocatable Dynamic Object File)]622 norm1
[(Format\) is a home-grown object-file format, designed alongside NASM itself and reflecting in its)]611 norm0
[(file format the internal structure of the assembler.)]600 norm2
[2(RDOFF)0( is not used by any well-known operating systems. Those writing their own systems,)]583 norm1
[(however, may well wish to use )2(RDOFF)0( as their object format, on the grounds that it is designed)]572 norm0
[(primarily for simplicity and contains very little file-header bureaucracy.)]561 norm2
[(The Unix NASM archive, and the DOS archive which includes sources, both contain an )2(rdoff)]544 norm1
[(subdirectory holding a set of RDOFF utilities: an RDF linker, an )2(RDF)0( static-library manager, an)]533 norm0
[(RDF file dump utility, and a program which will load and execute an RDF executable under Linux.)]522 norm2
[2(rdf)0( supports only the )(standard section names )2(.text)0(, )2(.data)0( and )2(.bss)0(.)]505 norm3
[{/section-6.9.1 xa}(Requiring a Library: The )2(LIBRARY)0( Directive)](6.9.1)487 subh3
[2(RDOFF)0( contains a mechanism for an object file to demand a given library to be linked to the)]470 norm1
[(module, either at load time or run time. This is done by the )2(LIBRARY)0( directive, which takes one)]459 norm0
[(argument which is the name of the module:)]448 norm2
[2(    library  mylib.rdl)]431 code3
[{/section-6.9.2 xa}(Specifying a Module Name: The )2(MODULE)0( Directive)](6.9.2)413 subh3
[(Special )2(RDOFF)0( header record is used to store the name of the module. It can be used, for example,)]396 norm1
[(by run-time loader to perform dynamic linking. )2(MODULE)0( directive takes one argument which is the)]385 norm0
[(name of current module:)]374 norm2
[2(    module  mymodname)]357 code3
[(Note that when you statically link modules and tell linker to strip the symbols from output file, all)]340 norm1
[(module names will be stripped too. To avoid it, you should start module names with )2($)0(, like:)]329 norm2
[2(    module  $kernel.core)]312 code3
[{/section-6.9.3 xa}2(rdf)0( Extensions to the )2(GLOBAL)0( directive)](6.9.3)294 subh3
[2(RDOFF)0( global symbols can contain additional information needed by the static linker. You can)]277 norm1
[(mark a global symbol as exported, thus telling the linker do not strip it from target executable or)]266 norm0
[(library file. Like in )2(ELF)0(, you can also specify whether an exported symbol is a procedure \(function\))]255 norm0
[(or data object.)]244 norm2
[(Suffixing the name with a colon and the word )2(export)0( you make the symbol exported:)]227 norm3
[2(    global  sys_open:export)]210 code3
[(To specify that exported symbol is a procedure \(function\), you add the word )2(proc)0( or )2(function)]193 norm1
[(after declaration:)]182 norm2
[2(    global  sys_open:export proc)]165 code3
[(Similarly, to specify exported data object, add the word )2(data)0( or )2(object)0( to the directive:)]148 norm3
[2(    global  kernel_ticks:export data)]131 code3
(80)pageeven
restore showpage
%%Page: 81 81
%%BeginPageSetup
save
%%EndPageSetup
/81 pa
[{/section-6.9.4 xa}2(rdf)0( Extensions to the )2(EXTERN)0( directive)](6.9.4)680 subh3
[(By default the )2(EXTERN)0( directive in )2(RDOFF)0( declares a "pure external" symbol \(i.e. the static linker)]663 norm1
[(will complain if such a symbol is not resolved\). To declare an "imported" symbol, which must be)]652 norm0
[(resolved later during a dynamic linking phase, )2(RDOFF)0( offers an additional )2(import)0( modifier. As in)]641 norm0
[2(GLOBAL)0(, you can also specify whether an imported symbol is a procedure \(function\) or data object.)]630 norm0
[(For example:)]619 norm2
[2(    library $libc )]602 code1
[2(    extern  _open:import )]591 code0
[2(    extern  _printf:import proc )]580 code0
[2(    extern  _errno:import data)]569 code2
[(Here the directive )2(LIBRARY)0( is also included, which gives the dynamic linker a hint as to where to)]552 norm1
[(find requested symbols.)]541 norm2
[{/section-6.10 xa}2(dbg)0(: Debugging Format)](6.10)521 head3
[(The )2(dbg)0( output format is not built into NASM in the default configuration. If you are building your)]504 norm1
[(own NASM executable from the sources, you can define )2(OF_DBG)0( in )2(outform.h)0( or on the)]493 norm0
[(compiler command line, and obtain the )2(dbg)0( output format.)]482 norm2
[(The )2(dbg)0( format does not output an object file as such; instead, it outputs a text file which contains a)]465 norm1
[(complete list of all the transactions between the main body of NASM and the output-format back)]454 norm0
[(end module. It is primarily intended to aid people who want to write their own output drivers, so)]443 norm0
[(that they can get a clearer idea of the various requests the main program makes of the output driver,)]432 norm0
[(and in what order they happen.)]421 norm2
[(For simple files, one can easily use the )2(dbg)0( format like this:)]404 norm3
[2(nasm -f dbg filename.asm)]387 code3
[(which will generate a diagnostic file called )2(filename.dbg)0(. However, this will not work well on)]370 norm1
[(files which were designed for a different object format, because each object format defines its own)]359 norm0
[(macros \(usually user-level forms of directives\), and those macros will not be defined in the )2(dbg)]348 norm0
[(format. Therefore it can be useful to run NASM twice, in order to do the preprocessing with the)]337 norm0
[(native object format selected:)]326 norm2
[2(nasm -e -f rdf -o rdfprog.i rdfprog.asm )]309 code1
[2(nasm -a -f dbg rdfprog.i)]298 code2
[(This preprocesses )2(rdfprog.asm)0( into )2(rdfprog.i)0(, keeping the )2(rdf)0( object format selected in)]281 norm1
[(order to make sure RDF special directives are converted into primitive form correctly. Then the)]270 norm0
[(preprocessed source is fed through the )2(dbg)0( format to generate the final diagnostic output.)]259 norm2
[(This workaround will still typically not work for programs intended for )2(obj)0( format, because the)]242 norm1
[2(obj)0( )2(SEGMENT)0( and )2(GROUP)0( directives have side effects of defining the segment and group names as)]231 norm0
[(symbols; )2(dbg)0( will not do this, so the program will not assemble. You will have to work around that)]220 norm0
[(by defining the symbols yourself \(using )2(EXTERN)0(, for example\) if you really need to get a )2(dbg)0( trace)]209 norm0
[(of an )2(obj)0(\226specific source file.)]198 norm2
[2(dbg)0( accepts any section name and any directives at all, and logs them all to its output file.)]181 norm3
(81)pageodd
restore showpage
%%Page: 82 82
%%BeginPageSetup
save
%%EndPageSetup
/82 pa
[{/chapter-7 xa}(Chapter 7: Writing 16-bit Code \(DOS, Windows 3/3.1\))]644 chap3
[(This chapter attempts to cover some of the common issues encountered when writing 16-bit code to)]609 norm1
[(run under )2(MS-DOS)0( or )2(Windows 3.x)0(. It covers how to link programs to produce )2(.EXE)0( or )2(.COM)]598 norm0
[(files, how to write )2(.SYS)0( device drivers, and how to interface assembly language code with 16-bit)]587 norm0
[(C compilers and with Borland Pascal.)]576 norm2
[{/section-7.1 xa}(Producing )2(.EXE)0( Files)](7.1)556 head3
[(Any large program written under DOS needs to be built as a )2(.EXE)0( file: only )2(.EXE)0( files have the)]539 norm1
[(necessary internal structure required to span more than one 64K segment. )(Windows programs, also,)]528 norm0
[(have to be built as )2(.EXE)0( files, since Windows does not support the )2(.COM)0( format.)]517 norm2
[(In general, you generate )2(.EXE)0( files by using the )2(obj)0( output format to produce one or more )2(.OBJ)]500 norm1
[(files, and then linking them together using a linker. However, NASM also supports the direct)]489 norm0
[(generation of simple DOS )2(.EXE)0( files using the )2(bin)0( output format \(by using )2(DB)0( and )2(DW)0( to)]478 norm0
[(construct the )2(.EXE)0( file header\), and a macro package is supplied to do this. Thanks to Yann Guidon)]467 norm0
[(for contributing the code for this.)]456 norm2
[(NASM may also support )2(.EXE)0( natively as another output format in future releases.)]439 norm3
[{/section-7.1.1 xa}(Using the )2(obj)0( Format To Generate )2(.EXE)0( Files)](7.1.1)421 subh3
[(This section describes the usual method of generating )2(.EXE)0( files by linking )2(.OBJ)0( files together.)]404 norm3
[(Most 16-bit programming language packages come with a suitable linker; if you have none of)]387 norm1
[(these, there is a free linker called )(VAL)(, available in )2(LZH)0( archive format from ){(ftp://x2ftp.oulu.fi/pub/msdos/programming/lang/)wl}2(x2ftp.oulu.fi){el}0(.)]376 norm0
[(An LZH archiver can be found at ){(ftp://ftp.simtel.net/pub/simtelnet/msdos/arcers)wl}2(ftp.simtel.net){el}0(. There is another `free' linker \(though this)]365 norm0
[(one doesn't come with sources\) called )(FREELINK, available from ){(http://www.pcorner.com/tpc/old/3-101.html)wl}2(www.pcorner.com){el}0(. A third,)]354 norm0
[2(djlink)0(, written by DJ Delorie, is available at ){(http://www.delorie.com/djgpp/16bit/djlink/)wl}2(www.delorie.com){el}0(. A fourth linker, )2(ALINK)0(,)]343 norm0
[(written by Anthony A.J. Williams, is available at ){(http://alink.sourceforge.net)wl}2(alink.sourceforge.net){el}0(.)]332 norm2
[(When linking several )2(.OBJ)0( files into a )2(.EXE)0( file, you should ensure that exactly one of them has a)]315 norm1
[(start point defined \(using the )2(..start)0( special symbol defined by the )2(obj)0( format: see ){/section-6.2.6 xl}(section){el}]304 norm0
[{/section-6.2.6 xl}(6.2.6){el}(\). If no module defines a start point, the linker will not know what value to give the)]293 norm0
[(entry-point field in the output file header; if more than one defines a start point, the linker will not)]282 norm0
[(know )1(which)0( value to use.)]271 norm2
[(An example of a NASM source file which can be assembled to a )2(.OBJ)0( file and linked on its own to)]254 norm1
[(a )2(.EXE)0( is given here. It demonstrates the basic principles of defining a stack, initialising the)]243 norm0
[(segment registers, and declaring a start point. This file is also provided in the )2(test)0( subdirectory of)]232 norm0
[(the NASM archives, under the name )2(objexe.asm)0(.)]221 norm2
[2(segment code )]204 code1
[2()]193 code0
[2(..start: )]182 code0
[2(        mov     ax,data )]171 code0
[2(        mov     ds,ax )]160 code0
[2(        mov     ax,stack )]149 code0
[2(        mov     ss,ax )]138 code0
[2(        mov     sp,stacktop)]127 code2
(82)pageeven
restore showpage
%%Page: 83 83
%%BeginPageSetup
save
%%EndPageSetup
/83 pa
[(This initial piece of code sets up )2(DS)0( to point to the data segment, and initialises )2(SS)0( and )2(SP)0( to point)]681 norm1
[(to the top of the provided stack. Notice that interrupts are implicitly disabled for one instruction)]670 norm0
[(after a move into )2(SS)0(, precisely for this situation, so that there's no chance of an interrupt occurring)]659 norm0
[(between the loads of )2(SS)0( and )2(SP)0( and not having a stack to execute on.)]648 norm2
[(Note also that the special symbol )2(..start)0( is defined at the beginning of this code, which means)]631 norm1
[(that will be the entry point into the resulting executable file.)]620 norm2
[2(        mov     dx,hello )]603 code1
[2(        mov     ah,9 )]592 code0
[2(        int     0x21)]581 code2
[(The above is the main program: load )2(DS:DX)0( with a pointer to the greeting message \()2(hello)0( is)]564 norm1
[(implicitly relative to the segment )2(data)0(, which was loaded into )2(DS)0( in the setup code, so the full)]553 norm0
[(pointer is valid\), and call the DOS print-string function.)]542 norm2
[2(        mov     ax,0x4c00 )]525 code1
[2(        int     0x21)]514 code2
[(This terminates the program using another DOS system call.)]497 norm3
[2(segment data )]480 code1
[2()]469 code0
[2(hello:  db      'hello, world', 13, 10, '$')]458 code2
[(The data segment contains the string we want to display.)]441 norm3
[2(segment stack stack )]424 code1
[2(        resb 64 )]413 code0
[2(stacktop:)]402 code2
[(The above code declares a stack segment containing 64 bytes of uninitialised stack space, and)]385 norm1
[(points )2(stacktop)0( at the top of it. The directive )2(segment stack stack)0( defines a segment)]374 norm0
[1(called)0( )2(stack)0(, and also of )1(type)0( )2(STACK)0(. The latter is not necessary to the correct running of the)]363 norm0
[(program, but linkers are likely to issue warnings or errors if your program has no segment of type)]352 norm0
[2(STACK)0(.)]341 norm2
[(The above file, when assembled into a )2(.OBJ)0( file, will link on its own to a valid )2(.EXE)0( file, which)]324 norm1
[(when run will print `hello, world' and then exit.)]313 norm2
[{/section-7.1.2 xa}(Using the )2(bin)0( Format To Generate )2(.EXE)0( Files)](7.1.2)295 subh3
[(The )2(.EXE)0( file format is simple enough that it's possible to build a )2(.EXE)0( file by writing a)]278 norm1
[(pure-binary program and sticking a 32-byte header on the front. This header is simple enough that)]267 norm0
[(it can be generated using )2(DB)0( and )2(DW)0( commands by NASM itself, so that you can use the )2(bin)0( output)]256 norm0
[(format to directly generate )2(.EXE)0( files.)]245 norm2
[(Included in the NASM archives, in the )2(misc)0( subdirectory, is a file )2(exebin.mac)0( of macros. It)]228 norm1
[(defines three macros: )2(EXE_begin)0(, )2(EXE_stack)0( and )2(EXE_end)0(.)]217 norm2
[(To produce a )2(.EXE)0( file using this method, you should start by using )2(%include)0( to load the)]200 norm1
[2(exebin.mac)0( macro package into your source file. You should then issue the )2(EXE_begin)0( macro)]189 norm0
[(call \(which takes no arguments\) to generate the file header data. Then write code as normal for the)]178 norm0
[2(bin)0( format \226 you can use all three standard sections )2(.text)0(, )2(.data)0( and )2(.bss)0(. At the end of the)]167 norm0
[(file you should call the )2(EXE_end)0( macro \(again, no arguments\), which defines some symbols to)]156 norm0
[(mark section sizes, and these symbols are referred to in the header code generated by )2(EXE_begin)0(.)]145 norm2
[(In this model, the code you end up writing starts at )2(0x100)0(, just like a )2(.COM)0( file \226 in fact, if you)]128 norm1
[(strip off the 32-byte header from the resulting )2(.EXE)0( file, you will have a valid )2(.COM)0( program. All)]117 norm0
[(the segment bases are the same, so you are limited to a 64K program, again just like a )2(.COM)0( file.)]106 norm0
(83)pageodd
restore showpage
%%Page: 84 84
%%BeginPageSetup
save
%%EndPageSetup
/84 pa
[(Note that an )2(ORG)0( directive is issued by the )2(EXE_begin)0( macro, so you should not explicitly issue)]681 norm0
[(one of your own.)]670 norm2
[(You can't directly refer to your segment base value, unfortunately, since this would require a)]653 norm1
[(relocation in the header, and things would get a lot more complicated. So you should get your)]642 norm0
[(segment base by copying it out of )2(CS)0( instead.)]631 norm2
[(On entry to your )2(.EXE)0( file, )2(SS:SP)0( are already set up to point to the top of a 2Kb stack. You can)]614 norm1
[(adjust the default stack size of 2Kb by calling the )2(EXE_stack)0( macro. For example, to change the)]603 norm0
[(stack size of your program to 64 bytes, you would call )2(EXE_stack 64)0(.)]592 norm2
[(A sample program which generates a )2(.EXE)0( file in this way is given in the )2(test)0( subdirectory of the)]575 norm1
[(NASM archive, as )2(binexe.asm)0(.)]564 norm2
[{/section-7.2 xa}(Producing )2(.COM)0( Files)](7.2)544 head3
[(While large DOS programs must be written as )2(.EXE)0( files, small ones are often better written as)]527 norm1
[2(.COM)0( files. )2(.COM)0( files are pure binary, and therefore most easily produced using the )2(bin)0( output)]516 norm0
[(format.)]505 norm2
[{/section-7.2.1 xa}(Using the )2(bin)0( Format To Generate )2(.COM)0( Files)](7.2.1)487 subh3
[2(.COM)0( files expect to be loaded at offset )2(100h)0( into their segment \(though the segment may change\).)]470 norm1
[(Execution then begins at )2(100h)0(, i.e. right at the start of the program. So to write a )2(.COM)0( program,)]459 norm0
[(you would create a source file looking like)]448 norm2
[2(        org 100h )]431 code1
[2()]420 code0
[2(section .text )]409 code0
[2()]398 code0
[2(start: )]387 code0
[2(        ; put your code here )]376 code0
[2()]365 code0
[2(section .data )]354 code0
[2()]343 code0
[2(        ; put data items here )]332 code0
[2()]321 code0
[2(section .bss )]310 code0
[2()]299 code0
[2(        ; put uninitialised data here)]288 code2
[(The )2(bin)0( format puts the )2(.text)0( section first in the file, so you can declare data or BSS items)]271 norm1
[(before beginning to write code if you want to and the code will still end up at the front of the file)]260 norm0
[(where it belongs.)]249 norm2
[(The BSS \(uninitialised data\) section does not take up space in the )2(.COM)0( file itself: instead,)]232 norm1
[(addresses of BSS items are resolved to point at space beyond the end of the file, on the grounds that)]221 norm0
[(this will be free memory when the program is run. Therefore you should not rely on your BSS being)]210 norm0
[(initialised to all zeros when you run.)]199 norm2
[(To assemble the above program, you should use a command line like)]182 norm3
[2(nasm myprog.asm -fbin -o myprog.com)]165 code3
[(The )2(bin)0( format would produce a file called )2(myprog)0( if no explicit output file name were specified,)]148 norm1
[(so you have to override it and give the desired file name.)]137 norm2
(84)pageeven
restore showpage
%%Page: 85 85
%%BeginPageSetup
save
%%EndPageSetup
/85 pa
[{/section-7.2.2 xa}(Using the )2(obj)0( Format To Generate )2(.COM)0( Files)](7.2.2)680 subh3
[(If you are writing a )2(.COM)0( program as more than one module, you may wish to assemble several)]663 norm1
[2(.OBJ)0( files and link them together into a )2(.COM)0( program. You can do this, provided you have a)]652 norm0
[(linker capable of outputting )2(.COM)0( files directly \()(TLINK does this\), or alternatively a converter)]641 norm0
[(program such as )2(EXE2BIN)0( to transform the )2(.EXE)0( file output from the linker into a )2(.COM)0( file.)]630 norm2
[(If you do this, you need to take care of several things:)]613 norm3
[(The first object file containing code should start its code segment with a line like )2(RESB 100h)0(.)]596 bull1
[(This is to ensure that the code begins at offset )2(100h)0( relative to the beginning of the code)]585 bull0
[(segment, so that the linker or converter program does not have to adjust address references within)]574 bull0
[(the file when generating the )2(.COM)0( file. Other assemblers use an )2(ORG)0( directive for this purpose,)]563 bull0
[(but )2(ORG)0( in NASM is a format-specific directive to the )2(bin)0( output format, and does not mean)]552 bull0
[(the same thing as it does in MASM-compatible assemblers.)]541 bull2
[(You don't need to define a stack segment.)]524 bull3
[(All your segments should be in the same group, so that every time your code or data references a)]507 bull1
[(symbol offset, all offsets are relative to the same segment base. This is because, when a )2(.COM)]496 bull0
[(file is loaded, all the segment registers contain the same value.)]485 bull2
[{/section-7.3 xa}(Producing )2(.SYS)0( Files)](7.3)465 head3
[(MS-DOS device drivers \226 )2(.SYS)0( files \226 are pure binary files, similar to )2(.COM)0( files, except that they)]448 norm1
[(start at origin zero rather than )2(100h)0(. Therefore, if you are writing a device driver using the )2(bin)]437 norm0
[(format, you do not need the )2(ORG)0( directive, since the default origin for )2(bin)0( is zero. Similarly, if you)]426 norm0
[(are using )2(obj)0(, you do not need the )2(RESB 100h)0( at the start of your code segment.)]415 norm2
[2(.SYS)0( files start with a header structure, containing pointers to the various routines inside the driver)]398 norm1
[(which do the work. This structure should be defined at the start of the code segment, even though it)]387 norm0
[(is not actually code.)]376 norm2
[(For more information on the format of )2(.SYS)0( files, and the data which has to go in the header)]359 norm1
[(structure, a list of books is given in the Frequently Asked Questions list for the newsgroup)]348 norm0
[{(news:comp.os.msdos.programmer)wl}2(comp.os.msdos.programmer){el}0(.)]337 norm2
[{/section-7.4 xa}(Interfacing to 16-bit C Programs)](7.4)317 head3
[(This section covers the basics of writing assembly routines that call, or are called from, C programs.)]300 norm1
[(To do this, you would typically write an assembly module as a )2(.OBJ)0( file, and link it with your C)]289 norm0
[(modules to produce a )(mixed-language program.)]278 norm2
[{/section-7.4.1 xa}(External Symbol Names)](7.4.1)260 subh3
[(C compilers have the convention that the names of all global symbols \(functions or data\) they)]243 norm1
[(define are formed by prefixing an underscore to the name as it appears in the C program. So, for)]232 norm0
[(example, the function a C programmer thinks of as )2(printf)0( appears to an assembly language)]221 norm0
[(programmer as )2(_printf)0(. This means that in your assembly programs, you can define symbols)]210 norm0
[(without a leading underscore, and not have to worry about name clashes with C symbols.)]199 norm2
[(If you find the underscores inconvenient, you can define macros to replace the )2(GLOBAL)0( and)]182 norm1
[2(EXTERN)0( directives as follows:)]171 norm2
[2(%macro  cglobal 1 )]154 code1
[2()]143 code0
[2(  global  _%1 )]132 code0
[2(  %define %1 _%1 )]121 code0
[2()]110 code0
(85)pageodd
restore showpage
%%Page: 86 86
%%BeginPageSetup
save
%%EndPageSetup
/86 pa
[2(%endmacro )]681 code0
[2()]670 code0
[2(%macro  cextern 1 )]659 code0
[2()]648 code0
[2(  extern  _%1 )]637 code0
[2(  %define %1 _%1 )]626 code0
[2()]615 code0
[2(%endmacro)]604 code2
[(\(These forms of the macros only take one argument at a time; a )2(%rep)0( construct could solve this.\))]587 norm3
[(If you then declare an external like this:)]570 norm3
[2(cextern printf)]553 code3
[(then the macro will expand it as)]536 norm3
[2(extern  _printf )]519 code1
[2(%define printf _printf)]508 code2
[(Thereafter, you can reference )2(printf)0( as if it was a symbol, and the preprocessor will put the)]491 norm1
[(leading underscore on where necessary.)]480 norm2
[(The )2(cglobal)0( macro works similarly. You must use )2(cglobal)0( before defining the symbol in)]463 norm1
[(question, but you would have had to do that anyway if you used )2(GLOBAL)0(.)]452 norm2
[(Also see ){/section-2.1.21 xl}(section 2.1.21){el}(.)]435 norm3
[{/section-7.4.2 xa}(Memory Models)](7.4.2)417 subh3
[(NASM contains no mechanism to support the various C memory models directly; you have to keep)]400 norm1
[(track yourself of which one you are writing for. This means you have to keep track of the following)]389 norm0
[(things:)]378 norm2
[(In models using a single code segment \(tiny, small and compact\), functions are near. This means)]361 bull1
[(that function pointers, when stored in data segments or pushed on the stack as function)]350 bull0
[(arguments, are 16 bits long and contain only an offset field \(the )2(CS)0( register never changes its)]339 bull0
[(value, and always gives the segment part of the full function address\), and that functions are)]328 bull0
[(called using ordinary near )2(CALL)0( instructions and return using )2(RETN)0( \(which, in NASM, is)]317 bull0
[(synonymous with )2(RET)0( anyway\). This means both that you should write your own routines to)]306 bull0
[(return with )2(RETN)0(, and that you should call external C routines with near )2(CALL)0( instructions.)]295 bull2
[(In models using more than one code segment \(medium, large and huge\), functions are far. This)]278 bull1
[(means that function pointers are 32 bits long \(consisting of a 16-bit offset followed by a 16-bit)]267 bull0
[(segment\), and that functions are called using )2(CALL FAR)0( \(or )2(CALL seg:offset)0(\) and return)]256 bull0
[(using )2(RETF)0(. Again, you should therefore write your own routines to return with )2(RETF)0( and use)]245 bull0
[2(CALL FAR)0( to call external routines.)]234 bull2
[(In models using a single data segment \(tiny, small and medium\), data pointers are 16 bits long,)]217 bull1
[(containing only an offset field \(the )2(DS)0( register doesn't change its value, and always gives the)]206 bull0
[(segment part of the full data item address\).)]195 bull2
[(In models using more than one data segment \(compact, large and huge\), data pointers are 32 bits)]178 bull1
[(long, consisting of a 16-bit offset followed by a 16-bit segment. You should still be careful not)]167 bull0
[(to modify )2(DS)0( in your routines without restoring it afterwards, but )2(ES)0( is free for you to use to)]156 bull0
[(access the contents of 32-bit data pointers you are passed.)]145 bull2
[(The huge memory model allows single data items to exceed 64K in size. In all other memory)]128 bull1
[(models, you can access the whole of a data item just by doing arithmetic on the offset field of the)]117 bull0
(86)pageeven
restore showpage
%%Page: 87 87
%%BeginPageSetup
save
%%EndPageSetup
/87 pa
[(pointer you are given, whether a segment field is present or not; in huge model, you have to be)]681 bull0
[(more careful of your pointer arithmetic.)]670 bull2
[(In most memory models, there is a )1(default)0( data segment, whose segment address is kept in )2(DS)]653 bull1
[(throughout the program. This data segment is typically the same segment as the stack, kept in )2(SS)0(,)]642 bull0
[(so that functions' local variables \(which are stored on the stack\) and global data items can both)]631 bull0
[(be accessed easily without changing )2(DS)0(. Particularly large data items are typically stored in other)]620 bull0
[(segments. However, some memory models \(though not the standard ones, usually\) allow the)]609 bull0
[(assumption that )2(SS)0( and )2(DS)0( hold the same value to be removed. Be careful about functions' local)]598 bull0
[(variables in this latter case.)]587 bull2
[(In models with a single code segment, the segment is called )2(_TEXT)0(, so your code segment must)]570 norm1
[(also go by this name in order to be linked into the same place as the main code segment. In models)]559 norm0
[(with a single data segment, or with a default data segment, it is called )2(_DATA)0(.)]548 norm2
[{/section-7.4.3 xa}(Function Definitions and Function Calls)](7.4.3)530 subh3
[(The )(C calling convention in 16-bit programs is as follows. In the following description, the words)]513 norm1
[1(caller)0( and )1(callee)0( are used to denote the function doing the calling and the function which gets called.)]502 norm2
[(The caller pushes the function's parameters on the stack, one after another, in reverse order \(right)]485 bull1
[(to left, so that the first argument specified to the function is pushed last\).)]474 bull2
[(The caller then executes a )2(CALL)0( instruction to pass control to the callee. This )2(CALL)0( is either near)]457 bull1
[(or far depending on the memory model.)]446 bull2
[(The callee receives control, and typically \(although this is not actually necessary, in functions)]429 bull1
[(which do not need to access their parameters\) starts by saving the value of )2(SP)0( in )2(BP)0( so as to be)]418 bull0
[(able to use )2(BP)0( as a base pointer to find its parameters on the stack. However, the caller was)]407 bull0
[(probably doing this too, so part of the calling convention states that )2(BP)0( must be preserved by any)]396 bull0
[(C function. Hence the callee, if it is going to set up )2(BP)0( as a )1(frame pointer)0(, must push the previous)]385 bull0
[(value first.)]374 bull2
[(The callee may then access its parameters relative to )2(BP)0(. The word at )2([BP])0( holds the previous)]357 bull1
[(value of )2(BP)0( as it was pushed; the next word, at )2([BP+2])0(, holds the offset part of the return)]346 bull0
[(address, pushed implicitly by )2(CALL)0(. In a small-model \(near\) function, the parameters start after)]335 bull0
[(that, at )2([BP+4])0(; in a large-model \(far\) function, the segment part of the return address lives at)]324 bull0
[2([BP+4])0(, and the parameters begin at )2([BP+6])0(. The leftmost parameter of the function, since it)]313 bull0
[(was pushed last, is accessible at this offset from )2(BP)0(; the others follow, at successively greater)]302 bull0
[(offsets. Thus, in a function such as )2(printf)0( which takes a variable number of parameters, the)]291 bull0
[(pushing of the parameters in reverse order means that the function knows where to find its first)]280 bull0
[(parameter, which tells it the number and type of the remaining ones.)]269 bull2
[(The callee may also wish to decrease )2(SP)0( further, so as to allocate space on the stack for local)]252 bull1
[(variables, which will then be accessible at negative offsets from )2(BP)0(.)]241 bull2
[(The callee, if it wishes to return a value to the caller, should leave the value in )2(AL)0(, )2(AX)0( or )2(DX:AX)]224 bull1
[(depending on the size of the value. Floating-point results are sometimes \(depending on the)]213 bull0
[(compiler\) returned in )2(ST0)0(.)]202 bull2
[(Once the callee has finished processing, it restores )2(SP)0( from )2(BP)0( if it had allocated local stack)]185 bull1
[(space, then pops the previous value of )2(BP)0(, and returns via )2(RETN)0( or )2(RETF)0( depending on memory)]174 bull0
[(model.)]163 bull2
[(When the caller regains control from the callee, the function parameters are still on the stack, so)]146 bull1
[(it typically adds an immediate constant to )2(SP)0( to remove them \(instead of executing a number of)]135 bull0
[(slow )2(POP)0( instructions\). Thus, if a function is accidentally called with the wrong number of)]124 bull0
[(parameters due to a prototype mismatch, the stack will still be returned to a sensible state since)]113 bull0
[(the caller, which )1(knows)0( how many parameters it pushed, does the removing.)]102 bull2
(87)pageodd
restore showpage
%%Page: 88 88
%%BeginPageSetup
save
%%EndPageSetup
/88 pa
[(It is instructive to compare this calling convention with that for Pascal programs \(described in)]681 norm1
[{/section-7.5.1 xl}(section 7.5.1){el}(\). Pascal has a simpler convention, since no functions have variable numbers of)]670 norm0
[(parameters. Therefore the callee knows how many parameters it should have been passed, and is)]659 norm0
[(able to deallocate them from the stack itself by passing an immediate argument to the )2(RET)0( or )2(RETF)]648 norm0
[(instruction, so the caller does not have to do it. Also, the parameters are pushed in left-to-right)]637 norm0
[(order, not right-to-left, which means that a compiler can give better guarantees about sequence)]626 norm0
[(points without performance suffering.)]615 norm2
[(Thus, you would define a function in C style in the following way. The following example is for)]598 norm1
[(small model:)]587 norm2
[2(global  _myfunc )]570 code1
[2()]559 code0
[2(_myfunc: )]548 code0
[2(        push    bp )]537 code0
[2(        mov     bp,sp )]526 code0
[2(        sub     sp,0x40         ; 64 bytes of local stack space )]515 code0
[2(        mov     bx,[bp+4]       ; first parameter to function )]504 code0
[2()]493 code0
[2(        ; some more code )]482 code0
[2()]471 code0
[2(        mov     sp,bp           ; undo "sub sp,0x40" above )]460 code0
[2(        pop     bp )]449 code0
[2(        ret)]438 code2
[(For a large-model function, you would replace )2(RET)0( by )2(RETF)0(, and look for the first parameter at)]421 norm1
[2([BP+6])0( instead of )2([BP+4])0(. Of course, if one of the parameters is a pointer, then the offsets of)]410 norm0
[1(subsequent)0( parameters will change depending on the memory model as well: far pointers take up)]399 norm0
[(four bytes on the stack when passed as a parameter, whereas near pointers take up two.)]388 norm2
[(At the other end of the process, to call a C function from your assembly code, you would do)]371 norm1
[(something like this:)]360 norm2
[2(extern  _printf )]343 code1
[2()]332 code0
[2(      ; and then, further down... )]321 code0
[2()]310 code0
[2(      push    word [myint]        ; one of my integer variables )]299 code0
[2(      push    word mystring       ; pointer into my data segment )]288 code0
[2(      call    _printf )]277 code0
[2(      add     sp,byte 4           ; `byte' saves space )]266 code0
[2()]255 code0
[2(      ; then those data items... )]244 code0
[2()]233 code0
[2(segment _DATA )]222 code0
[2()]211 code0
[2(myint         dw    1234 )]200 code0
[2(mystring      db    'This number -> %d <- should be 1234',10,0)]189 code2
[(This piece of code is the small-model assembly equivalent of the C code)]172 norm3
[2(    int myint = 1234; )]155 code1
[2(    printf\("This number -> %d <- should be 1234\\\\n", myint\);)]144 code2
[(In large model, the function-call code might look more like this. In this example, it is assumed that)]127 norm1
[2(DS)0( already holds the segment base of the segment )2(_DATA)0(. If not, you would have to initialise it)]116 norm0
[(first.)]105 norm2
(88)pageeven
restore showpage
%%Page: 89 89
%%BeginPageSetup
save
%%EndPageSetup
/89 pa
[2(      push    word [myint] )]681 code1
[2(      push    word seg mystring   ; Now push the segment, and... )]670 code0
[2(      push    word mystring       ; ... offset of "mystring" )]659 code0
[2(      call    far _printf )]648 code0
[2(      add    sp,byte 6)]637 code2
[(The integer value still takes up one word on the stack, since large model does not affect the size of)]620 norm1
[(the )2(int)0( data type. The first argument \(pushed last\) to )2(printf)0(, however, is a data pointer, and)]609 norm0
[(therefore has to contain a segment and offset part. The segment should be stored second in memory,)]598 norm0
[(and therefore must be pushed first. \(Of course, )2(PUSH DS)0( would have been a shorter instruction)]587 norm0
[(than )2(PUSH WORD SEG mystring)0(, if )2(DS)0( was set up as the above example assumed.\) Then the)]576 norm0
[(actual call becomes a far call, since functions expect far calls in large model; and )2(SP)0( has to be)]565 norm0
[(increased by 6 rather than 4 afterwards to make up for the extra word of parameters.)]554 norm2
[{/section-7.4.4 xa}(Accessing Data Items)](7.4.4)536 subh3
[(To get at the contents of C variables, or to declare variables which C can access, you need only)]519 norm1
[(declare the names as )2(GLOBAL)0( or )2(EXTERN)0(. \(Again, the names require leading underscores, as stated)]508 norm0
[(in ){/section-7.4.1 xl}(section 7.4.1){el}(.\) Thus, a C variable declared as )2(int i)0( can be accessed from assembler as)]497 norm2
[2(extern _i )]480 code1
[2()]469 code0
[2(        mov ax,[_i])]458 code2
[(And to declare your own integer variable which C programs can access as )2(extern int j)0(, you)]441 norm1
[(do this \(making sure you are assembling in the )2(_DATA)0( segment, if necessary\):)]430 norm2
[2(global  _j )]413 code1
[2()]402 code0
[2(_j      dw      0)]391 code2
[(To access a C array, you need to know the size of the components of the array. For example, )2(int)]374 norm1
[(variables are two bytes long, so if a C program declares an array as )2(int a[10])0(, you can access)]363 norm0
[2(a[3])0( by coding )2(mov ax,[_a+6])0(. \(The byte offset 6 is obtained by multiplying the desired array)]352 norm0
[(index, 3, by the size of the array element, 2.\) The sizes of the C base types in 16-bit compilers are:)]341 norm0
[(1 for )2(char)0(, 2 for )2(short)0( and )2(int)0(, 4 for )2(long)0( and )2(float)0(, and 8 for )2(double)0(.)]330 norm2
[(To access a C )(data structure, you need to know the offset from the base of the structure to the field)]313 norm1
[(you are interested in. You can either do this by converting the C structure definition into a NASM)]302 norm0
[(structure definition \(using )2(STRUC)0(\), or by calculating the one offset and using just that.)]291 norm2
[(To do either of these, you should read your C compiler's manual to find out how it organises data)]274 norm1
[(structures. NASM gives no special alignment to structure members in its own )2(STRUC)0( macro, so you)]263 norm0
[(have to specify alignment yourself if the C compiler generates it. Typically, you might find that a)]252 norm0
[(structure like)]241 norm2
[2(struct @\\{ )]224 code1
[2(    char c; )]213 code0
[2(    int i; )]202 code0
[2(@\\} foo;)]191 code2
[(might be four bytes long rather than three, since the )2(int)0( field would be aligned to a two-byte)]174 norm1
[(boundary. However, this sort of feature tends to be a configurable option in the C compiler, either)]163 norm0
[(using command-line options or )2(#pragma)0( lines, so you have to find out how your own compiler)]152 norm0
[(does it.)]141 norm2
(89)pageodd
restore showpage
%%Page: 90 90
%%BeginPageSetup
save
%%EndPageSetup
/90 pa
[{/section-7.4.5 xa}2(c16.mac)0(: Helper Macros for the 16-bit C Interface)](7.4.5)680 subh3
[(Included in the NASM archives, in the )2(misc)0( directory, is a file )2(c16.mac)0( of macros. It defines)]663 norm1
[(three macros: )2(proc)0(, )2(arg)0( and )2(endproc)0(. These are intended to be used for C-style procedure)]652 norm0
[(definitions, and they automate a lot of the work involved in keeping track of the calling convention.)]641 norm2
[(\(An alternative, TASM compatible form of )2(arg)0( is also now built into NASM's preprocessor. See)]624 norm1
[{/section-4.9 xl}(section 4.9){el}( for details.\))]613 norm2
[(An example of an assembly function using the macro set is given here:)]596 norm3
[2(proc    _nearproc )]579 code1
[2()]568 code0
[2(%$i     arg )]557 code0
[2(%$j     arg )]546 code0
[2(        mov     ax,[bp + %$i] )]535 code0
[2(        mov     bx,[bp + %$j] )]524 code0
[2(        add     ax,[bx] )]513 code0
[2()]502 code0
[2(endproc)]491 code2
[(This defines )2(_nearproc)0( to be a procedure taking two arguments, the first \()2(i)0(\) an integer and the)]474 norm1
[(second \()2(j)0(\) a pointer to an integer. It returns )2(i + *j)0(.)]463 norm2
[(Note that the )2(arg)0( macro has an )2(EQU)0( as the first line of its expansion, and since the label before the)]446 norm1
[(macro call gets prepended to the first line of the expanded macro, the )2(EQU)0( works, defining )2(%$i)0( to)]435 norm0
[(be an offset from )2(BP)0(. A context-local variable is used, local to the context pushed by the )2(proc)]424 norm0
[(macro and popped by the )2(endproc)0( macro, so that the same argument name can be used in later)]413 norm0
[(procedures. Of course, you don't )1(have)0( to do that.)]402 norm2
[(The macro set produces code for near functions \(tiny, small and compact-model code\) by default.)]385 norm1
[(You can have it generate far functions \(medium, large and huge-model code\) by means of coding)]374 norm0
[2(%define FARCODE)0(. This changes the kind of return instruction generated by )2(endproc)0(, and also)]363 norm0
[(changes the starting point for the argument offsets. The macro set contains no intrinsic dependency)]352 norm0
[(on whether data pointers are far or not.)]341 norm2
[2(arg)0( can take an optional parameter, giving the size of the argument. If no size is given, 2 is)]324 norm1
[(assumed, since it is likely that many function parameters will be of type )2(int)0(.)]313 norm2
[(The large-model equivalent of the above function would look like this:)]296 norm3
[2(%define FARCODE )]279 code1
[2()]268 code0
[2(proc    _farproc )]257 code0
[2()]246 code0
[2(%$i     arg )]235 code0
[2(%$j     arg     4 )]224 code0
[2(        mov     ax,[bp + %$i] )]213 code0
[2(        mov     bx,[bp + %$j] )]202 code0
[2(        mov     es,[bp + %$j + 2] )]191 code0
[2(        add     ax,[bx] )]180 code0
[2()]169 code0
[2(endproc)]158 code2
[(This makes use of the argument to the )2(arg)0( macro to define a parameter of size 4, because )2(j)0( is now)]141 norm1
[(a far pointer. When we load from )2(j)0(, we must load a segment and an offset.)]130 norm2
(90)pageeven
restore showpage
%%Page: 91 91
%%BeginPageSetup
save
%%EndPageSetup
/91 pa
[{/section-7.5 xa}(Interfacing to )(Borland Pascal Programs)](7.5)678 head3
[(Interfacing to Borland Pascal programs is similar in concept to interfacing to 16-bit C programs.)]661 norm1
[(The differences are:)]650 norm2
[(The leading underscore required for interfacing to C programs is not required for Pascal.)]633 bull3
[(The memory model is always large: functions are far, data pointers are far, and no data item can)]616 bull1
[(be more than 64K long. \(Actually, some functions are near, but only those functions that are local)]605 bull0
[(to a Pascal unit and never called from outside it. All assembly functions that Pascal calls, and all)]594 bull0
[(Pascal functions that assembly routines are able to call, are far.\) However, all static data declared)]583 bull0
[(in a Pascal program goes into the default data segment, which is the one whose segment address)]572 bull0
[(will be in )2(DS)0( when control is passed to your assembly code. The only things that do not live in)]561 bull0
[(the default data segment are local variables \(they live in the stack segment\) and dynamically)]550 bull0
[(allocated variables. All data )1(pointers)0(, however, are far.)]539 bull2
[(The function calling convention is different \226 described below.)]522 bull3
[(Some data types, such as strings, are stored differently.)]505 bull3
[(There are restrictions on the segment names you are allowed to use \226 Borland Pascal will ignore)]488 bull1
[(code or data declared in a segment it doesn't like the name of. The restrictions are described)]477 bull0
[(below.)]466 bull2
[{/section-7.5.1 xa}(The Pascal Calling Convention)](7.5.1)448 subh3
[(The 16-bit Pascal calling convention is as follows. In the following description, the words )1(caller)]431 norm1
[(and )1(callee)0( are used to denote the function doing the calling and the function which gets called.)]420 norm2
[(The caller pushes the function's parameters on the stack, one after another, in normal order \(left)]403 bull1
[(to right, so that the first argument specified to the function is pushed first\).)]392 bull2
[(The caller then executes a far )2(CALL)0( instruction to pass control to the callee.)]375 bull3
[(The callee receives control, and typically \(although this is not actually necessary, in functions)]358 bull1
[(which do not need to access their parameters\) starts by saving the value of )2(SP)0( in )2(BP)0( so as to be)]347 bull0
[(able to use )2(BP)0( as a base pointer to find its parameters on the stack. However, the caller was)]336 bull0
[(probably doing this too, so part of the calling convention states that )2(BP)0( must be preserved by any)]325 bull0
[(function. Hence the callee, if it is going to set up )2(BP)0( as a )(frame pointer, must push the previous)]314 bull0
[(value first.)]303 bull2
[(The callee may then access its parameters relative to )2(BP)0(. The word at )2([BP])0( holds the previous)]286 bull1
[(value of )2(BP)0( as it was pushed. The next word, at )2([BP+2])0(, holds the offset part of the return)]275 bull0
[(address, and the next one at )2([BP+4])0( the segment part. The parameters begin at )2([BP+6])0(. The)]264 bull0
[(rightmost parameter of the function, since it was pushed last, is accessible at this offset from )2(BP)0(;)]253 bull0
[(the others follow, at successively greater offsets.)]242 bull2
[(The callee may also wish to decrease )2(SP)0( further, so as to allocate space on the stack for local)]225 bull1
[(variables, which will then be accessible at negative offsets from )2(BP)0(.)]214 bull2
[(The callee, if it wishes to return a value to the caller, should leave the value in )2(AL)0(, )2(AX)0( or )2(DX:AX)]197 bull1
[(depending on the size of the value. Floating-point results are returned in )2(ST0)0(. Results of type)]186 bull0
[2(Real)0( \(Borland's own custom floating-point data type, not handled directly by the FPU\) are)]175 bull0
[(returned in )2(DX:BX:AX)0(. To return a result of type )2(String)0(, the caller pushes a pointer to a)]164 bull0
[(temporary string before pushing the parameters, and the callee places the returned string value at)]153 bull0
[(that location. The pointer is not a parameter, and should not be removed from the stack by the)]142 bull0
[2(RETF)0( instruction.)]131 bull2
[(Once the callee has finished processing, it restores )2(SP)0( from )2(BP)0( if it had allocated local stack)]114 bull1
[(space, then pops the previous value of )2(BP)0(, and returns via )2(RETF)0(. It uses the form of )2(RETF)0( with)]103 bull0
(91)pageodd
restore showpage
%%Page: 92 92
%%BeginPageSetup
save
%%EndPageSetup
/92 pa
[(an immediate parameter, giving the number of bytes taken up by the parameters on the stack.)]681 bull0
[(This causes the parameters to be removed from the stack as a side effect of the return instruction.)]670 bull2
[(When the caller regains control from the callee, the function parameters have already been)]653 bull1
[(removed from the stack, so it needs to do nothing further.)]642 bull2
[(Thus, you would define a function in Pascal style, taking two )2(Integer)0(\226type parameters, in the)]625 norm1
[(following way:)]614 norm2
[2(global  myfunc )]597 code1
[2()]586 code0
[2(myfunc: push    bp )]575 code0
[2(        mov     bp,sp )]564 code0
[2(        sub     sp,0x40         ; 64 bytes of local stack space )]553 code0
[2(        mov     bx,[bp+8]       ; first parameter to function )]542 code0
[2(        mov     bx,[bp+6]       ; second parameter to function )]531 code0
[2()]520 code0
[2(        ; some more code )]509 code0
[2()]498 code0
[2(        mov     sp,bp           ; undo "sub sp,0x40" above )]487 code0
[2(        pop     bp )]476 code0
[2(        retf    4               ; total size of params is 4)]465 code2
[(At the other end of the process, to call a Pascal function from your assembly code, you would do)]448 norm1
[(something like this:)]437 norm2
[2(extern  SomeFunc )]420 code1
[2()]409 code0
[2(       ; and then, further down... )]398 code0
[2()]387 code0
[2(       push   word seg mystring   ; Now push the segment, and... )]376 code0
[2(       push   word mystring       ; ... offset of "mystring" )]365 code0
[2(       push   word [myint]        ; one of my variables )]354 code0
[2(       call   far SomeFunc)]343 code2
[(This is equivalent to the Pascal code)]326 norm3
[2(procedure SomeFunc\(String: PChar; Int: Integer\); )]309 code1
[2(    SomeFunc\(@@mystring, myint\);)]298 code2
[{/section-7.5.2 xa}(Borland Pascal )(Segment Name Restrictions)](7.5.2)280 subh3
[(Since Borland Pascal's internal unit file format is completely different from )2(OBJ)0(, it only makes a)]263 norm1
[(very sketchy job of actually reading and understanding the various information contained in a real)]252 norm0
[2(OBJ)0( file when it links that in. Therefore an object file intended to be linked to a Pascal program)]241 norm0
[(must obey a number of restrictions:)]230 norm2
[(Procedures and functions must be in a segment whose name is either )2(CODE)0(, )2(CSEG)0(, or something)]213 bull1
[(ending in )2(_TEXT)0(.)]202 bull2
[(Initialised data must be in a segment whose name is either )2(CONST)0( or something ending in)]185 bull1
[2(_DATA)0(.)]174 bull2
[(Uninitialised data must be in a segment whose name is either )2(DATA)0(, )2(DSEG)0(, or something ending)]157 bull1
[(in )2(_BSS)0(.)]146 bull2
[(Any other segments in the object file are completely ignored. )2(GROUP)0( directives and segment)]129 bull1
[(attributes are also ignored.)]118 bull2
(92)pageeven
restore showpage
%%Page: 93 93
%%BeginPageSetup
save
%%EndPageSetup
/93 pa
[{/section-7.5.3 xa}(Using )2(c16.mac)0( With Pascal Programs)](7.5.3)680 subh3
[(The )2(c16.mac)0( macro package, described in ){/section-7.4.5 xl}(section 7.4.5){el}(, can also be used to simplify writing)]663 norm1
[(functions to be called from Pascal programs, if you code )2(%define PASCAL)0(. This definition)]652 norm0
[(ensures that functions are far \(it implies )2(FARCODE)0(\), and also causes procedure return instructions to)]641 norm0
[(be generated with an operand.)]630 norm2
[(Defining )2(PASCAL)0( does not change the code which calculates the argument offsets; you must)]613 norm1
[(declare your function's arguments in reverse order. For example:)]602 norm2
[2(%define PASCAL )]585 code1
[2()]574 code0
[2(proc    _pascalproc )]563 code0
[2()]552 code0
[2(%$j     arg 4 )]541 code0
[2(%$i     arg )]530 code0
[2(        mov     ax,[bp + %$i] )]519 code0
[2(        mov     bx,[bp + %$j] )]508 code0
[2(        mov     es,[bp + %$j + 2] )]497 code0
[2(        add     ax,[bx] )]486 code0
[2()]475 code0
[2(endproc)]464 code2
[(This defines the same routine, conceptually, as the example in ){/section-7.4.5 xl}(section 7.4.5){el}(: it defines a function)]447 norm1
[(taking two arguments, an integer and a pointer to an integer, which returns the sum of the integer)]436 norm0
[(and the contents of the pointer. The only difference between this code and the large-model C)]425 norm0
[(version is that )2(PASCAL)0( is defined instead of )2(FARCODE)0(, and that the arguments are declared in)]414 norm0
[(reverse order.)]403 norm2
(93)pageodd
restore showpage
%%Page: 94 94
%%BeginPageSetup
save
%%EndPageSetup
/94 pa
[{/chapter-8 xa}(Chapter 8: Writing 32-bit Code \(Unix, Win32, DJGPP\))]644 chap3
[(This chapter attempts to cover some of the common issues involved when writing 32-bit code, to)]609 norm1
[(run under )(Win32 or Unix, or to be linked with C code generated by a Unix-style C compiler such)]598 norm0
[(as )(DJGPP. It covers how to write assembly code to interface with 32-bit C routines, and how to)]587 norm0
[(write position-independent code for shared libraries.)]576 norm2
[(Almost all 32-bit code, and in particular all code running under )2(Win32)0(, )2(DJGPP)0( or any of the PC)]559 norm1
[(Unix variants, runs in )1(flat)0( memory model. This means that the segment registers and paging have)]548 norm0
[(already been set up to give you the same 32-bit 4Gb address space no matter what segment you)]537 norm0
[(work relative to, and that you should ignore all segment registers completely. When writing)]526 norm0
[(flat-model application code, you never need to use a segment override or modify any segment)]515 norm0
[(register, and the code-section addresses you pass to )2(CALL)0( and )2(JMP)0( live in the same address space)]504 norm0
[(as the data-section addresses you access your variables by and the stack-section addresses you)]493 norm0
[(access local variables and procedure parameters by. Every address is 32 bits long and contains only)]482 norm0
[(an offset part.)]471 norm2
[{/section-8.1 xa}(Interfacing to 32-bit C Programs)](8.1)451 head3
[(A lot of the discussion in ){/section-7.4 xl}(section 7.4){el}(, about interfacing to 16-bit C programs, still applies when)]434 norm1
[(working in 32 bits. The absence of memory models or segmentation worries simplifies things a lot.)]423 norm2
[{/section-8.1.1 xa}(External Symbol Names)](8.1.1)405 subh3
[(Most 32-bit C compilers share the convention used by 16-bit compilers, that the names of all)]388 norm1
[(global symbols \(functions or data\) they define are formed by prefixing an underscore to the name as)]377 norm0
[(it appears in the C program. However, not all of them do: the )2(ELF)0( specification states that C)]366 norm0
[(symbols do )1(not)0( have a leading underscore on their assembly-language names.)]355 norm2
[(The older Linux )2(a.out)0( C compiler, all )2(Win32)0( compilers, )2(DJGPP)0(, and )2(NetBSD)0( and )2(FreeBSD)0(,)]338 norm1
[(all use the leading underscore; for these compilers, the macros )2(cextern)0( and )2(cglobal)0(, as given)]327 norm0
[(in ){/section-7.4.1 xl}(section 7.4.1){el}(, will still work. For )2(ELF)0(, though, the leading underscore should not be used.)]316 norm2
[(See also ){/section-2.1.21 xl}(section 2.1.21){el}(.)]299 norm3
[{/section-8.1.2 xa}(Function Definitions and Function Calls)](8.1.2)281 subh3
[(The )(C calling conventionThe C calling convention in 32-bit programs is as follows. In the)]264 norm1
[(following description, the words )1(caller)0( and )1(callee)0( are used to denote the function doing the calling)]253 norm0
[(and the function which gets called.)]242 norm2
[(The caller pushes the function's parameters on the stack, one after another, in reverse order \(right)]225 bull1
[(to left, so that the first argument specified to the function is pushed last\).)]214 bull2
[(The caller then executes a near )2(CALL)0( instruction to pass control to the callee.)]197 bull3
[(The callee receives control, and typically \(although this is not actually necessary, in functions)]180 bull1
[(which do not need to access their parameters\) starts by saving the value of )2(ESP)0( in )2(EBP)0( so as to)]169 bull0
[(be able to use )2(EBP)0( as a base pointer to find its parameters on the stack. However, the caller was)]158 bull0
[(probably doing this too, so part of the calling convention states that )2(EBP)0( must be preserved by)]147 bull0
[(any C function. Hence the callee, if it is going to set up )2(EBP)0( as a )(frame pointer, must push the)]136 bull0
[(previous value first.)]125 bull2
(94)pageeven
restore showpage
%%Page: 95 95
%%BeginPageSetup
save
%%EndPageSetup
/95 pa
[(The callee may then access its parameters relative to )2(EBP)0(. The doubleword at )2([EBP])0( holds the)]681 bull1
[(previous value of )2(EBP)0( as it was pushed; the next doubleword, at )2([EBP+4])0(, holds the return)]670 bull0
[(address, pushed implicitly by )2(CALL)0(. The parameters start after that, at )2([EBP+8])0(. The leftmost)]659 bull0
[(parameter of the function, since it was pushed last, is accessible at this offset from )2(EBP)0(; the)]648 bull0
[(others follow, at successively greater offsets. Thus, in a function such as )2(printf)0( which takes a)]637 bull0
[(variable number of parameters, the pushing of the parameters in reverse order means that the)]626 bull0
[(function knows where to find its first parameter, which tells it the number and type of the)]615 bull0
[(remaining ones.)]604 bull2
[(The callee may also wish to decrease )2(ESP)0( further, so as to allocate space on the stack for local)]587 bull1
[(variables, which will then be accessible at negative offsets from )2(EBP)0(.)]576 bull2
[(The callee, if it wishes to return a value to the caller, should leave the value in )2(AL)0(, )2(AX)0( or )2(EAX)]559 bull1
[(depending on the size of the value. Floating-point results are typically returned in )2(ST0)0(.)]548 bull2
[(Once the callee has finished processing, it restores )2(ESP)0( from )2(EBP)0( if it had allocated local stack)]531 bull1
[(space, then pops the previous value of )2(EBP)0(, and returns via )2(RET)0( \(equivalently, )2(RETN)0(\).)]520 bull2
[(When the caller regains control from the callee, the function parameters are still on the stack, so)]503 bull1
[(it typically adds an immediate constant to )2(ESP)0( to remove them \(instead of executing a number of)]492 bull0
[(slow )2(POP)0( instructions\). Thus, if a function is accidentally called with the wrong number of)]481 bull0
[(parameters due to a prototype mismatch, the stack will still be returned to a sensible state since)]470 bull0
[(the caller, which )1(knows)0( how many parameters it pushed, does the removing.)]459 bull2
[(There is an alternative calling convention used by Win32 programs for Windows API calls, and also)]442 norm1
[(for functions called )1(by)0( the Windows API such as window procedures: they follow what Microsoft)]431 norm0
[(calls the )2(__stdcall)0( convention. This is slightly closer to the Pascal convention, in that the callee)]420 norm0
[(clears the stack by passing a parameter to the )2(RET)0( instruction. However, the parameters are still)]409 norm0
[(pushed in right-to-left order.)]398 norm2
[(Thus, you would define a function in C style in the following way:)]381 norm3
[2(global  _myfunc )]364 code1
[2()]353 code0
[2(_myfunc: )]342 code0
[2(        push    ebp )]331 code0
[2(        mov     ebp,esp )]320 code0
[2(        sub     esp,0x40        ; 64 bytes of local stack space )]309 code0
[2(        mov     ebx,[ebp+8]     ; first parameter to function )]298 code0
[2()]287 code0
[2(        ; some more code )]276 code0
[2()]265 code0
[2(        leave                   ; mov esp,ebp / pop ebp )]254 code0
[2(        ret)]243 code2
[(At the other end of the process, to call a C function from your assembly code, you would do)]226 norm1
[(something like this:)]215 norm2
[2(extern  _printf )]198 code1
[2()]187 code0
[2(        ; and then, further down... )]176 code0
[2()]165 code0
[2(        push    dword [myint]   ; one of my integer variables )]154 code0
[2(        push    dword mystring  ; pointer into my data segment )]143 code0
[2(        call    _printf )]132 code0
[2(        add     esp,byte 8      ; `byte' saves space )]121 code0
[2()]110 code0
(95)pageodd
restore showpage
%%Page: 96 96
%%BeginPageSetup
save
%%EndPageSetup
/96 pa
[2(        ; then those data items... )]681 code0
[2()]670 code0
[2(segment _DATA )]659 code0
[2()]648 code0
[2(myint       dd   1234 )]637 code0
[2(mystring    db   'This number -> %d <- should be 1234',10,0)]626 code2
[(This piece of code is the assembly equivalent of the C code)]609 norm3
[2(    int myint = 1234; )]592 code1
[2(    printf\("This number -> %d <- should be 1234\\\\n", myint\);)]581 code2
[{/section-8.1.3 xa}(Accessing Data Items)](8.1.3)563 subh3
[(To get at the contents of C variables, or to declare variables which C can access, you need only)]546 norm1
[(declare the names as )2(GLOBAL)0( or )2(EXTERN)0(. \(Again, the names require leading underscores, as stated)]535 norm0
[(in ){/section-8.1.1 xl}(section 8.1.1){el}(.\) Thus, a C variable declared as )2(int i)0( can be accessed from assembler as)]524 norm2
[2(          extern _i )]507 code1
[2(          mov eax,[_i])]496 code2
[(And to declare your own integer variable which C programs can access as )2(extern int j)0(, you)]479 norm1
[(do this \(making sure you are assembling in the )2(_DATA)0( segment, if necessary\):)]468 norm2
[2(          global _j )]451 code1
[2(_j        dd 0)]440 code2
[(To access a C array, you need to know the size of the components of the array. For example, )2(int)]423 norm1
[(variables are four bytes long, so if a C program declares an array as )2(int a[10])0(, you can access)]412 norm0
[2(a[3])0( by coding )2(mov ax,[_a+12])0(. \(The byte offset 12 is obtained by multiplying the desired)]401 norm0
[(array index, 3, by the size of the array element, 4.\) The sizes of the C base types in 32-bit compilers)]390 norm0
[(are: 1 for )2(char)0(, 2 for )2(short)0(, 4 for )2(int)0(, )2(long)0( and )2(float)0(, and 8 for )2(double)0(. Pointers, being)]379 norm0
[(32-bit addresses, are also 4 bytes long.)]368 norm2
[(To access a C )(data structure, you need to know the offset from the base of the structure to the field)]351 norm1
[(you are interested in. You can either do this by converting the C structure definition into a NASM)]340 norm0
[(structure definition \(using )2(STRUC)0(\), or by calculating the one offset and using just that.)]329 norm2
[(To do either of these, you should read your C compiler's manual to find out how it organises data)]312 norm1
[(structures. NASM gives no special alignment to structure members in its own )2(STRUC)0( macro, so you)]301 norm0
[(have to specify alignment yourself if the C compiler generates it. Typically, you might find that a)]290 norm0
[(structure like)]279 norm2
[2(struct @\\{ )]262 code1
[2(    char c; )]251 code0
[2(    int i; )]240 code0
[2(@\\} foo;)]229 code2
[(might be eight bytes long rather than five, since the )2(int)0( field would be aligned to a four-byte)]212 norm1
[(boundary. However, this sort of feature is sometimes a configurable option in the C compiler, either)]201 norm0
[(using command-line options or )2(#pragma)0( lines, so you have to find out how your own compiler)]190 norm0
[(does it.)]179 norm2
[{/section-8.1.4 xa}2(c32.mac)0(: Helper Macros for the 32-bit C Interface)](8.1.4)161 subh3
[(Included in the NASM archives, in the )2(misc)0( directory, is a file )2(c32.mac)0( of macros. It defines)]144 norm1
[(three macros: )2(proc)0(, )2(arg)0( and )2(endproc)0(. These are intended to be used for C-style procedure)]133 norm0
[(definitions, and they automate a lot of the work involved in keeping track of the calling convention.)]122 norm2
[(An example of an assembly function using the macro set is given here:)]105 norm3
(96)pageeven
restore showpage
%%Page: 97 97
%%BeginPageSetup
save
%%EndPageSetup
/97 pa
[2(proc    _proc32 )]681 code1
[2()]670 code0
[2(%$i     arg )]659 code0
[2(%$j     arg )]648 code0
[2(        mov     eax,[ebp + %$i] )]637 code0
[2(        mov     ebx,[ebp + %$j] )]626 code0
[2(        add     eax,[ebx] )]615 code0
[2()]604 code0
[2(endproc)]593 code2
[(This defines )2(_proc32)0( to be a procedure taking two arguments, the first \()2(i)0(\) an integer and the)]576 norm1
[(second \()2(j)0(\) a pointer to an integer. It returns )2(i + *j)0(.)]565 norm2
[(Note that the )2(arg)0( macro has an )2(EQU)0( as the first line of its expansion, and since the label before the)]548 norm1
[(macro call gets prepended to the first line of the expanded macro, the )2(EQU)0( works, defining )2(%$i)0( to)]537 norm0
[(be an offset from )2(BP)0(. A context-local variable is used, local to the context pushed by the )2(proc)]526 norm0
[(macro and popped by the )2(endproc)0( macro, so that the same argument name can be used in later)]515 norm0
[(procedures. Of course, you don't )1(have)0( to do that.)]504 norm2
[2(arg)0( can take an optional parameter, giving the size of the argument. If no size is given, 4 is)]487 norm1
[(assumed, since it is likely that many function parameters will be of type )2(int)0( or pointers.)]476 norm2
[{/section-8.2 xa}(Writing NetBSD/FreeBSD/OpenBSD and Linux/ELF )(Shared Libraries)](8.2)456 head3
[2(ELF)0( replaced the older )2(a.out)0( object file format under Linux because it contains support for)]439 norm1
[(position-independent code \()(PIC\), which makes writing shared libraries much easier. NASM)]428 norm0
[(supports the )2(ELF)0( position-independent code features, so you can write Linux )2(ELF)0( shared libraries)]417 norm0
[(in NASM.)]406 norm2
[(NetBSD, and its close cousins )(FreeBSD and )(OpenBSD, take a different approach by hacking PIC)]389 norm1
[(support into the )2(a.out)0( format. NASM supports this as the )2(aoutb)0( output format, so you can write)]378 norm0
[(BSD shared libraries in NASM too.)]367 norm2
[(The operating system loads a PIC shared library by memory-mapping the library file at an)]350 norm1
[(arbitrarily chosen point in the address space of the running process. The contents of the library's)]339 norm0
[(code section must therefore not depend on where it is loaded in memory.)]328 norm2
[(Therefore, you cannot get at your variables by writing code like this:)]311 norm3
[2(        mov     eax,[myvar]             ; WRONG)]294 code3
[(Instead, the linker provides an area of memory called the )1(global offset table)0(, or )(GOT; the GOT is)]277 norm1
[(situated at a constant distance from your library's code, so if you can find out where your library is)]266 norm0
[(loaded \(which is typically done using a )2(CALL)0( and )2(POP)0( combination\), you can obtain the address of)]255 norm0
[(the GOT, and you can then load the addresses of your variables out of linker-generated entries in)]244 norm0
[(the GOT.)]233 norm2
[(The )1(data)0( section of a PIC shared library does not have these restrictions: since the data section is)]216 norm1
[(writable, it has to be copied into memory anyway rather than just paged in from the library file, so)]205 norm0
[(as long as it's being copied it can be relocated too. So you can put ordinary types of relocation in)]194 norm0
[(the data section without too much worry \(but see ){/section-8.2.4 xl}(section 8.2.4){el}( for a caveat\).)]183 norm2
[{/section-8.2.1 xa}(Obtaining the Address of the GOT)](8.2.1)165 subh3
[(Each code module in your shared library should define the GOT as an external symbol:)]148 norm3
[2(extern  _GLOBAL_OFFSET_TABLE_   ; in ELF )]131 code1
[2(extern  __GLOBAL_OFFSET_TABLE_  ; in BSD a.out)]120 code2
(97)pageodd
restore showpage
%%Page: 98 98
%%BeginPageSetup
save
%%EndPageSetup
/98 pa
[(At the beginning of any function in your shared library which plans to access your data or BSS)]681 norm1
[(sections, you must first calculate the address of the GOT. This is typically done by writing the)]670 norm0
[(function in this form:)]659 norm2
[2(func:   push    ebp )]642 code1
[2(        mov     ebp,esp )]631 code0
[2(        push    ebx )]620 code0
[2(        call    .get_GOT )]609 code0
[2(.get_GOT: )]598 code0
[2(        pop     ebx )]587 code0
[2(        add     ebx,_GLOBAL_OFFSET_TABLE_+$$-.get_GOT wrt ..gotpc )]576 code0
[2()]565 code0
[2(        ; the function body comes here )]554 code0
[2()]543 code0
[2(        mov     ebx,[ebp-4] )]532 code0
[2(        mov     esp,ebp )]521 code0
[2(        pop     ebp )]510 code0
[2(        ret)]499 code2
[(\(For BSD, again, the symbol )2(_GLOBAL_OFFSET_TABLE)0( requires a second leading underscore.\))]482 norm3
[(The first two lines of this function are simply the standard C prologue to set up a stack frame, and)]465 norm1
[(the last three lines are standard C function epilogue. The third line, and the fourth to last line, save)]454 norm0
[(and restore the )2(EBX)0( register, because PIC shared libraries use this register to store the address of the)]443 norm0
[(GOT.)]432 norm2
[(The interesting bit is the )2(CALL)0( instruction and the following two lines. The )2(CALL)0( and )2(POP)]415 norm1
[(combination obtains the address of the label )2(.get_GOT)0(, without having to know in advance where)]404 norm0
[(the program was loaded \(since the )2(CALL)0( instruction is encoded relative to the current position\). The)]393 norm0
[2(ADD)0( instruction makes use of one of the special PIC relocation types: )(GOTPC relocation. With the)]382 norm0
[2(WRT ..gotpc)0( qualifier specified, the symbol referenced \(here )2(_GLOBAL_OFFSET_TABLE_)0(,)]371 norm0
[(the special symbol assigned to the GOT\) is given as an offset from the beginning of the section.)]360 norm0
[(\(Actually, )2(ELF)0( encodes it as the offset from the operand field of the )2(ADD)0( instruction, but NASM)]349 norm0
[(simplifies this deliberately, so you do things the same way for both )2(ELF)0( and )2(BSD)0(.\) So the)]338 norm0
[(instruction then )1(adds)0( the beginning of the section, to get the real address of the GOT, and subtracts)]327 norm0
[(the value of )2(.get_GOT)0( which it knows is in )2(EBX)0(. Therefore, by the time that instruction has)]316 norm0
[(finished, )2(EBX)0( contains the address of the GOT.)]305 norm2
[(If you didn't follow that, don't worry: it's never necessary to obtain the address of the GOT by any)]288 norm1
[(other means, so you can put those three instructions into a macro and safely ignore them:)]277 norm2
[2(%macro  get_GOT 0 )]260 code1
[2()]249 code0
[2(        call    %%getgot )]238 code0
[2(  %%getgot: )]227 code0
[2(        pop     ebx )]216 code0
[2(        add     ebx,_GLOBAL_OFFSET_TABLE_+$$-%%getgot wrt ..gotpc )]205 code0
[2()]194 code0
[2(%endmacro)]183 code2
[{/section-8.2.2 xa}(Finding Your Local Data Items)](8.2.2)165 subh3
[(Having got the GOT, you can then use it to obtain the addresses of your data items. Most variables)]148 norm1
[(will reside in the sections you have declared; they can be accessed using the )2(..gotoff)0( special)]137 norm0
[2(WRT)0( type. The way this works is like this:)]126 norm2
[2(        lea     eax,[ebx+myvar wrt ..gotoff])]109 code3
(98)pageeven
restore showpage
%%Page: 99 99
%%BeginPageSetup
save
%%EndPageSetup
/99 pa
[(The expression )2(myvar wrt ..gotoff)0( is calculated, when the shared library is linked, to be the)]681 norm1
[(offset to the local variable )2(myvar)0( from the beginning of the GOT. Therefore, adding it to )2(EBX)0( as)]670 norm0
[(above will place the real address of )2(myvar)0( in )2(EAX)0(.)]659 norm2
[(If you declare variables as )2(GLOBAL)0( without specifying a size for them, they are shared between)]642 norm1
[(code modules in the library, but do not get exported from the library to the program that loaded it.)]631 norm0
[(They will still be in your ordinary data and BSS sections, so you can access them in the same way)]620 norm0
[(as local variables, using the above )2(..gotoff)0( mechanism.)]609 norm2
[(Note that due to a peculiarity of the way BSD )2(a.out)0( format handles this relocation type, there)]592 norm1
[(must be at least one non-local symbol in the same section as the address you're trying to access.)]581 norm2
[{/section-8.2.3 xa}(Finding External and Common Data Items)](8.2.3)563 subh3
[(If your library needs to get at an external variable \(external to the )1(library)0(, not just to one of the)]546 norm1
[(modules within it\), you must use the )2(..got)0( type to get at it. The )2(..got)0( type, instead of giving)]535 norm0
[(you the offset from the GOT base to the variable, gives you the offset from the GOT base to a GOT)]524 norm0
[1(entry)0( containing the address of the variable. The linker will set up this GOT entry when it builds the)]513 norm0
[(library, and the dynamic linker will place the correct address in it at load time. So to obtain the)]502 norm0
[(address of an external variable )2(extvar)0( in )2(EAX)0(, you would code)]491 norm2
[2(        mov     eax,[ebx+extvar wrt ..got])]474 code3
[(This loads the address of )2(extvar)0( out of an entry in the GOT. The linker, when it builds the shared)]457 norm1
[(library, collects together every relocation of type )2(..got)0(, and builds the GOT so as to ensure it has)]446 norm0
[(every necessary entry present.)]435 norm2
[(Common variables must also be accessed in this way.)]418 norm3
[{/section-8.2.4 xa}(Exporting Symbols to the Library User)](8.2.4)400 subh3
[(If you want to export symbols to the user of the library, you have to declare whether they are)]383 norm1
[(functions or data, and if they are data, you have to give the size of the data item. This is because the)]372 norm0
[(dynamic linker has to build )(procedure linkage table entries for any exported functions, and also)]361 norm0
[(moves exported data items away from the library's data section in which they were declared.)]350 norm2
[(So to export a function to users of the library, you must use)]333 norm3
[2(global  func:function           ; declare it as a function )]316 code1
[2()]305 code0
[2(func:   push    ebp )]294 code0
[2()]283 code0
[2(        ; etc.)]272 code2
[(And to export a data item such as an array, you would have to code)]255 norm3
[2(global  array:data array.end-array      ; give the size too )]238 code1
[2()]227 code0
[2(array:  resd    128 )]216 code0
[2(.end:)]205 code2
[(Be careful: If you export a variable to the library user, by declaring it as )2(GLOBAL)0( and supplying a)]188 norm1
[(size, the variable will end up living in the data section of the main program, rather than in your)]177 norm0
[(library's data section, where you declared it. So you will have to access your own global variable)]166 norm0
[(with the )2(..got)0( mechanism rather than )2(..gotoff)0(, as if it were external \(which, effectively, it has)]155 norm0
[(become\).)]144 norm2
[(Equally, if you need to store the address of an exported global in one of your data sections, you)]127 norm1
[(can't do it by means of the standard sort of code:)]116 norm2
(99)pageodd
restore showpage
%%Page: 100 100
%%BeginPageSetup
save
%%EndPageSetup
/100 pa
[2(dataptr:        dd      global_data_item        ; WRONG)]681 code3
[(NASM will interpret this code as an ordinary relocation, in which )2(global_data_item)0( is merely)]664 norm1
[(an offset from the beginning of the )2(.data)0( section \(or whatever\); so this reference will end up)]653 norm0
[(pointing at your data section instead of at the exported global which resides elsewhere.)]642 norm2
[(Instead of the above code, then, you must write)]625 norm3
[2(dataptr:        dd      global_data_item wrt ..sym)]608 code3
[(which makes use of the special )2(WRT)0( type )2(..sym)0( to instruct NASM to search the symbol table for a)]591 norm1
[(particular symbol at that address, rather than just relocating by section base.)]580 norm2
[(Either method will work for functions: referring to one of your functions by means of)]563 norm3
[2(funcptr:        dd      my_function)]546 code3
[(will give the user the address of the code you wrote, whereas)]529 norm3
[2(funcptr:        dd      my_function wrt .sym)]512 code3
[(will give the address of the procedure linkage table for the function, which is where the calling)]495 norm1
[(program will )1(believe)0( the function lives. Either address is a valid way to call the function.)]484 norm2
[{/section-8.2.5 xa}(Calling Procedures Outside the Library)](8.2.5)466 subh3
[(Calling procedures outside your shared library has to be done by means of a )1(procedure linkage)]449 norm1
[1(table)0(, or )(PLT. The PLT is placed at a known offset from where the library is loaded, so the library)]438 norm0
[(code can make calls to the PLT in a position-independent way. Within the PLT there is code to)]427 norm0
[(jump to offsets contained in the GOT, so function calls to other shared libraries or to routines in the)]416 norm0
[(main program can be transparently passed off to their real destinations.)]405 norm2
[(To call an external routine, you must use another special PIC relocation type, )2(WRT ..plt)0(. This is)]388 norm1
[(much easier than the GOT-based ones: you simply replace calls such as )2(CALL printf)0( with the)]377 norm0
[(PLT-relative version )2(CALL printf WRT ..plt)0(.)]366 norm2
[{/section-8.2.6 xa}(Generating the Library File)](8.2.6)348 subh3
[(Having written some code modules and assembled them to )2(.o)0( files, you then generate your shared)]331 norm1
[(library with a command such as)]320 norm2
[2(ld -shared -o library.so module1.o module2.o       # for ELF )]303 code1
[2(ld -Bshareable -o library.so module1.o module2.o   # for BSD)]292 code2
[(For ELF, if your shared library is going to reside in system directories such as )2(/usr/lib)0( or)]275 norm1
[2(/lib)0(, it is usually worth using the )2(-soname)0( flag to the linker, to store the final library file name,)]264 norm0
[(with a version number, into the library:)]253 norm2
[2(ld -shared -soname library.so.1 -o library.so.1.2 *.o)]236 code3
[(You would then copy )2(library.so.1.2)0( into the library directory, and create )2(library.so.1)]219 norm1
[(as a symbolic link to it.)]208 norm2
(100)pageeven
restore showpage
%%Page: 101 101
%%BeginPageSetup
save
%%EndPageSetup
/101 pa
[{/chapter-9 xa}(Chapter 9: Mixing 16 and 32 Bit Code)]644 chap3
[(This chapter tries to cover some of the issues, largely related to unusual forms of addressing and)]609 norm1
[(jump instructions, encountered when writing operating system code such as protected-mode)]598 norm0
[(initialisation routines, which require code that operates in mixed segment sizes, such as code in a)]587 norm0
[(16-bit segment trying to modify data in a 32-bit one, or jumps between different-size segments.)]576 norm2
[{/section-9.1 xa}(Mixed-Size Jumps)](9.1)556 head3
[(The most common form of )(mixed-size instruction is the one used when writing a 32-bit OS:)]539 norm1
[(having done your setup in 16-bit mode, such as loading the kernel, you then have to boot it by)]528 norm0
[(switching into protected mode and jumping to the 32-bit kernel start address. In a fully 32-bit OS,)]517 norm0
[(this tends to be the )1(only)0( mixed-size instruction you need, since everything before it can be done in)]506 norm0
[(pure 16-bit code, and everything after it can be pure 32-bit.)]495 norm2
[(This jump must specify a 48-bit far address, since the target segment is a 32-bit one. However, it)]478 norm1
[(must be assembled in a 16-bit segment, so just coding, for example,)]467 norm2
[2(        jmp     0x1234:0x56789ABC       ; wrong!)]450 code3
[(will not work, since the offset part of the address will be truncated to )2(0x9ABC)0( and the jump will be)]433 norm1
[(an ordinary 16-bit far one.)]422 norm2
[(The Linux kernel setup code gets round the inability of )2(as86)0( to generate the required instruction by)]405 norm1
[(coding it manually, using )2(DB)0( instructions. NASM can go one better than that, by actually generating)]394 norm0
[(the right instruction itself. Here's how to do it right:)]383 norm2
[2(        jmp     dword 0x1234:0x56789ABC         ; right)]366 code3
[(The )2(DWORD)0( prefix \(strictly speaking, it should come )1(after)0( the colon, since it is declaring the )1(offset)]349 norm1
[(field to be a doubleword; but NASM will accept either form, since both are unambiguous\) forces)]338 norm0
[(the offset part to be treated as far, in the assumption that you are deliberately writing a jump from a)]327 norm0
[(16-bit segment to a 32-bit one.)]316 norm2
[(You can do the reverse operation, jumping from a 32-bit segment to a 16-bit one, by means of the)]299 norm1
[2(WORD)0( prefix:)]288 norm2
[2(        jmp     word 0x8765:0x4321      ; 32 to 16 bit)]271 code3
[(If the )2(WORD)0( prefix is specified in 16-bit mode, or the )2(DWORD)0( prefix in 32-bit mode, they will be)]254 norm1
[(ignored, since each is explicitly forcing NASM into a mode it was in anyway.)]243 norm2
[{/section-9.2 xa}(Addressing Between Different-Size Segments)](9.2)223 head3
[(If your OS is mixed 16 and 32-bit, or if you are writing a DOS extender, you are likely to have to)]206 norm1
[(deal with some 16-bit segments and some 32-bit ones. At some point, you will probably end up)]195 norm0
[(writing code in a 16-bit segment which has to access data in a 32-bit segment, or vice versa.)]184 norm2
[(If the data you are trying to access in a 32-bit segment lies within the first 64K of the segment, you)]167 norm1
[(may be able to get away with using an ordinary 16-bit addressing operation for the purpose; but)]156 norm0
[(sooner or later, you will want to do 32-bit addressing from 16-bit mode.)]145 norm2
[(The easiest way to do this is to make sure you use a register for the address, since any effective)]128 norm1
[(address containing a 32-bit register is forced to be a 32-bit address. So you can do)]117 norm2
(101)pageodd
restore showpage
%%Page: 102 102
%%BeginPageSetup
save
%%EndPageSetup
/102 pa
[2(        mov     eax,offset_into_32_bit_segment_specified_by_fs )]681 code1
[2(        mov     dword [fs:eax],0x11223344)]670 code2
[(This is fine, but slightly cumbersome \(since it wastes an instruction and a register\) if you already)]653 norm1
[(know the precise offset you are aiming at. The x86 architecture does allow 32-bit effective)]642 norm0
[(addresses to specify nothing but a 4-byte offset, so why shouldn't NASM be able to generate the)]631 norm0
[(best instruction for the purpose?)]620 norm2
[(It can. As in ){/section-9.1 xl}(section 9.1){el}(, you need only prefix the address with the )2(DWORD)0( keyword, and it will be)]603 norm1
[(forced to be a 32-bit address:)]592 norm2
[2(        mov     dword [fs:dword my_offset],0x11223344)]575 code3
[(Also as in ){/section-9.1 xl}(section 9.1){el}(, NASM is not fussy about whether the )2(DWORD)0( prefix comes before or after)]558 norm1
[(the segment override, so arguably a nicer-looking way to code the above instruction is)]547 norm2
[2(        mov     dword [dword fs:my_offset],0x11223344)]530 code3
[(Don't confuse the )2(DWORD)0( prefix )1(outside)0( the square brackets, which controls the size of the data)]513 norm1
[(stored at the address, with the one )2(inside)0( the square brackets which controls the length of the)]502 norm0
[(address itself. The two can quite easily be different:)]491 norm2
[2(        mov     word [dword 0x12345678],0x9ABC)]474 code3
[(This moves 16 bits of data to an address specified by a 32-bit offset.)]457 norm3
[(You can also specify )2(WORD)0( or )2(DWORD)0( prefixes along with the )2(FAR)0( prefix to indirect far jumps or)]440 norm1
[(calls. For example:)]429 norm2
[2(        call    dword far [fs:word 0x4321])]412 code3
[(This instruction contains an address specified by a 16-bit offset; it loads a 48-bit far pointer from)]395 norm1
[(that \(16-bit segment and 32-bit offset\), and calls that address.)]384 norm2
[{/section-9.3 xa}(Other Mixed-Size Instructions)](9.3)364 head3
[(The other way you might want to access data might be using the string instructions \()2(LODSx)0(,)]347 norm1
[2(STOSx)0( and so on\) or the )2(XLATB)0( instruction. These instructions, since they take no parameters,)]336 norm0
[(might seem to have no easy way to make them perform 32-bit addressing when assembled in a)]325 norm0
[(16-bit segment.)]314 norm2
[(This is the purpose of NASM's )2(a16)0( and )2(a32)0( prefixes. If you are coding )2(LODSB)0( in a 16-bit)]297 norm1
[(segment but it is supposed to be accessing a string in a 32-bit segment, you should load the desired)]286 norm0
[(address into )2(ESI)0( and then code)]275 norm2
[2(        a32     lodsb)]258 code3
[(The prefix forces the addressing size to 32 bits, meaning that )2(LODSB)0( loads from )2([DS:ESI])]241 norm1
[(instead of )2([DS:SI])0(. To access a string in a 16-bit segment when coding in a 32-bit one, the)]230 norm0
[(corresponding )2(a16)0( prefix can be used.)]219 norm2
[(The )2(a16)0( and )2(a32)0( prefixes can be applied to any instruction in NASM's instruction table, but most)]202 norm1
[(of them can generate all the useful forms without them. The prefixes are necessary only for)]191 norm0
[(instructions with implicit addressing: )2(CMPSx)0( \(){/section-B.4.27 xl}(section B.4.27){el}(\), )2(SCASx)0( \(){/section-B.4.286 xl}(section B.4.286){el}(\), )2(LODSx)]180 norm0
[(\(){/section-B.4.141 xl}(section B.4.141){el}(\), )2(STOSx)0( \(){/section-B.4.303 xl}(section B.4.303){el}(\), )2(MOVSx)0( \(){/section-B.4.178 xl}(section B.4.178){el}(\), )2(INSx)0( \(){/section-B.4.121 xl}(section B.4.121){el}(\),)]169 norm0
[2(OUTSx)0( \(){/section-B.4.195 xl}(section B.4.195){el}(\), and )2(XLATB)0( \(){/section-B.4.334 xl}(section B.4.334){el}(\). Also, the various push and pop)]158 norm0
[(instructions \()2(PUSHA)0( and )2(POPF)0( as well as the more usual )2(PUSH)0( and )2(POP)0(\) can accept )2(a16)0( or )2(a32)]147 norm0
[(prefixes to force a particular one of )2(SP)0( or )2(ESP)0( to be used as a stack pointer, in case the stack)]136 norm0
[(segment in use is a different size from the code segment.)]125 norm2
(102)pageeven
restore showpage
%%Page: 103 103
%%BeginPageSetup
save
%%EndPageSetup
/103 pa
[2(PUSH)0( and )2(POP)0(, when applied to segment registers in 32-bit mode, also have the slightly odd)]681 norm1
[(behaviour that they push and pop 4 bytes at a time, of which the top two are ignored and the bottom)]670 norm0
[(two give the value of the segment register being manipulated. To force the 16-bit behaviour of)]659 norm0
[(segment-register push and pop instructions, you can use the operand-size prefix )2(o16)0(:)]648 norm2
[2(        o16 push    ss )]631 code1
[2(        o16 push    ds)]620 code2
[(This code saves a doubleword of stack space by fitting two segment registers into the space which)]603 norm1
[(would normally be consumed by pushing one.)]592 norm2
[(\(You can also use the )2(o32)0( prefix to force the 32-bit behaviour when in 16-bit mode, but this seems)]575 norm1
[(less useful.\))]564 norm2
(103)pageodd
restore showpage
%%Page: 104 104
%%BeginPageSetup
save
%%EndPageSetup
/104 pa
[{/chapter-10 xa}(Chapter 10: Troubleshooting)]644 chap3
[(This chapter describes some of the common problems that users have been known to encounter with)]609 norm1
[(NASM, and answers them. It also gives instructions for reporting bugs in NASM if you find a)]598 norm0
[(difficulty that isn't listed here.)]587 norm2
[{/section-10.1 xa}(Common Problems)](10.1)567 head3
[{/section-10.1.1 xa}(NASM Generates )(Inefficient Code)](10.1.1)549 subh3
[(We sometimes get `bug' reports about NASM generating inefficient, or even `wrong', code on)]532 norm1
[(instructions such as )2(ADD ESP,8)0(. This is a deliberate design feature, connected to predictability of)]521 norm0
[(output: NASM, on seeing )2(ADD ESP,8)0(, will generate the form of the instruction which leaves room)]510 norm0
[(for a 32-bit offset. You need to code )2(ADD ESP,BYTE 8)0( if you want the space-efficient form of)]499 norm0
[(the instruction. This isn't a bug, it's user error: if you prefer to have NASM produce the more)]488 norm0
[(efficient code automatically enable optimization with the )2(-On)0( option \(see ){/section-2.1.16 xl}(section 2.1.16){el}(\).)]477 norm2
[{/section-10.1.2 xa}(My Jumps are Out of Range)](10.1.2)459 subh3
[(Similarly, people complain that when they issue )(conditional jumps \(which are )2(SHORT)0( by default\))]442 norm1
[(that try to jump too far, NASM reports `short jump out of range' instead of making the jumps longer.)]431 norm2
[(This, again, is partly a predictability issue, but in fact has a more practical reason as well. NASM)]414 norm1
[(has no means of being told what type of processor the code it is generating will be run on; so it)]403 norm0
[(cannot decide for itself that it should generate )2(Jcc NEAR)0( type instructions, because it doesn't)]392 norm0
[(know that it's working for a 386 or above. Alternatively, it could replace the out-of-range short)]381 norm0
[2(JNE)0( instruction with a very short )2(JE)0( instruction that jumps over a )2(JMP NEAR)0(; this is a sensible)]370 norm0
[(solution for processors below a 386, but hardly efficient on processors which have good branch)]359 norm0
[(prediction )1(and)0( could have used )2(JNE NEAR)0( instead. So, once again, it's up to the user, not the)]348 norm0
[(assembler, to decide what instructions should be generated. See ){/section-2.1.16 xl}(section 2.1.16){el}(.)]337 norm2
[{/section-10.1.3 xa}2(ORG)0( Doesn't Work)](10.1.3)319 subh3
[(People writing )(boot sector programs in the )2(bin)0( format often complain that )2(ORG)0( doesn't work the)]302 norm1
[(way they'd like: in order to place the )2(0xAA55)0( signature word at the end of a 512-byte boot sector,)]291 norm0
[(people who are used to MASM tend to code)]280 norm2
[2(        ORG 0 )]263 code1
[2()]252 code0
[2(        ; some boot sector code )]241 code0
[2()]230 code0
[2(        ORG 510 )]219 code0
[2(        DW 0xAA55)]208 code2
[(This is not the intended use of the )2(ORG)0( directive in NASM, and will not work. The correct way to)]191 norm1
[(solve this problem in NASM is to use the )2(TIMES)0( directive, like this:)]180 norm2
[2(        ORG 0 )]163 code1
[2()]152 code0
[2(        ; some boot sector code )]141 code0
[2()]130 code0
[2(        TIMES 510-\($-$$\) DB 0 )]119 code0
[2(        DW 0xAA55)]108 code2
(104)pageeven
restore showpage
%%Page: 105 105
%%BeginPageSetup
save
%%EndPageSetup
/105 pa
[(The )2(TIMES)0( directive will insert exactly enough zero bytes into the output to move the assembly)]681 norm1
[(point up to 510. This method also has the advantage that if you accidentally fill your boot sector too)]670 norm0
[(full, NASM will catch the problem at assembly time and report it, so you won't end up with a boot)]659 norm0
[(sector that you have to disassemble to find out what's wrong with it.)]648 norm2
[{/section-10.1.4 xa}2(TIMES)0( Doesn't Work)](10.1.4)630 subh3
[(The other common problem with the above code is people who write the )2(TIMES)0( line as)]613 norm3
[2(        TIMES 510-$ DB 0)]596 code3
[(by reasoning that )2($)0( should be a pure number, just like 510, so the difference between them is also a)]579 norm1
[(pure number and can happily be fed to )2(TIMES)0(.)]568 norm2
[(NASM is a )1(modular)0( assembler: the various component parts are designed to be easily separable for)]551 norm1
[(re-use, so they don't exchange information unnecessarily. In consequence, the )2(bin)0( output format,)]540 norm0
[(even though it has been told by the )2(ORG)0( directive that the )2(.text)0( section should start at 0, does not)]529 norm0
[(pass that information back to the expression evaluator. So from the evaluator's point of view, )2($)]518 norm0
[(isn't a pure number: it's an offset from a section base. Therefore the difference between )2($)0( and 510)]507 norm0
[(is also not a pure number, but involves a section base. Values involving section bases cannot be)]496 norm0
[(passed as arguments to )2(TIMES)0(.)]485 norm2
[(The solution, as in the previous section, is to code the )2(TIMES)0( line in the form)]468 norm3
[2(        TIMES 510-\($-$$\) DB 0)]451 code3
[(in which )2($)0( and )2($$)0( are offsets from the same section base, and so their difference is a pure number.)]434 norm1
[(This will solve the problem and generate sensible code.)]423 norm2
[{/section-10.2 xa}(Bugs)](10.2)403 head3
[(We have never yet released a version of NASM with any )1(known)0( bugs. That doesn't usually stop)]386 norm1
[(there being plenty we didn't know about, though. Any that you find should be reported firstly via)]375 norm0
[(the )2(bugtracker)0( at ){(https://sourceforge.net/projects/nasm/)wl}2(https://sourceforge.net/projects/nasm/){el}0( \(click on "Bugs"\), or)]364 norm0
[(if that fails then through one of the contacts in ){/section-1.2 xl}(section 1.2){el}(.)]353 norm2
[(Please read ){/section-2.2 xl}(section 2.2){el}( first, and don't report the bug if it's listed in there as a deliberate feature. \(If)]336 norm1
[(you think the feature is badly thought out, feel free to send us reasons why you think it should be)]325 norm0
[(changed, but don't just send us mail saying `This is a bug' if the documentation says we did it on)]314 norm0
[(purpose.\) Then read ){/section-10.1 xl}(section 10.1){el}(, and don't bother reporting the bug if it's listed there.)]303 norm2
[(If you do report a bug, )1(please)0( give us all of the following information:)]286 norm3
[(What operating system you're running NASM under. DOS, Linux, NetBSD, Win16, Win32,)]269 bull1
[(VMS \(I'd be impressed\), whatever.)]258 bull2
[(If you're running NASM under DOS or Win32, tell us whether you've compiled your own)]241 bull1
[(executable from the DOS source archive, or whether you were using the standard distribution)]230 bull0
[(binaries out of the archive. If you were using a locally built executable, try to reproduce the)]219 bull0
[(problem using one of the standard binaries, as this will make it easier for us to reproduce your)]208 bull0
[(problem prior to fixing it.)]197 bull2
[(Which version of NASM you're using, and exactly how you invoked it. Give us the precise)]180 bull1
[(command line, and the contents of the )2(NASMENV)0( environment variable if any.)]169 bull2
[(Which versions of any supplementary programs you're using, and how you invoked them. If the)]152 bull1
[(problem only becomes visible at link time, tell us what linker you're using, what version of it)]141 bull0
[(you've got, and the exact linker command line. If the problem involves linking against object)]130 bull0
[(files generated by a compiler, tell us what compiler, what version, and what command line or)]119 bull0
(105)pageodd
restore showpage
%%Page: 106 106
%%BeginPageSetup
save
%%EndPageSetup
/106 pa
[(options you used. \(If you're compiling in an IDE, please try to reproduce the problem with the)]681 bull0
[(command-line version of the compiler.\))]670 bull2
[(If at all possible, send us a NASM source file which exhibits the problem. If this causes)]653 bull1
[(copyright problems \(e.g. you can only reproduce the bug in restricted-distribution code\) then)]642 bull0
[(bear in mind the following two points: firstly, we guarantee that any source code sent to us for)]631 bull0
[(the purposes of debugging NASM will be used )1(only)0( for the purposes of debugging NASM, and)]620 bull0
[(that we will delete all our copies of it as soon as we have found and fixed the bug or bugs in)]609 bull0
[(question; and secondly, we would prefer )1(not)0( to be mailed large chunks of code anyway. The)]598 bull0
[(smaller the file, the better. A three-line sample file that does nothing useful )1(except)0( demonstrate)]587 bull0
[(the problem is much easier to work with than a fully fledged ten-thousand-line program. \(Of)]576 bull0
[(course, some errors )1(do)0( only crop up in large files, so this may not be possible.\))]565 bull2
[(A description of what the problem actually )1(is)0(. `It doesn't work' is )1(not)0( a helpful description!)]548 bull1
[(Please describe exactly what is happening that shouldn't be, or what isn't happening that should.)]537 bull0
[(Examples might be: `NASM generates an error message saying Line 3 for an error that's actually)]526 bull0
[(on Line 5'; `NASM generates an error message that I believe it shouldn't be generating at all';)]515 bull0
[(`NASM fails to generate an error message that I believe it )1(should)0( be generating'; `the object file)]504 bull0
[(produced from this source code crashes my linker'; `the ninth byte of the output file is 66 and I)]493 bull0
[(think it should be 77 instead'.)]482 bull2
[(If you believe the output file from NASM to be faulty, send it to us. That allows us to determine)]465 bull1
[(whether our own copy of NASM generates the same file, or whether the problem is related to)]454 bull0
[(portability issues between our development platforms and yours. We can handle binary files)]443 bull0
[(mailed to us as MIME attachments, uuencoded, and even BinHex. Alternatively, we may be able)]432 bull0
[(to provide an FTP site you can upload the suspect files to; but mailing them is easier for us.)]421 bull2
[(Any other information or data files that might be helpful. If, for example, the problem involves)]404 bull1
[(NASM failing to generate an object file while TASM can generate an equivalent file without)]393 bull0
[(trouble, then send us )1(both)0( object files, so we can see what TASM is doing differently from us.)]382 bull2
(106)pageeven
restore showpage
%%Page: 107 107
%%BeginPageSetup
save
%%EndPageSetup
/107 pa
[{/appendix-A xa}(Appendix A: )(Ndisasm)]644 appn3
[(The Netwide Disassembler, NDISASM)]603 norm3
[{/section-A.1 xa}(Introduction)](A.1)583 head3
[(The Netwide Disassembler is a small companion program to the Netwide Assembler, NASM. It)]566 norm1
[(seemed a shame to have an x86 assembler, complete with a full instruction table, and not make as)]555 norm0
[(much use of it as possible, so here's a disassembler which shares the instruction table \(and some)]544 norm0
[(other bits of code\) with NASM.)]533 norm2
[(The Netwide Disassembler does nothing except to produce disassemblies of )1(binary)0( source files.)]516 norm1
[(NDISASM does not have any understanding of object file formats, like )2(objdump)0(, and it will not)]505 norm0
[(understand )2(DOS .EXE)0( files like )2(debug)0( will. It just disassembles.)]494 norm2
[{/section-A.2 xa}(Getting Started: Installation)](A.2)474 head3
[(See ){/section-1.3 xl}(section 1.3){el}( for installation instructions. NDISASM, like NASM, has a )2(man page)0( which you)]457 norm1
[(may want to put somewhere useful, if you are on a Unix system.)]446 norm2
[{/section-A.3 xa}(Running NDISASM)](A.3)426 head3
[(To disassemble a file, you will typically use a command of the form)]409 norm3
[2(       ndisasm [-b16 | -b32] filename)]392 code3
[(NDISASM can disassemble 16-bit code or 32-bit code equally easily, provided of course that you)]375 norm1
[(remember to specify which it is to work with. If no )2(-b)0( switch is present, NDISASM works in)]364 norm0
[(16-bit mode by default. The )2(-u)0( switch \(for USE32\) also invokes 32-bit mode.)]353 norm2
[(Two more command line options are )2(-r)0( which reports the version number of NDISASM you are)]336 norm1
[(running, and )2(-h)0( which gives a short summary of command line options.)]325 norm2
[{/section-A.3.1 xa}(COM Files: Specifying an Origin)](A.3.1)307 subh3
[(To disassemble a )2(DOS .COM)0( file correctly, a disassembler must assume that the first instruction in)]290 norm1
[(the file is loaded at address )2(0x100)0(, rather than at zero. NDISASM, which assumes by default that)]279 norm0
[(any file you give it is loaded at zero, will therefore need to be informed of this.)]268 norm2
[(The )2(-o)0( option allows you to declare a different origin for the file you are disassembling. Its)]251 norm1
[(argument may be expressed in any of the NASM numeric formats: decimal by default, if it begins)]240 norm0
[(with `)2($)0(' or `)2(0x)0(' or ends in `)2(H)0(' it's )2(hex)0(, if it ends in `)2(Q)0(' it's )2(octal)0(, and if it ends in `)2(B)0(' it's)]229 norm0
[2(binary)0(.)]218 norm2
[(Hence, to disassemble a )2(.COM)0( file:)]201 norm3
[2(       ndisasm -o100h filename.com)]184 code3
[(will do the trick.)]167 norm3
[{/section-A.3.2 xa}(Code Following Data: Synchronisation)](A.3.2)149 subh3
[(Suppose you are disassembling a file which contains some data which isn't machine code, and )1(then)]132 norm1
[(contains some machine code. NDISASM will faithfully plough through the data section, producing)]121 norm0
[(machine instructions wherever it can \(although most of them will look bizarre, and some may have)]110 norm0
(107)pageodd
restore showpage
%%Page: 108 108
%%BeginPageSetup
save
%%EndPageSetup
/108 pa
[(unusual prefixes, e.g. `)2(FS OR AX,0x240A)0('\), and generating `DB' instructions ever so often if)]681 norm0
[(it's totally stumped. Then it will reach the code section.)]670 norm2
[(Supposing NDISASM has just finished generating a strange machine instruction from part of the)]653 norm1
[(data section, and its file position is now one byte )1(before)0( the beginning of the code section. It's)]642 norm0
[(entirely possible that another spurious instruction will get generated, starting with the final byte of)]631 norm0
[(the data section, and then the correct first instruction in the code section will not be seen because the)]620 norm0
[(starting point skipped over it. This isn't really ideal.)]609 norm2
[(To avoid this, you can specify a `)2(synchronisation)0(' point, or indeed as many synchronisation)]592 norm1
[(points as you like \(although NDISASM can only handle 8192 sync points internally\). The definition)]581 norm0
[(of a sync point is this: NDISASM guarantees to hit sync points exactly during disassembly. If it is)]570 norm0
[(thinking about generating an instruction which would cause it to jump over a sync point, it will)]559 norm0
[(discard that instruction and output a `)2(db)0(' instead. So it )1(will)0( start disassembly exactly from the sync)]548 norm0
[(point, and so you )1(will)0( see all the instructions in your code section.)]537 norm2
[(Sync points are specified using the )2(-s)0( option: they are measured in terms of the program origin, not)]520 norm1
[(the file position. So if you want to synchronise after 32 bytes of a )2(.COM)0( file, you would have to do)]509 norm2
[2(       ndisasm -o100h -s120h file.com)]492 code3
[(rather than)]475 norm3
[2(       ndisasm -o100h -s20h file.com)]458 code3
[(As stated above, you can specify multiple sync markers if you need to, just by repeating the )2(-s)]441 norm1
[(option.)]430 norm2
[{/section-A.3.3 xa}(Mixed Code and Data: Automatic \(Intelligent\) Synchronisation )](A.3.3)412 subh3
[(Suppose you are disassembling the boot sector of a )2(DOS)0( floppy \(maybe it has a virus, and you need)]395 norm1
[(to understand the virus so that you know what kinds of damage it might have done you\). Typically,)]384 norm0
[(this will contain a )2(JMP)0( instruction, then some data, then the rest of the code. So there is a very good)]373 norm0
[(chance of NDISASM being )1(misaligned)0( when the data ends and the code begins. Hence a sync point)]362 norm0
[(is needed.)]351 norm2
[(On the other hand, why should you have to specify the sync point manually? What you'd do in)]334 norm1
[(order to find where the sync point would be, surely, would be to read the )2(JMP)0( instruction, and then)]323 norm0
[(to use its target address as a sync point. So can NDISASM do that for you?)]312 norm2
[(The answer, of course, is yes: using either of the synonymous switches )2(-a)0( \(for automatic sync\) or)]295 norm1
[2(-i)0( \(for intelligent sync\) will enable )2(auto-sync)0( mode. Auto-sync mode automatically generates)]284 norm0
[(a sync point for any forward-referring PC-relative jump or call instruction that NDISASM)]273 norm0
[(encounters. \(Since NDISASM is one-pass, if it encounters a PC-relative jump whose target has)]262 norm0
[(already been processed, there isn't much it can do about it...\))]251 norm2
[(Only PC-relative jumps are processed, since an absolute jump is either through a register \(in which)]234 norm1
[(case NDISASM doesn't know what the register contains\) or involves a segment address \(in which)]223 norm0
[(case the target code isn't in the same segment that NDISASM is working in, and so the sync point)]212 norm0
[(can't be placed anywhere useful\).)]201 norm2
[(For some kinds of file, this mechanism will automatically put sync points in all the right places, and)]184 norm1
[(save you from having to place any sync points manually. However, it should be stressed that)]173 norm0
[(auto-sync mode is )1(not)0( guaranteed to catch all the sync points, and you may still have to place some)]162 norm0
[(manually.)]151 norm2
[(Auto-sync mode doesn't prevent you from declaring manual sync points: it just adds automatically)]134 norm1
[(generated ones to the ones you provide. It's perfectly feasible to specify )2(-i)0( )1(and)0( some )2(-s)0( options.)]123 norm2
(108)pageeven
restore showpage
%%Page: 109 109
%%BeginPageSetup
save
%%EndPageSetup
/109 pa
[(Another caveat with auto-sync mode is that if, by some unpleasant fluke, something in your data)]681 norm1
[(section should disassemble to a PC-relative call or jump instruction, NDISASM may obediently)]670 norm0
[(place a sync point in a totally random place, for example in the middle of one of the instructions in)]659 norm0
[(your code section. So you may end up with a wrong disassembly even if you use auto-sync. Again,)]648 norm0
[(there isn't much I can do about this. If you have problems, you'll have to use manual sync points, or)]637 norm0
[(use the )2(-k)0( option \(documented below\) to suppress disassembly of the data area.)]626 norm2
[{/section-A.3.4 xa}(Other Options)](A.3.4)608 subh3
[(The )2(-e)0( option skips a header on the file, by ignoring the first N bytes. This means that the header is)]591 norm1
[1(not)0( counted towards the disassembly offset: if you give )2(-e10 -o10)0(, disassembly will start at byte)]580 norm0
[(10 in the file, and this will be given offset 10, not 20.)]569 norm2
[(The )2(-k)0( option is provided with two comma-separated numeric arguments, the first of which is an)]552 norm1
[(assembly offset and the second is a number of bytes to skip. This )1(will)0( count the skipped bytes)]541 norm0
[(towards the assembly offset: its use is to suppress disassembly of a data section which wouldn't)]530 norm0
[(contain anything you wanted to see anyway.)]519 norm2
[{/section-A.4 xa}(Bugs and Improvements)](A.4)499 head3
[(There are no known bugs. However, any you find, with patches if possible, should be sent to)]482 norm1
[{(mailto:jules@dsf.org.uk)wl}2(jules@dsf.org.uk){el}0( or ){(mailto:anakin@pobox.com)wl}2(anakin@pobox.com){el}0(, or to the developer's site at)]471 norm0
[{(https://sourceforge.net/projects/nasm/)wl}2(https://sourceforge.net/projects/nasm/){el}0( and we'll try to fix them. Feel free to send)]460 norm0
[(contributions and new features as well.)]449 norm2
[(Future plans include awareness of which processors certain instructions will run on, and marking of)]432 norm1
[(instructions that are too advanced for some processor \(or are )2(FPU)0( instructions, or are undocumented)]421 norm0
[(opcodes, or are privileged protected-mode instructions, or whatever\).)]410 norm2
[(That's All Folks!)]393 norm3
[(I hope NDISASM is of some use to somebody. Including me. :-\))]376 norm3
[(I don't recommend taking NDISASM apart to see how an efficient disassembler works, because as)]359 norm1
[(far as I know, it isn't an efficient one anyway. You have been warned.)]348 norm2
(109)pageodd
restore showpage
%%Page: 110 110
%%BeginPageSetup
save
%%EndPageSetup
/110 pa
[{/appendix-B xa}(Appendix B: x86 Instruction Reference)]644 appn3
[(This appendix provides a complete list of the machine instructions which NASM will assemble, and)]603 norm1
[(a short description of the function of each one.)]592 norm2
[(It is not intended to be exhaustive documentation on the fine details of the instructions' function,)]575 norm1
[(such as which exceptions they can trigger: for such documentation, you should go to Intel's Web)]564 norm0
[(site, ){(http://developer.intel.com/design/Pentium4/manuals/)wl}2(http://developer.intel.com/design/Pentium4/manuals/){el}0(.)]553 norm2
[(Instead, this appendix is intended primarily to provide documentation on the way the instructions)]536 norm1
[(may be used within NASM. For example, looking up )2(LOOP)0( will tell you that NASM allows )2(CX)0( or)]525 norm0
[2(ECX)0( to be specified as an optional second argument to the )2(LOOP)0( instruction, to enforce which of the)]514 norm0
[(two possible counter registers should be used if the default is not the one desired.)]503 norm2
[(The instructions are not quite listed in alphabetical order, since groups of instructions with similar)]486 norm1
[(functions are lumped together in the same entry. Most of them don't move very far from their)]475 norm0
[(alphabetic position because of this.)]464 norm2
[{/section-B.1 xa}(Key to Operand Specifications)](B.1)444 head3
[(The instruction descriptions in this appendix specify their operands using the following notation:)]427 norm3
[(Registers: )2(reg8)0( denotes an 8-bit )(general purpose register, )2(reg16)0( denotes a 16-bit general)]410 bull1
[(purpose register, and )2(reg32)0( a 32-bit one. )2(fpureg)0( denotes one of the eight FPU stack registers,)]399 bull0
[2(mmxreg)0( denotes one of the eight 64-bit MMX registers, and )2(segreg)0( denotes a segment)]388 bull0
[(register. In addition, some registers \(such as )2(AL)0(, )2(DX)0( or )2(ECX)0(\) may be specified explicitly.)]377 bull2
[(Immediate operands: )2(imm)0( denotes a generic )(immediate operand. )2(imm8)0(, )2(imm16)0( and )2(imm32)0( are)]360 bull1
[(used when the operand is intended to be a specific size. For some of these instructions, NASM)]349 bull0
[(needs an explicit specifier: for example, )2(ADD ESP,16)0( could be interpreted as either)]338 bull0
[2(ADD r/m32,imm32)0( or )2(ADD r/m32,imm8)0(. NASM chooses the former by default, and so you)]327 bull0
[(must specify )2(ADD ESP,BYTE 16)0( for the latter.)]316 bull2
[(Memory references: )2(mem)0( denotes a generic )(memory reference; )2(mem8)0(, )2(mem16)0(, )2(mem32)0(, )2(mem64)]299 bull1
[(and )2(mem80)0( are used when the operand needs to be a specific size. Again, a specifier is needed in)]288 bull0
[(some cases: )2(DEC [address])0( is ambiguous and will be rejected by NASM. You must specify)]277 bull0
[2(DEC BYTE [address])0(, )2(DEC WORD [address])0( or )2(DEC DWORD [address])0( instead.)]266 bull2
[(Restricted memory references: one form of the )2(MOV)0( instruction allows a memory address to be)]249 bull1
[(specified )1(without)0( allowing the normal range of register combinations and effective address)]238 bull0
[(processing. This is denoted by )2(memoffs8)0(, )2(memoffs16)0( and )2(memoffs32)0(.)]227 bull2
[(Register or memory choices: many instructions can accept either a register )1(or)0( a memory)]210 bull1
[(reference as an operand. )2(r/m8)0( is a shorthand for )2(reg8/mem8)0(; similarly )2(r/m16)0( and )2(r/m32)0(.)]199 bull0
[2(r/m64)0( is MMX-related, and is a shorthand for )2(mmxreg/mem64)0(.)]188 bull2
[{/section-B.2 xa}(Key to Opcode Descriptions)](B.2)168 head3
[(This appendix also provides the opcodes which NASM will generate for each form of each)]151 norm1
[(instruction. The opcodes are listed in the following way:)]140 norm2
[(A hex number, such as )2(3F)0(, indicates a fixed byte containing that number.)]123 bull3
(110)pageeven
restore showpage
%%Page: 111 111
%%BeginPageSetup
save
%%EndPageSetup
/111 pa
[(A hex number followed by )2(+r)0(, such as )2(C8+r)0(, indicates that one of the operands to the)]681 bull1
[(instruction is a register, and the `register value' of that register should be added to the hex)]670 bull0
[(number to produce the generated byte. For example, EDX has register value 2, so the code)]659 bull0
[2(C8+r)0(, when the register operand is EDX, generates the hex byte )2(CA)0(. Register values for specific)]648 bull0
[(registers are given in ){/section-B.2.1 xl}(section B.2.1){el}(.)]637 bull2
[(A hex number followed by )2(+cc)0(, such as )2(40+cc)0(, indicates that the instruction name has a)]620 bull1
[(condition code suffix, and the numeric representation of the condition code should be added to)]609 bull0
[(the hex number to produce the generated byte. For example, the code )2(40+cc)0(, when the)]598 bull0
[(instruction contains the )2(NE)0( condition, generates the hex byte )2(45)0(. Condition codes and their)]587 bull0
[(numeric representations are given in ){/section-B.2.2 xl}(section B.2.2){el}(.)]576 bull2
[(A slash followed by a digit, such as )2(/2)0(, indicates that one of the operands to the instruction is a)]559 bull1
[(memory address or register \(denoted )2(mem)0( or )2(r/m)0(, with an optional size\). This is to be encoded as)]548 bull0
[(an effective address, with a )(ModR/M byte, an optional )(SIB byte, and an optional displacement,)]537 bull0
[(and the spare \(register\) field of the ModR/M byte should be the digit given \(which will be from 0)]526 bull0
[(to 7, so it fits in three bits\). The encoding of effective addresses is given in ){/section-B.2.5 xl}(section B.2.5){el}(.)]515 bull2
[(The code )2(/r)0( combines the above two: it indicates that one of the operands is a memory address)]498 bull1
[(or )2(r/m)0(, and another is a register, and that an effective address should be generated with the spare)]487 bull0
[(\(register\) field in the ModR/M byte being equal to the `register value' of the register operand.)]476 bull0
[(The encoding of effective addresses is given in ){/section-B.2.5 xl}(section B.2.5){el}(; register values are given in ){/section-B.2.1 xl}(section){el}]465 bull0
[{/section-B.2.1 xl}(B.2.1){el}(.)]454 bull2
[(The codes )2(ib)0(, )2(iw)0( and )2(id)0( indicate that one of the operands to the instruction is an immediate)]437 bull1
[(value, and that this is to be encoded as a byte, little-endian word or little-endian doubleword)]426 bull0
[(respectively.)]415 bull2
[(The codes )2(rb)0(, )2(rw)0( and )2(rd)0( indicate that one of the operands to the instruction is an immediate)]398 bull1
[(value, and that the )1(difference)0( between this value and the address of the end of the instruction is to)]387 bull0
[(be encoded as a byte, word or doubleword respectively. Where the form )2(rw/rd)0( appears, it)]376 bull0
[(indicates that either )2(rw)0( or )2(rd)0( should be used according to whether assembly is being performed)]365 bull0
[(in )2(BITS 16)0( or )2(BITS 32)0( state respectively.)]354 bull2
[(The codes )2(ow)0( and )2(od)0( indicate that one of the operands to the instruction is a reference to the)]337 bull1
[(contents of a memory address specified as an immediate value: this encoding is used in some)]326 bull0
[(forms of the )2(MOV)0( instruction in place of the standard effective-address mechanism. The)]315 bull0
[(displacement is encoded as a word or doubleword. Again, )2(ow/od)0( denotes that )2(ow)0( or )2(od)0( should)]304 bull0
[(be chosen according to the )2(BITS)0( setting.)]293 bull2
[(The codes )2(o16)0( and )2(o32)0( indicate that the given form of the instruction should be assembled with)]276 bull1
[(operand size 16 or 32 bits. In other words, )2(o16)0( indicates a )2(66)0( prefix in )2(BITS 32)0( state, but)]265 bull0
[(generates no code in )2(BITS 16)0( state; and )2(o32)0( indicates a )2(66)0( prefix in )2(BITS 16)0( state but)]254 bull0
[(generates nothing in )2(BITS 32)0(.)]243 bull2
[(The codes )2(a16)0( and )2(a32)0(, similarly to )2(o16)0( and )2(o32)0(, indicate the address size of the given form)]226 bull1
[(of the instruction. Where this does not match the )2(BITS)0( setting, a )2(67)0( prefix is required.)]215 bull2
[{/section-B.2.1 xa}(Register Values)](B.2.1)197 subh3
[(Where an instruction requires a register value, it is already implicit in the encoding of the rest of the)]180 norm1
[(instruction what type of register is intended: an 8-bit general-purpose register, a segment register, a)]169 norm0
[(debug register, an MMX register, or whatever. Therefore there is no problem with registers of)]158 norm0
[(different types sharing an encoding value.)]147 norm2
[(The encodings for the various classes of register are:)]130 norm3
[(8-bit general registers: )2(AL)0( is 0, )2(CL)0( is 1, )2(DL)0( is 2, )2(BL)0( is 3, )2(AH)0( is 4, )2(CH)0( is 5, )2(DH)0( is 6, and )2(BH)0( is 7.)]113 bull3
(111)pageodd
restore showpage
%%Page: 112 112
%%BeginPageSetup
save
%%EndPageSetup
/112 pa
[(16-bit general registers: )2(AX)0( is 0, )2(CX)0( is 1, )2(DX)0( is 2, )2(BX)0( is 3, )2(SP)0( is 4, )2(BP)0( is 5, )2(SI)0( is 6, and )2(DI)0( is 7.)]681 bull3
[(32-bit general registers: )2(EAX)0( is 0, )2(ECX)0( is 1, )2(EDX)0( is 2, )2(EBX)0( is 3, )2(ESP)0( is 4, )2(EBP)0( is 5, )2(ESI)0( is 6,)]664 bull1
[(and )2(EDI)0( is 7.)]653 bull2
[(Segment registers: )2(ES)0( is 0, )2(CS)0( is 1, )2(SS)0( is 2, )2(DS)0( is 3, )2(FS)0( is 4, and )2(GS)0( is 5.)]636 bull3
[(Floating-point registers: )2(ST0)0( is 0, )2(ST1)0( is 1, )2(ST2)0( is 2, )2(ST3)0( is 3, )2(ST4)0( is 4, )2(ST5)0( is 5, )2(ST6)0( is 6,)]619 bull1
[(and )2(ST7)0( is 7.)]608 bull2
[(64-bit )(MMX registers: )2(MM0)0( is 0, )2(MM1)0( is 1, )2(MM2)0( is 2, )2(MM3)0( is 3, )2(MM4)0( is 4, )2(MM5)0( is 5, )2(MM6)0( is 6, and)]591 bull1
[2(MM7)0( is 7.)]580 bull2
[(Control registers: )2(CR0)0( is 0, )2(CR2)0( is 2, )2(CR3)0( is 3, and )2(CR4)0( is 4.)]563 bull3
[(Debug registers: )2(DR0)0( is 0, )2(DR1)0( is 1, )2(DR2)0( is 2, )2(DR3)0( is 3, )2(DR6)0( is 6, and )2(DR7)0( is 7.)]546 bull3
[(Test registers: )2(TR3)0( is 3, )2(TR4)0( is 4, )2(TR5)0( is 5, )2(TR6)0( is 6, and )2(TR7)0( is 7.)]529 bull3
[(\(Note that wherever a register name contains a number, that number is also the register value for)]512 norm1
[(that register.\))]501 norm2
[{/section-B.2.2 xa}(Condition Codes)](B.2.2)483 subh3
[(The available condition codes are given here, along with their numeric representations as part of)]466 norm1
[(opcodes. Many of these condition codes have synonyms, so several will be listed at a time.)]455 norm2
[(In the following descriptions, the word `either', when applied to two possible trigger conditions, is)]438 norm1
[(used to mean `either or both'. If `either but not both' is meant, the phrase `exactly one of' is used.)]427 norm2
[2(O)0( is 0 \(trigger if the overflow flag is set\); )2(NO)0( is 1.)]410 bull3
[2(B)0(, )2(C)0( and )2(NAE)0( are 2 \(trigger if the carry flag is set\); )2(AE)0(, )2(NB)0( and )2(NC)0( are 3.)]393 bull3
[2(E)0( and )2(Z)0( are 4 \(trigger if the zero flag is set\); )2(NE)0( and )2(NZ)0( are 5.)]376 bull3
[2(BE)0( and )2(NA)0( are 6 \(trigger if either of the carry or zero flags is set\); )2(A)0( and )2(NBE)0( are 7.)]359 bull3
[2(S)0( is 8 \(trigger if the sign flag is set\); )2(NS)0( is 9.)]342 bull3
[2(P)0( and )2(PE)0( are 10 \(trigger if the parity flag is set\); )2(NP)0( and )2(PO)0( are 11.)]325 bull3
[2(L)0( and )2(NGE)0( are 12 \(trigger if exactly one of the sign and overflow flags is set\); )2(GE)0( and )2(NL)0( are 13.)]308 bull3
[2(LE)0( and )2(NG)0( are 14 \(trigger if either the zero flag is set, or exactly one of the sign and overflow)]291 bull1
[(flags is set\); )2(G)0( and )2(NLE)0( are 15.)]280 bull2
[(Note that in all cases, the sense of a condition code may be reversed by changing the low bit of the)]263 norm1
[(numeric representation.)]252 norm2
[(For details of when an instruction sets each of the status flags, see the individual instruction, plus)]235 norm1
[(the Status Flags reference in ){/section-B.2.4 xl}(section B.2.4){el}]224 norm2
[{/section-B.2.3 xa}(SSE Condition Predicates)](B.2.3)206 subh3
[(The condition predicates for SSE comparison instructions are the codes used as part of the opcode,)]189 norm1
[(to determine what form of comparison is being carried out. In each case, the imm8 value is the final)]178 norm0
[(byte of the opcode encoding, and the predicate is the code used as part of the mnemonic for the)]167 norm0
[(instruction \(equivalent to the "cc" in an integer instruction that used a condition code\). The)]156 norm0
[(instructions that use this will give details of what the various mnemonics are, this table is used to)]145 norm0
[(help you work out details of what is happening.)]134 norm2
[2(Predi-  imm8  Description Relation where:   Emula- Result   QNaN )]117 code1
[2( cate  Encod-             A Is 1st Operand  tion   if NaN   Signal )]106 code0
(112)pageeven
restore showpage
%%Page: 113 113
%%BeginPageSetup
save
%%EndPageSetup
/113 pa
[2(        ing               B Is 2nd Operand         Operand  Invalid )]681 code0
[2()]670 code0
[2(EQ     000B   equal       A = B                    False     No )]659 code0
[2()]648 code0
[2(LT     001B   less-than   A < B                    False     Yes )]637 code0
[2()]626 code0
[2(LE     010B   less-than-  A <= B                   False     Yes )]615 code0
[2(               or-equal )]604 code0
[2()]593 code0
[2(---    ----   greater     A > B             Swap   False     Yes )]582 code0
[2(              than                          Operands, )]571 code0
[2(                                            Use LT )]560 code0
[2()]549 code0
[2(---    ----   greater-    A >= B            Swap   False     Yes )]538 code0
[2(              than-or-equal                 Operands, )]527 code0
[2(                                            Use LE )]516 code0
[2()]505 code0
[2(UNORD  011B   unordered   A, B = Unordered         True      No )]494 code0
[2()]483 code0
[2(NEQ    100B   not-equal   A != B                   True      No )]472 code0
[2()]461 code0
[2(NLT    101B   not-less-   NOT\(A < B\)               True      Yes )]450 code0
[2(              than )]439 code0
[2()]428 code0
[2(NLE    110B   not-less-   NOT\(A <= B\)              True      Yes )]417 code0
[2(              than-or- )]406 code0
[2(              equal )]395 code0
[2()]384 code0
[2(---    ----   not-greater NOT\(A > B\)        Swap   True      Yes )]373 code0
[2(              than                          Operands, )]362 code0
[2(                                            Use NLT )]351 code0
[2()]340 code0
[2(---    ----   not-greater NOT\(A >= B\)       Swap   True      Yes )]329 code0
[2(              than-                         Operands, )]318 code0
[2(              or-equal                      Use NLE )]307 code0
[2()]296 code0
[2(ORD    111B   ordered      A , B = Ordered         False     No)]285 code2
[(The unordered relationship is true when at least one of the two values being compared is a NaN or)]268 norm1
[(in an unsupported format.)]257 norm2
[(Note that the comparisons which are listed as not having a predicate or encoding can only be)]240 norm1
[(achieved through software emulation, as described in the "emulation" column. Note in particular)]229 norm0
[(that an instruction such as )2(greater-than)0( is not the same as )2(NLE)0(, as, unlike with the )2(CMP)]218 norm0
[(instruction, it has to take into account the possibility of one operand containing a NaN or an)]207 norm0
[(unsupported numeric format.)]196 norm2
[{/section-B.2.4 xa}(Status Flags)](B.2.4)178 subh3
[(The status flags provide some information about the result of the arithmetic instructions. This)]161 norm1
[(information can be used by conditional instructions \(such a )2(Jcc)0( and )2(CMOVcc)0(\) as well as by some)]150 norm0
[(of the other instructions \(such as )2(ADC)0( and )2(INTO)0(\).)]139 norm2
[(There are 6 status flags:)]122 norm3
[2(CF - Carry flag.)]105 code3
(113)pageodd
restore showpage
%%Page: 114 114
%%BeginPageSetup
save
%%EndPageSetup
/114 pa
[(Set if an arithmetic operation generates a carry or a borrow out of the most-significant bit of the)]681 norm1
[(result; cleared otherwise. This flag indicates an overflow condition for unsigned-integer arithmetic.)]670 norm0
[(It is also used in multiple-precision arithmetic.)]659 norm2
[2(PF - Parity flag.)]642 code3
[(Set if the least-significant byte of the result contains an even number of 1 bits; cleared otherwise.)]625 norm3
[2(AF - Adjust flag.)]608 code3
[(Set if an arithmetic operation generates a carry or a borrow out of bit 3 of the result; cleared)]591 norm1
[(otherwise. This flag is used in binary-coded decimal \(BCD\) arithmetic.)]580 norm2
[2(ZF - Zero flag.)]563 code3
[(Set if the result is zero; cleared otherwise.)]546 norm3
[2(SF - Sign flag.)]529 code3
[(Set equal to the most-significant bit of the result, which is the sign bit of a signed integer. \(0)]512 norm1
[(indicates a positive value and 1 indicates a negative value.\))]501 norm2
[2(OF - Overflow flag.)]484 code3
[(Set if the integer result is too large a positive number or too small a negative number \(excluding the)]467 norm1
[(sign-bit\) to fit in the destination operand; cleared otherwise. This flag indicates an overflow)]456 norm0
[(condition for signed-integer \(two's complement\) arithmetic.)]445 norm2
[{/section-B.2.5 xa}(Effective Address Encoding: )(ModR/M and )(SIB)](B.2.5)427 subh3
[(An )(effective address is encoded in up to three parts: a ModR/M byte, an optional SIB byte, and an)]410 norm1
[(optional byte, word or doubleword displacement field.)]399 norm2
[(The ModR/M byte consists of three fields: the )2(mod)0( field, ranging from 0 to 3, in the upper two bits)]382 norm1
[(of the byte, the )2(r/m)0( field, ranging from 0 to 7, in the lower three bits, and the spare \(register\) field)]371 norm0
[(in the middle \(bit 3 to bit 5\). The spare field is not relevant to the effective address being encoded,)]360 norm0
[(and either contains an extension to the instruction opcode or the register value of another operand.)]349 norm2
[(The ModR/M system can be used to encode a direct register reference rather than a memory access.)]332 norm1
[(This is always done by setting the )2(mod)0( field to 3 and the )2(r/m)0( field to the register value of the)]321 norm0
[(register in question \(it must be a general-purpose register, and the size of the register must already)]310 norm0
[(be implicit in the encoding of the rest of the instruction\). In this case, the SIB byte and displacement)]299 norm0
[(field are both absent.)]288 norm2
[(In 16-bit addressing mode \(either )2(BITS 16)0( with no )2(67)0( prefix, or )2(BITS 32)0( with a )2(67)0( prefix\), the)]271 norm1
[(SIB byte is never used. The general rules for )2(mod)0( and )2(r/m)0( \(there is an exception, given below\) are:)]260 norm2
[(The )2(mod)0( field gives the length of the displacement field: 0 means no displacement, 1 means one)]243 bull1
[(byte, and 2 means two bytes.)]232 bull2
[(The )2(r/m)0( field encodes the combination of registers to be added to the displacement to give the)]215 bull1
[(accessed address: 0 means )2(BX+SI)0(, 1 means )2(BX+DI)0(, 2 means )2(BP+SI)0(, 3 means )2(BP+DI)0(, 4 means)]204 bull0
[2(SI)0( only, 5 means )2(DI)0( only, 6 means )2(BP)0( only, and 7 means )2(BX)0( only.)]193 bull2
[(However, there is a special case:)]176 norm3
[(If )2(mod)0( is 0 and )2(r/m)0( is 6, the effective address encoded is not )2([BP])0( as the above rules would)]159 bull1
[(suggest, but instead )2([disp16])0(: the displacement field is present and is two bytes long, and no)]148 bull0
[(registers are added to the displacement.)]137 bull2
(114)pageeven
restore showpage
%%Page: 115 115
%%BeginPageSetup
save
%%EndPageSetup
/115 pa
[(Therefore the effective address )2([BP])0( cannot be encoded as efficiently as )2([BX])0(; so if you code)]681 norm1
[2([BP])0( in a program, NASM adds a notional 8-bit zero displacement, and sets )2(mod)0( to 1, )2(r/m)0( to 6,)]670 norm0
[(and the one-byte displacement field to 0.)]659 norm2
[(In 32-bit addressing mode \(either )2(BITS 16)0( with a )2(67)0( prefix, or )2(BITS 32)0( with no )2(67)0( prefix\) the)]642 norm1
[(general rules \(again, there are exceptions\) for )2(mod)0( and )2(r/m)0( are:)]631 norm2
[(The )2(mod)0( field gives the length of the displacement field: 0 means no displacement, 1 means one)]614 bull1
[(byte, and 2 means four bytes.)]603 bull2
[(If only one register is to be added to the displacement, and it is not )2(ESP)0(, the )2(r/m)0( field gives its)]586 bull1
[(register value, and the SIB byte is absent. If the )2(r/m)0( field is 4 \(which would encode )2(ESP)0(\), the)]575 bull0
[(SIB byte is present and gives the combination and scaling of registers to be added to the)]564 bull0
[(displacement.)]553 bull2
[(If the SIB byte is present, it describes the combination of registers \(an optional base register, and an)]536 norm1
[(optional index register scaled by multiplication by 1, 2, 4 or 8\) to be added to the displacement. The)]525 norm0
[(SIB byte is divided into the )2(scale)0( field, in the top two bits, the )2(index)0( field in the next three, and)]514 norm0
[(the )2(base)0( field in the bottom three. The general rules are:)]503 norm2
[(The )2(base)0( field encodes the register value of the base register.)]486 bull3
[(The )2(index)0( field encodes the register value of the index register, unless it is 4, in which case no)]469 bull1
[(index register is used \(so )2(ESP)0( cannot be used as an index register\).)]458 bull2
[(The )2(scale)0( field encodes the multiplier by which the index register is scaled before adding it to)]441 bull1
[(the base and displacement: 0 encodes a multiplier of 1, 1 encodes 2, 2 encodes 4 and 3 encodes 8.)]430 bull2
[(The exceptions to the 32-bit encoding rules are:)]413 norm3
[(If )2(mod)0( is 0 and )2(r/m)0( is 5, the effective address encoded is not )2([EBP])0( as the above rules would)]396 bull1
[(suggest, but instead )2([disp32])0(: the displacement field is present and is four bytes long, and no)]385 bull0
[(registers are added to the displacement.)]374 bull2
[(If )2(mod)0( is 0, )2(r/m)0( is 4 \(meaning the SIB byte is present\) and )2(base)0( is 4, the effective address)]357 bull1
[(encoded is not )2([EBP+index])0( as the above rules would suggest, but instead)]346 bull0
[2([disp32+index])0(: the displacement field is present and is four bytes long, and there is no)]335 bull0
[(base register \(but the index register is still processed in the normal way\).)]324 bull2
[{/section-B.3 xa}(Key to Instruction Flags)](B.3)304 head3
[(Given along with each instruction in this appendix is a set of flags, denoting the type of the)]287 norm1
[(instruction. The types are as follows:)]276 norm2
[2(8086)0(, )2(186)0(, )2(286)0(, )2(386)0(, )2(486)0(, )2(PENT)0( and )2(P6)0( denote the lowest processor type that supports the)]259 bull1
[(instruction. Most instructions run on all processors above the given type; those that do not are)]248 bull0
[(documented. The Pentium II contains no additional instructions beyond the P6 \(Pentium Pro\);)]237 bull0
[(from the point of view of its instruction set, it can be thought of as a P6 with MMX capability.)]226 bull2
[2(3DNOW)0( indicates that the instruction is a 3DNow! one, and will run on the AMD K6-2 and later)]209 bull1
[(processors. ATHLON extensions to the 3DNow! instruction set are documented as such.)]198 bull2
[2(CYRIX)0( indicates that the instruction is specific to Cyrix processors, for example the extra MMX)]181 bull1
[(instructions in the Cyrix extended MMX instruction set.)]170 bull2
[2(FPU)0( indicates that the instruction is a floating-point one, and will only run on machines with a)]153 bull1
[(coprocessor \(automatically including 486DX, Pentium and above\).)]142 bull2
[2(KATMAI)0( indicates that the instruction was introduced as part of the Katmai New Instruction set.)]125 bull1
[(These instructions are available on the Pentium III and later processors. Those which are not)]114 bull0
[(specifically SSE instructions are also available on the AMD Athlon.)]103 bull2
(115)pageodd
restore showpage
%%Page: 116 116
%%BeginPageSetup
save
%%EndPageSetup
/116 pa
[2(MMX)0( indicates that the instruction is an MMX one, and will run on MMX-capable Pentium)]681 bull1
[(processors and the Pentium II.)]670 bull2
[2(PRIV)0( indicates that the instruction is a protected-mode management instruction. Many of these)]653 bull1
[(may only be used in protected mode, or only at privilege level zero.)]642 bull2
[2(SSE)0( and )2(SSE2)0( indicate that the instruction is a Streaming SIMD Extension instruction. These)]625 bull1
[(instructions operate on multiple values in a single operation. SSE was introduced with the)]614 bull0
[(Pentium III and SSE2 was introduced with the Pentium 4.)]603 bull2
[2(UNDOC)0( indicates that the instruction is an undocumented one, and not part of the official Intel)]586 bull1
[(Architecture; it may or may not be supported on any given machine.)]575 bull2
[2(WILLAMETTE)0( indicates that the instruction was introduced as part of the new instruction set in)]558 bull1
[(the Pentium 4 and Intel Xeon processors. These instructions are also known as SSE2 instructions.)]547 bull2
[{/section-B.4 xa}(x86 Instruction Set)](B.4)527 head3
[{/section-B.4.1 xa}2(AAA)0(, )2(AAS)0(, )2(AAM)0(, )2(AAD)0(: ASCII Adjustments)](B.4.1)509 subh3
[2(AAA                           ; 37                   [8086])]492 code3
[2(AAS                           ; 3F                   [8086])]475 code3
[2(AAD                           ; D5 0A                [8086] )]458 code1
[2(AAD imm                       ; D5 ib                [8086])]447 code2
[2(AAM                           ; D4 0A                [8086] )]430 code1
[2(AAM imm                       ; D4 ib                [8086])]419 code2
[(These instructions are used in conjunction with the add, subtract, multiply and divide instructions to)]402 norm1
[(perform binary-coded decimal arithmetic in )1(unpacked)0( \(one BCD digit per byte \226 easy to translate to)]391 norm0
[(and from )2(ASCII)0(, hence the instruction names\) form. There are also packed BCD instructions )2(DAA)]380 norm0
[(and )2(DAS)0(: see ){/section-B.4.57 xl}(section B.4.57){el}(.)]369 norm2
[2(AAA)0( \(ASCII Adjust After Addition\) should be used after a one-byte )2(ADD)0( instruction whose)]352 bull1
[(destination was the )2(AL)0( register: by means of examining the value in the low nibble of )2(AL)0( and)]341 bull0
[(also the auxiliary carry flag )2(AF)0(, it determines whether the addition has overflowed, and adjusts it)]330 bull0
[(\(and sets the carry flag\) if so. You can add long BCD strings together by doing )2(ADD)0(/)2(AAA)0( on the)]319 bull0
[(low digits, then doing )2(ADC)0(/)2(AAA)0( on each subsequent digit.)]308 bull2
[2(AAS)0( \(ASCII Adjust AL After Subtraction\) works similarly to )2(AAA)0(, but is for use after )2(SUB)]291 bull1
[(instructions rather than )2(ADD)0(.)]280 bull2
[2(AAM)0( \(ASCII Adjust AX After Multiply\) is for use after you have multiplied two decimal digits)]263 bull1
[(together and left the result in )2(AL)0(: it divides )2(AL)0( by ten and stores the quotient in )2(AH)0(, leaving the)]252 bull0
[(remainder in )2(AL)0(. The divisor 10 can be changed by specifying an operand to the instruction: a)]241 bull0
[(particularly handy use of this is )2(AAM 16)0(, causing the two nibbles in )2(AL)0( to be separated into )2(AH)]230 bull0
[(and )2(AL)0(.)]219 bull2
[2(AAD)0( \(ASCII Adjust AX Before Division\) performs the inverse operation to )2(AAM)0(: it multiplies )2(AH)]202 bull1
[(by ten, adds it to )2(AL)0(, and sets )2(AH)0( to zero. Again, the multiplier 10 can be changed.)]191 bull2
[{/section-B.4.2 xa}2(ADC)0(: Add with Carry)](B.4.2)173 subh3
[2(ADC r/m8,reg8                 ; 10 /r                [8086] )]156 code1
[2(ADC r/m16,reg16               ; o16 11 /r            [8086] )]145 code0
[2(ADC r/m32,reg32               ; o32 11 /r            [386])]134 code2
(116)pageeven
restore showpage
%%Page: 117 117
%%BeginPageSetup
save
%%EndPageSetup
/117 pa
[2(ADC reg8,r/m8                 ; 12 /r                [8086] )]681 code1
[2(ADC reg16,r/m16               ; o16 13 /r            [8086] )]670 code0
[2(ADC reg32,r/m32               ; o32 13 /r            [386])]659 code2
[2(ADC r/m8,imm8                 ; 80 /2 ib             [8086] )]642 code1
[2(ADC r/m16,imm16               ; o16 81 /2 iw         [8086] )]631 code0
[2(ADC r/m32,imm32               ; o32 81 /2 id         [386])]620 code2
[2(ADC r/m16,imm8                ; o16 83 /2 ib         [8086] )]603 code1
[2(ADC r/m32,imm8                ; o32 83 /2 ib         [386])]592 code2
[2(ADC AL,imm8                   ; 14 ib                [8086] )]575 code1
[2(ADC AX,imm16                  ; o16 15 iw            [8086] )]564 code0
[2(ADC EAX,imm32                 ; o32 15 id            [386])]553 code2
[2(ADC)0( performs integer addition: it adds its two operands together, plus the value of the carry flag,)]536 norm1
[(and leaves the result in its destination \(first\) operand. The destination operand can be a register or a)]525 norm0
[(memory location. The source operand can be a register, a memory location or an immediate value.)]514 norm2
[(The flags are set according to the result of the operation: in particular, the carry flag is affected and)]497 norm1
[(can be used by a subsequent )2(ADC)0( instruction.)]486 norm2
[(In the forms with an 8-bit immediate second operand and a longer first operand, the second operand)]469 norm1
[(is considered to be signed, and is sign-extended to the length of the first operand. In these cases, the)]458 norm0
[2(BYTE)0( qualifier is necessary to force NASM to generate this form of the instruction.)]447 norm2
[(To add two numbers without also adding the contents of the carry flag, use )2(ADD)0( \(){/section-B.4.3 xl}(section B.4.3){el}(\).)]430 norm3
[{/section-B.4.3 xa}2(ADD)0(: Add Integers)](B.4.3)412 subh3
[2(ADD r/m8,reg8                 ; 00 /r                [8086] )]395 code1
[2(ADD r/m16,reg16               ; o16 01 /r            [8086] )]384 code0
[2(ADD r/m32,reg32               ; o32 01 /r            [386])]373 code2
[2(ADD reg8,r/m8                 ; 02 /r                [8086] )]356 code1
[2(ADD reg16,r/m16               ; o16 03 /r            [8086] )]345 code0
[2(ADD reg32,r/m32               ; o32 03 /r            [386])]334 code2
[2(ADD r/m8,imm8                 ; 80 /7 ib             [8086] )]317 code1
[2(ADD r/m16,imm16               ; o16 81 /7 iw         [8086] )]306 code0
[2(ADD r/m32,imm32               ; o32 81 /7 id         [386])]295 code2
[2(ADD r/m16,imm8                ; o16 83 /7 ib         [8086] )]278 code1
[2(ADD r/m32,imm8                ; o32 83 /7 ib         [386])]267 code2
[2(ADD AL,imm8                   ; 04 ib                [8086] )]250 code1
[2(ADD AX,imm16                  ; o16 05 iw            [8086] )]239 code0
[2(ADD EAX,imm32                 ; o32 05 id            [386])]228 code2
[2(ADD)0( performs integer addition: it adds its two operands together, and leaves the result in its)]211 norm1
[(destination \(first\) operand. The destination operand can be a register or a memory location. The)]200 norm0
[(source operand can be a register, a memory location or an immediate value.)]189 norm2
[(The flags are set according to the result of the operation: in particular, the carry flag is affected and)]172 norm1
[(can be used by a subsequent )2(ADC)0( instruction.)]161 norm2
[(In the forms with an 8-bit immediate second operand and a longer first operand, the second operand)]144 norm1
[(is considered to be signed, and is sign-extended to the length of the first operand. In these cases, the)]133 norm0
[2(BYTE)0( qualifier is necessary to force NASM to generate this form of the instruction.)]122 norm2
(117)pageodd
restore showpage
%%Page: 118 118
%%BeginPageSetup
save
%%EndPageSetup
/118 pa
[{/section-B.4.4 xa}2(ADDPD)0(: ADD Packed Double-Precision FP Values)](B.4.4)680 subh3
[2(ADDPD xmm1,xmm2/mem128        ; 66 0F 58 /r     [WILLAMETTE,SSE2])]663 code3
[2(ADDPD)0( performs addition on each of two packed double-precision FP value pairs.)]646 norm3
[2(   dst[0-63]   := dst[0-63]   + src[0-63], )]629 code1
[2(   dst[64-127] := dst[64-127] + src[64-127].)]618 code2
[(The destination is an )2(XMM)0( register. The source operand can be either an )2(XMM)0( register or a 128-bit)]601 norm1
[(memory location.)]590 norm2
[{/section-B.4.5 xa}2(ADDPS)0(: ADD Packed Single-Precision FP Values)](B.4.5)572 subh3
[2(ADDPS xmm1,xmm2/mem128        ; 0F 58 /r        [KATMAI,SSE])]555 code3
[2(ADDPS)0( performs addition on each of four packed single-precision FP value pairs)]538 norm3
[2(   dst[0-31]   := dst[0-31]   + src[0-31], )]521 code1
[2(   dst[32-63]  := dst[32-63]  + src[32-63], )]510 code0
[2(   dst[64-95]  := dst[64-95]  + src[64-95], )]499 code0
[2(   dst[96-127] := dst[96-127] + src[96-127].)]488 code2
[(The destination is an )2(XMM)0( register. The source operand can be either an )2(XMM)0( register or a 128-bit)]471 norm1
[(memory location.)]460 norm2
[{/section-B.4.6 xa}2(ADDSD)0(: ADD Scalar Double-Precision FP Values)](B.4.6)442 subh3
[2(ADDSD xmm1,xmm2/mem64         ; F2 0F 58 /r     [KATMAI,SSE])]425 code3
[2(ADDSD)0( adds the low double-precision FP values from the source and destination operands and)]408 norm1
[(stores the double-precision FP result in the destination operand.)]397 norm2
[2(   dst[0-63]   := dst[0-63] + src[0-63], )]380 code1
[2(   dst[64-127\) remains unchanged.)]369 code2
[(The destination is an )2(XMM)0( register. The source operand can be either an )2(XMM)0( register or a 64-bit)]352 norm1
[(memory location.)]341 norm2
[{/section-B.4.7 xa}2(ADDSS)0(: ADD Scalar Single-Precision FP Values)](B.4.7)323 subh3
[2(ADDSS xmm1,xmm2/mem32         ; F3 0F 58 /r     [WILLAMETTE,SSE2])]306 code3
[2(ADDSS)0( adds the low single-precision FP values from the source and destination operands and)]289 norm1
[(stores the single-precision FP result in the destination operand.)]278 norm2
[2(   dst[0-31]   := dst[0-31] + src[0-31], )]261 code1
[2(   dst[32-127] remains unchanged.)]250 code2
[(The destination is an )2(XMM)0( register. The source operand can be either an )2(XMM)0( register or a 32-bit)]233 norm1
[(memory location.)]222 norm2
[{/section-B.4.8 xa}2(AND)0(: Bitwise AND)](B.4.8)204 subh3
[2(AND r/m8,reg8                 ; 20 /r                [8086] )]187 code1
[2(AND r/m16,reg16               ; o16 21 /r            [8086] )]176 code0
[2(AND r/m32,reg32               ; o32 21 /r            [386])]165 code2
[2(AND reg8,r/m8                 ; 22 /r                [8086] )]148 code1
[2(AND reg16,r/m16               ; o16 23 /r            [8086] )]137 code0
[2(AND reg32,r/m32               ; o32 23 /r            [386])]126 code2
(118)pageeven
restore showpage
%%Page: 119 119
%%BeginPageSetup
save
%%EndPageSetup
/119 pa
[2(AND r/m8,imm8                 ; 80 /4 ib             [8086] )]681 code1
[2(AND r/m16,imm16               ; o16 81 /4 iw         [8086] )]670 code0
[2(AND r/m32,imm32               ; o32 81 /4 id         [386])]659 code2
[2(AND r/m16,imm8                ; o16 83 /4 ib         [8086] )]642 code1
[2(AND r/m32,imm8                ; o32 83 /4 ib         [386])]631 code2
[2(AND AL,imm8                   ; 24 ib                [8086] )]614 code1
[2(AND AX,imm16                  ; o16 25 iw            [8086] )]603 code0
[2(AND EAX,imm32                 ; o32 25 id            [386])]592 code2
[2(AND)0( performs a bitwise AND operation between its two operands \(i.e. each bit of the result is 1 if)]575 norm1
[(and only if the corresponding bits of the two inputs were both 1\), and stores the result in the)]564 norm0
[(destination \(first\) operand. The destination operand can be a register or a memory location. The)]553 norm0
[(source operand can be a register, a memory location or an immediate value.)]542 norm2
[(In the forms with an 8-bit immediate second operand and a longer first operand, the second operand)]525 norm1
[(is considered to be signed, and is sign-extended to the length of the first operand. In these cases, the)]514 norm0
[2(BYTE)0( qualifier is necessary to force NASM to generate this form of the instruction.)]503 norm2
[(The )2(MMX)0( instruction )2(PAND)0( \(see ){/section-B.4.202 xl}(section B.4.202){el}(\) performs the same operation on the 64-bit )2(MMX)]486 norm1
[(registers.)]475 norm2
[{/section-B.4.9 xa}2(ANDNPD)0(: Bitwise Logical AND NOT of Packed Double-Precision FP Values)](B.4.9)457 subh3
[2(ANDNPD xmm1,xmm2/mem128       ; 66 0F 55 /r     [WILLAMETTE,SSE2])]440 code3
[2(ANDNPD)0( inverts the bits of the two double-precision floating-point values in the destination)]423 norm1
[(register, and then performs a logical AND between the two double-precision floating-point values)]412 norm0
[(in the source operand and the temporary inverted result, storing the result in the destination register.)]401 norm2
[2(   dst[0-63]   := src[0-63]   AND NOT dst[0-63], )]384 code1
[2(   dst[64-127] := src[64-127] AND NOT dst[64-127].)]373 code2
[(The destination is an )2(XMM)0( register. The source operand can be either an )2(XMM)0( register or a 128-bit)]356 norm1
[(memory location.)]345 norm2
[{/section-B.4.10 xa}2(ANDNPS)0(: Bitwise Logical AND NOT of Packed Single-Precision FP Values)](B.4.10)327 subh3
[2(ANDNPS xmm1,xmm2/mem128       ; 0F 55 /r        [KATMAI,SSE])]310 code3
[2(ANDNPS)0( inverts the bits of the four single-precision floating-point values in the destination)]293 norm1
[(register, and then performs a logical AND between the four single-precision floating-point values)]282 norm0
[(in the source operand and the temporary inverted result, storing the result in the destination register.)]271 norm2
[2(   dst[0-31]   := src[0-31]   AND NOT dst[0-31], )]254 code1
[2(   dst[32-63]  := src[32-63]  AND NOT dst[32-63], )]243 code0
[2(   dst[64-95]  := src[64-95]  AND NOT dst[64-95], )]232 code0
[2(   dst[96-127] := src[96-127] AND NOT dst[96-127].)]221 code2
[(The destination is an )2(XMM)0( register. The source operand can be either an )2(XMM)0( register or a 128-bit)]204 norm1
[(memory location.)]193 norm2
[{/section-B.4.11 xa}2(ANDPD)0(: Bitwise Logical AND For Single FP)](B.4.11)175 subh3
[2(ANDPD xmm1,xmm2/mem128        ; 66 0F 54 /r     [WILLAMETTE,SSE2])]158 code3
[2(ANDPD)0( performs a bitwise logical AND of the two double-precision floating point values in the)]141 norm1
[(source and destination operand, and stores the result in the destination register.)]130 norm2
[2(   dst[0-63]   := src[0-63]   AND dst[0-63], )]113 code1
[2(   dst[64-127] := src[64-127] AND dst[64-127].)]102 code2
(119)pageodd
restore showpage
%%Page: 120 120
%%BeginPageSetup
save
%%EndPageSetup
/120 pa
[(The destination is an )2(XMM)0( register. The source operand can be either an )2(XMM)0( register or a 128-bit)]681 norm1
[(memory location.)]670 norm2
[{/section-B.4.12 xa}2(ANDPS)0(: Bitwise Logical AND For Single FP)](B.4.12)652 subh3
[2(ANDPS xmm1,xmm2/mem128        ; 0F 54 /r        [KATMAI,SSE])]635 code3
[2(ANDPS)0( performs a bitwise logical AND of the four single-precision floating point values in the)]618 norm1
[(source and destination operand, and stores the result in the destination register.)]607 norm2
[2(   dst[0-31]   := src[0-31]   AND dst[0-31], )]590 code1
[2(   dst[32-63]  := src[32-63]  AND dst[32-63], )]579 code0
[2(   dst[64-95]  := src[64-95]  AND dst[64-95], )]568 code0
[2(   dst[96-127] := src[96-127] AND dst[96-127].)]557 code2
[(The destination is an )2(XMM)0( register. The source operand can be either an )2(XMM)0( register or a 128-bit)]540 norm1
[(memory location.)]529 norm2
[{/section-B.4.13 xa}2(ARPL)0(: Adjust RPL Field of Selector)](B.4.13)511 subh3
[2(ARPL r/m16,reg16              ; 63 /r                [286,PRIV])]494 code3
[2(ARPL)0( expects its two word operands to be segment selectors. It adjusts the )2(RPL)0( \(requested privilege)]477 norm1
[(level \226 stored in the bottom two bits of the selector\) field of the destination \(first\) operand to ensure)]466 norm0
[(that it is no less \(i.e. no more privileged than\) the )2(RPL)0( field of the source operand. The zero flag is)]455 norm0
[(set if and only if a change had to be made.)]444 norm2
[{/section-B.4.14 xa}2(BOUND)0(: Check Array Index against Bounds)](B.4.14)426 subh3
[2(BOUND reg16,mem               ; o16 62 /r            [186] )]409 code1
[2(BOUND reg32,mem               ; o32 62 /r            [386])]398 code2
[2(BOUND)0( expects its second operand to point to an area of memory containing two signed values of)]381 norm1
[(the same size as its first operand \(i.e. two words for the 16-bit form; two doublewords for the)]370 norm0
[(32-bit form\). It performs two signed comparisons: if the value in the register passed as its first)]359 norm0
[(operand is less than the first of the in-memory values, or is greater than or equal to the second, it)]348 norm0
[(throws a )2(BR)0( exception. Otherwise, it does nothing.)]337 norm2
[{/section-B.4.15 xa}2(BSF)0(, )2(BSR)0(: Bit Scan)](B.4.15)319 subh3
[2(BSF reg16,r/m16               ; o16 0F BC /r         [386] )]302 code1
[2(BSF reg32,r/m32               ; o32 0F BC /r         [386])]291 code2
[2(BSR reg16,r/m16               ; o16 0F BD /r         [386] )]274 code1
[2(BSR reg32,r/m32               ; o32 0F BD /r         [386])]263 code2
[2(BSF)0( searches for the least significant set bit in its source \(second\) operand, and if it finds one,)]246 bull1
[(stores the index in its destination \(first\) operand. If no set bit is found, the contents of the)]235 bull0
[(destination operand are undefined. If the source operand is zero, the zero flag is set.)]224 bull2
[2(BSR)0( performs the same function, but searches from the top instead, so it finds the most)]207 bull1
[(significant set bit.)]196 bull2
[(Bit indices are from 0 \(least significant\) to 15 or 31 \(most significant\). The destination operand can)]179 norm1
[(only be a register. The source operand can be a register or a memory location.)]168 norm2
[{/section-B.4.16 xa}2(BSWAP)0(: Byte Swap)](B.4.16)150 subh3
[2(BSWAP reg32                   ; o32 0F C8+r          [486])]133 code3
[2(BSWAP)0( swaps the order of the four bytes of a 32-bit register: bits 0-7 exchange places with bits)]116 norm1
[(24-31, and bits 8-15 swap with bits 16-23. There is no explicit 16-bit equivalent: to byte-swap)]105 norm0
(120)pageeven
restore showpage
%%Page: 121 121
%%BeginPageSetup
save
%%EndPageSetup
/121 pa
[2(AX)0(, )2(BX)0(, )2(CX)0( or )2(DX)0(, )2(XCHG)0( can be used. When )2(BSWAP)0( is used with a 16-bit register, the result is)]681 norm0
[(undefined.)]670 norm2
[{/section-B.4.17 xa}2(BT)0(, )2(BTC)0(, )2(BTR)0(, )2(BTS)0(: Bit Test)](B.4.17)652 subh3
[2(BT r/m16,reg16                ; o16 0F A3 /r         [386] )]635 code1
[2(BT r/m32,reg32                ; o32 0F A3 /r         [386] )]624 code0
[2(BT r/m16,imm8                 ; o16 0F BA /4 ib      [386] )]613 code0
[2(BT r/m32,imm8                 ; o32 0F BA /4 ib      [386])]602 code2
[2(BTC r/m16,reg16               ; o16 0F BB /r         [386] )]585 code1
[2(BTC r/m32,reg32               ; o32 0F BB /r         [386] )]574 code0
[2(BTC r/m16,imm8                ; o16 0F BA /7 ib      [386] )]563 code0
[2(BTC r/m32,imm8                ; o32 0F BA /7 ib      [386])]552 code2
[2(BTR r/m16,reg16               ; o16 0F B3 /r         [386] )]535 code1
[2(BTR r/m32,reg32               ; o32 0F B3 /r         [386] )]524 code0
[2(BTR r/m16,imm8                ; o16 0F BA /6 ib      [386] )]513 code0
[2(BTR r/m32,imm8                ; o32 0F BA /6 ib      [386])]502 code2
[2(BTS r/m16,reg16               ; o16 0F AB /r         [386] )]485 code1
[2(BTS r/m32,reg32               ; o32 0F AB /r         [386] )]474 code0
[2(BTS r/m16,imm                 ; o16 0F BA /5 ib      [386] )]463 code0
[2(BTS r/m32,imm                 ; o32 0F BA /5 ib      [386])]452 code2
[(These instructions all test one bit of their first operand, whose index is given by the second operand,)]435 norm1
[(and store the value of that bit into the carry flag. Bit indices are from 0 \(least significant\) to 15 or 31)]424 norm0
[(\(most significant\).)]413 norm2
[(In addition to storing the original value of the bit into the carry flag, )2(BTR)0( also resets \(clears\) the bit)]396 norm1
[(in the operand itself. )2(BTS)0( sets the bit, and )2(BTC)0( complements the bit. )2(BT)0( does not modify its)]385 norm0
[(operands.)]374 norm2
[(The destination can be a register or a memory location. The source can be a register or an)]357 norm1
[(immediate value.)]346 norm2
[(If the destination operand is a register, the bit offset should be in the range 0-15 \(for 16-bit)]329 norm1
[(operands\) or 0-31 \(for 32-bit operands\). An immediate value outside these ranges will be taken)]318 norm0
[(modulo 16/32 by the processor.)]307 norm2
[(If the destination operand is a memory location, then an immediate bit offset follows the same rules)]290 norm1
[(as for a register. If the bit offset is in a register, then it can be anything within the signed range of)]279 norm0
[(the register used \(ie, for a 32-bit operand, it can be \(-2^31\) to \(2^31 \226 1\))]268 norm2
[{/section-B.4.18 xa}2(CALL)0(: Call Subroutine)](B.4.18)250 subh3
[2(CALL imm                      ; E8 rw/rd             [8086] )]233 code1
[2(CALL imm:imm16                ; o16 9A iw iw         [8086] )]222 code0
[2(CALL imm:imm32                ; o32 9A id iw         [386] )]211 code0
[2(CALL FAR mem16                ; o16 FF /3            [8086] )]200 code0
[2(CALL FAR mem32                ; o32 FF /3            [386] )]189 code0
[2(CALL r/m16                    ; o16 FF /2            [8086] )]178 code0
[2(CALL r/m32                    ; o32 FF /2            [386])]167 code2
[2(CALL)0( calls a subroutine, by means of pushing the current instruction pointer \()2(IP)0(\) and optionally )2(CS)]150 norm1
[(as well on the stack, and then jumping to a given address.)]139 norm2
[2(CS)0( is pushed as well as )2(IP)0( if and only if the call is a far call, i.e. a destination segment address is)]122 norm1
[(specified in the instruction. The forms involving two colon-separated arguments are far calls; so are)]111 norm0
[(the )2(CALL FAR mem)0( forms.)]100 norm2
(121)pageodd
restore showpage
%%Page: 122 122
%%BeginPageSetup
save
%%EndPageSetup
/122 pa
[(The immediate )(near call takes one of two forms \()2(call imm16/imm32)0(, determined by the current)]681 norm1
[(segment size limit. For 16-bit operands, you would use )2(CALL 0x1234)0(, and for 32-bit operands)]670 norm0
[(you would use )2(CALL 0x12345678)0(. The value passed as an operand is a relative offset.)]659 norm2
[(You can choose between the two immediate )(far call forms \()2(CALL imm:imm)0(\) by the use of the)]642 norm1
[2(WORD)0( and )2(DWORD)0( keywords: )2(CALL WORD 0x1234:0x5678)0(\) or)]631 norm0
[2(CALL DWORD 0x1234:0x56789abc)0(.)]620 norm2
[(The )2(CALL FAR mem)0( forms execute a far call by loading the destination address out of memory.)]603 norm1
[(The address loaded consists of 16 or 32 bits of offset \(depending on the operand size\), and 16 bits of)]592 norm0
[(segment. The operand size may be overridden using )2(CALL WORD FAR mem)0( or)]581 norm0
[2(CALL DWORD FAR mem)0(.)]570 norm2
[(The )2(CALL r/m)0( forms execute a )(near call \(within the same segment\), loading the destination)]553 norm1
[(address out of memory or out of a register. The keyword )2(NEAR)0( may be specified, for clarity, in)]542 norm0
[(these forms, but is not necessary. Again, operand size can be overridden using )2(CALL WORD mem)]531 norm0
[(or )2(CALL DWORD mem)0(.)]520 norm2
[(As a convenience, NASM does not require you to call a far procedure symbol by coding the)]503 norm1
[(cumbersome )2(CALL SEG routine:routine)0(, but instead allows the easier synonym)]492 norm0
[2(CALL FAR routine)0(.)]481 norm2
[(The )2(CALL r/m)0( forms given above are near calls; NASM will accept the )2(NEAR)0( keyword \(e.g.)]464 norm1
[2(CALL NEAR [address])0(\), even though it is not strictly necessary.)]453 norm2
[{/section-B.4.19 xa}2(CBW)0(, )2(CWD)0(, )2(CDQ)0(, )2(CWDE)0(: Sign Extensions)](B.4.19)435 subh3
[2(CBW                           ; o16 98               [8086] )]418 code1
[2(CWDE                          ; o32 98               [386])]407 code2
[2(CWD                           ; o16 99               [8086] )]390 code1
[2(CDQ                           ; o32 99               [386])]379 code2
[(All these instructions sign-extend a short value into a longer one, by replicating the top bit of the)]362 norm1
[(original value to fill the extended one.)]351 norm2
[2(CBW)0( extends )2(AL)0( into )2(AX)0( by repeating the top bit of )2(AL)0( in every bit of )2(AH)0(. )2(CWDE)0( extends )2(AX)0( into)]334 norm1
[2(EAX)0(. )2(CWD)0( extends )2(AX)0( into )2(DX:AX)0( by repeating the top bit of )2(AX)0( throughout )2(DX)0(, and )2(CDQ)0( extends)]323 norm0
[2(EAX)0( into )2(EDX:EAX)0(.)]312 norm2
[{/section-B.4.20 xa}2(CLC)0(, )2(CLD)0(, )2(CLI)0(, )2(CLTS)0(: Clear Flags)](B.4.20)294 subh3
[2(CLC                           ; F8                   [8086] )]277 code1
[2(CLD                           ; FC                   [8086] )]266 code0
[2(CLI                           ; FA                   [8086] )]255 code0
[2(CLTS                          ; 0F 06                [286,PRIV])]244 code2
[(These instructions clear various flags. )2(CLC)0( clears the carry flag; )2(CLD)0( clears the direction flag; )2(CLI)]227 norm1
[(clears the interrupt flag \(thus disabling interrupts\); and )2(CLTS)0( clears the task-switched \()2(TS)0(\) flag in)]216 norm0
[2(CR0)0(.)]205 norm2
[(To set the carry, direction, or interrupt flags, use the )2(STC)0(, )2(STD)0( and )2(STI)0( instructions \(){/section-B.4.301 xl}(section){el}]188 norm1
[{/section-B.4.301 xl}(B.4.301){el}(\). To invert the carry flag, use )2(CMC)0( \(){/section-B.4.22 xl}(section B.4.22){el}(\).)]177 norm2
[{/section-B.4.21 xa}2(CLFLUSH)0(: Flush Cache Line)](B.4.21)159 subh3
[2(CLFLUSH mem                   ; 0F AE /7        [WILLAMETTE,SSE2])]142 code3
[2(CLFLUSH)0( invalidates the cache line that contains the linear address specified by the source operand)]125 norm1
[(from all levels of the processor cache hierarchy \(data and instruction\). If, at any level of the cache)]114 norm0
(122)pageeven
restore showpage
%%Page: 123 123
%%BeginPageSetup
save
%%EndPageSetup
/123 pa
[(hierarchy, the line is inconsistent with memory \(dirty\) it is written to memory before invalidation.)]681 norm0
[(The source operand points to a byte-sized memory location.)]670 norm2
[(Although )2(CLFLUSH)0( is flagged )2(SSE2)0( and above, it may not be present on all processors which have)]653 norm1
[2(SSE2)0( support, and it may be supported on other processors; the )2(CPUID)0( instruction \(){/section-B.4.34 xl}(section B.4.34){el}(\))]642 norm0
[(will return a bit which indicates support for the )2(CLFLUSH)0( instruction.)]631 norm2
[{/section-B.4.22 xa}2(CMC)0(: Complement Carry Flag)](B.4.22)613 subh3
[2(CMC                           ; F5                   [8086])]596 code3
[2(CMC)0( changes the value of the carry flag: if it was 0, it sets it to 1, and vice versa.)]579 norm3
[{/section-B.4.23 xa}2(CMOVcc)0(: Conditional Move)](B.4.23)561 subh3
[2(CMOVcc reg16,r/m16            ; o16 0F 40+cc /r      [P6] )]544 code1
[2(CMOVcc reg32,r/m32            ; o32 0F 40+cc /r      [P6])]533 code2
[2(CMOV)0( moves its source \(second\) operand into its destination \(first\) operand if the given condition)]516 norm1
[(code is satisfied; otherwise it does nothing.)]505 norm2
[(For a list of condition codes, see ){/section-B.2.2 xl}(section B.2.2){el}(.)]488 norm3
[(Although the )2(CMOV)0( instructions are flagged )2(P6)0( and above, they may not be supported by all)]471 norm1
[(Pentium Pro processors; the )2(CPUID)0( instruction \(){/section-B.4.34 xl}(section B.4.34){el}(\) will return a bit which indicates)]460 norm0
[(whether conditional moves are supported.)]449 norm2
[{/section-B.4.24 xa}2(CMP)0(: Compare Integers)](B.4.24)431 subh3
[2(CMP r/m8,reg8                 ; 38 /r                [8086] )]414 code1
[2(CMP r/m16,reg16               ; o16 39 /r            [8086] )]403 code0
[2(CMP r/m32,reg32               ; o32 39 /r            [386])]392 code2
[2(CMP reg8,r/m8                 ; 3A /r                [8086] )]375 code1
[2(CMP reg16,r/m16               ; o16 3B /r            [8086] )]364 code0
[2(CMP reg32,r/m32               ; o32 3B /r            [386])]353 code2
[2(CMP r/m8,imm8                 ; 80 /7 ib             [8086] )]336 code1
[2(CMP r/m16,imm16               ; o16 81 /7 iw         [8086] )]325 code0
[2(CMP r/m32,imm32               ; o32 81 /7 id         [386])]314 code2
[2(CMP r/m16,imm8                ; o16 83 /7 ib         [8086] )]297 code1
[2(CMP r/m32,imm8                ; o32 83 /7 ib         [386])]286 code2
[2(CMP AL,imm8                   ; 3C ib                [8086] )]269 code1
[2(CMP AX,imm16                  ; o16 3D iw            [8086] )]258 code0
[2(CMP EAX,imm32                 ; o32 3D id            [386])]247 code2
[2(CMP)0( performs a `mental' subtraction of its second operand from its first operand, and affects the)]230 norm1
[(flags as if the subtraction had taken place, but does not store the result of the subtraction anywhere.)]219 norm2
[(In the forms with an 8-bit immediate second operand and a longer first operand, the second operand)]202 norm1
[(is considered to be signed, and is sign-extended to the length of the first operand. In these cases, the)]191 norm0
[2(BYTE)0( qualifier is necessary to force NASM to generate this form of the instruction.)]180 norm2
[(The destination operand can be a register or a memory location. The source can be a register,)]163 norm1
[(memory location or an immediate value of the same size as the destination.)]152 norm2
[{/section-B.4.25 xa}2(CMPccPD)0(: Packed Double-Precision FP Compare )( )( )( )( )( )( )( )](B.4.25)134 subh3
[2(CMPPD xmm1,xmm2/mem128,imm8   ; 66 0F C2 /r ib  [WILLAMETTE,SSE2])]117 code3
(123)pageodd
restore showpage
%%Page: 124 124
%%BeginPageSetup
save
%%EndPageSetup
/124 pa
[2(CMPEQPD xmm1,xmm2/mem128      ; 66 0F C2 /r 00  [WILLAMETTE,SSE2] )]681 code1
[2(CMPLTPD xmm1,xmm2/mem128      ; 66 0F C2 /r 01  [WILLAMETTE,SSE2] )]670 code0
[2(CMPLEPD xmm1,xmm2/mem128      ; 66 0F C2 /r 02  [WILLAMETTE,SSE2] )]659 code0
[2(CMPUNORDPD xmm1,xmm2/mem128   ; 66 0F C2 /r 03  [WILLAMETTE,SSE2] )]648 code0
[2(CMPNEQPD xmm1,xmm2/mem128     ; 66 0F C2 /r 04  [WILLAMETTE,SSE2] )]637 code0
[2(CMPNLTPD xmm1,xmm2/mem128     ; 66 0F C2 /r 05  [WILLAMETTE,SSE2] )]626 code0
[2(CMPNLEPD xmm1,xmm2/mem128     ; 66 0F C2 /r 06  [WILLAMETTE,SSE2] )]615 code0
[2(CMPORDPD xmm1,xmm2/mem128     ; 66 0F C2 /r 07  [WILLAMETTE,SSE2])]604 code2
[(The )2(CMPccPD)0( instructions compare the two packed double-precision FP values in the source and)]587 norm1
[(destination operands, and returns the result of the comparison in the destination register. The result)]576 norm0
[(of each comparison is a quadword mask of all 1s \(comparison true\) or all 0s \(comparison false\).)]565 norm2
[(The destination is an )2(XMM)0( register. The source can be either an )2(XMM)0( register or a 128-bit memory)]548 norm1
[(location.)]537 norm2
[(The third operand is an 8-bit immediate value, of which the low 3 bits define the type of)]520 norm1
[(comparison. For ease of programming, the 8 two-operand pseudo-instructions are provided, with)]509 norm0
[(the third operand already filled in. The )( )2(Condition Predicates)0( are:)]498 norm2
[2(EQ     0   Equal )]481 code1
[2(LT     1   Less-than )]470 code0
[2(LE     2   Less-than-or-equal )]459 code0
[2(UNORD  3   Unordered )]448 code0
[2(NE     4   Not-equal )]437 code0
[2(NLT    5   Not-less-than )]426 code0
[2(NLE    6   Not-less-than-or-equal )]415 code0
[2(ORD    7   Ordered)]404 code2
[(For more details of the comparison predicates, and details of how to emulate the "greater-than")]387 norm1
[(equivalents, see ){/section-B.2.3 xl}(section B.2.3){el}]376 norm2
[{/section-B.4.26 xa}2(CMPccPS)0(: Packed Single-Precision FP Compare )( )( )( )( )( )( )( )](B.4.26)358 subh3
[2(CMPPS xmm1,xmm2/mem128,imm8   ; 0F C2 /r ib     [KATMAI,SSE])]341 code3
[2(CMPEQPS xmm1,xmm2/mem128      ; 0F C2 /r 00     [KATMAI,SSE] )]324 code1
[2(CMPLTPS xmm1,xmm2/mem128      ; 0F C2 /r 01     [KATMAI,SSE] )]313 code0
[2(CMPLEPS xmm1,xmm2/mem128      ; 0F C2 /r 02     [KATMAI,SSE] )]302 code0
[2(CMPUNORDPS xmm1,xmm2/mem128   ; 0F C2 /r 03     [KATMAI,SSE] )]291 code0
[2(CMPNEQPS xmm1,xmm2/mem128     ; 0F C2 /r 04     [KATMAI,SSE] )]280 code0
[2(CMPNLTPS xmm1,xmm2/mem128     ; 0F C2 /r 05     [KATMAI,SSE] )]269 code0
[2(CMPNLEPS xmm1,xmm2/mem128     ; 0F C2 /r 06     [KATMAI,SSE] )]258 code0
[2(CMPORDPS xmm1,xmm2/mem128     ; 0F C2 /r 07     [KATMAI,SSE])]247 code2
[(The )2(CMPccPS)0( instructions compare the two packed single-precision FP values in the source and)]230 norm1
[(destination operands, and returns the result of the comparison in the destination register. The result)]219 norm0
[(of each comparison is a doubleword mask of all 1s \(comparison true\) or all 0s \(comparison false\).)]208 norm2
[(The destination is an )2(XMM)0( register. The source can be either an )2(XMM)0( register or a 128-bit memory)]191 norm1
[(location.)]180 norm2
[(The third operand is an 8-bit immediate value, of which the low 3 bits define the type of)]163 norm1
[(comparison. For ease of programming, the 8 two-operand pseudo-instructions are provided, with)]152 norm0
[(the third operand already filled in. The )( )2(Condition Predicates)0( are:)]141 norm2
[2(EQ     0   Equal )]124 code1
[2(LT     1   Less-than )]113 code0
[2(LE     2   Less-than-or-equal )]102 code0
(124)pageeven
restore showpage
%%Page: 125 125
%%BeginPageSetup
save
%%EndPageSetup
/125 pa
[2(UNORD  3   Unordered )]681 code0
[2(NE     4   Not-equal )]670 code0
[2(NLT    5   Not-less-than )]659 code0
[2(NLE    6   Not-less-than-or-equal )]648 code0
[2(ORD    7   Ordered)]637 code2
[(For more details of the comparison predicates, and details of how to emulate the "greater-than")]620 norm1
[(equivalents, see ){/section-B.2.3 xl}(section B.2.3){el}]609 norm2
[{/section-B.4.27 xa}2(CMPSB)0(, )2(CMPSW)0(, )2(CMPSD)0(: Compare Strings)](B.4.27)591 subh3
[2(CMPSB                         ; A6                   [8086] )]574 code1
[2(CMPSW                         ; o16 A7               [8086] )]563 code0
[2(CMPSD                         ; o32 A7               [386])]552 code2
[2(CMPSB)0( compares the byte at )2([DS:SI])0( or )2([DS:ESI])0( with the byte at )2([ES:DI])0( or )2([ES:EDI])0(,)]535 norm1
[(and sets the flags accordingly. It then increments or decrements \(depending on the direction flag:)]524 norm0
[(increments if the flag is clear, decrements if it is set\) )2(SI)0( and )2(DI)0( \(or )2(ESI)0( and )2(EDI)0(\).)]513 norm2
[(The registers used are )2(SI)0( and )2(DI)0( if the address size is 16 bits, and )2(ESI)0( and )2(EDI)0( if it is 32 bits. If)]496 norm1
[(you need to use an address size not equal to the current )2(BITS)0( setting, you can use an explicit )2(a16)]485 norm0
[(or )2(a32)0( prefix.)]474 norm2
[(The segment register used to load from )2([SI])0( or )2([ESI])0( can be overridden by using a segment)]457 norm1
[(register name as a prefix \(for example, )2(ES CMPSB)0(\). The use of )2(ES)0( for the load from )2([DI])0( or)]446 norm0
[2([EDI])0( cannot be overridden.)]435 norm2
[2(CMPSW)0( and )2(CMPSD)0( work in the same way, but they compare a word or a doubleword instead of a)]418 norm1
[(byte, and increment or decrement the addressing registers by 2 or 4 instead of 1.)]407 norm2
[(The )2(REPE)0( and )2(REPNE)0( prefixes \(equivalently, )2(REPZ)0( and )2(REPNZ)0(\) may be used to repeat the)]390 norm1
[(instruction up to )2(CX)0( \(or )2(ECX)0( \226 again, the address size chooses which\) times until the first unequal or)]379 norm0
[(equal byte is found.)]368 norm2
[{/section-B.4.28 xa}2(CMPccSD)0(: Scalar Double-Precision FP Compare )( )( )( )( )( )( )( )](B.4.28)350 subh3
[2(CMPSD xmm1,xmm2/mem64,imm8    ; F2 0F C2 /r ib  [WILLAMETTE,SSE2])]333 code3
[2(CMPEQSD xmm1,xmm2/mem64       ; F2 0F C2 /r 00  [WILLAMETTE,SSE2] )]316 code1
[2(CMPLTSD xmm1,xmm2/mem64       ; F2 0F C2 /r 01  [WILLAMETTE,SSE2] )]305 code0
[2(CMPLESD xmm1,xmm2/mem64       ; F2 0F C2 /r 02  [WILLAMETTE,SSE2] )]294 code0
[2(CMPUNORDSD xmm1,xmm2/mem64    ; F2 0F C2 /r 03  [WILLAMETTE,SSE2] )]283 code0
[2(CMPNEQSD xmm1,xmm2/mem64      ; F2 0F C2 /r 04  [WILLAMETTE,SSE2] )]272 code0
[2(CMPNLTSD xmm1,xmm2/mem64      ; F2 0F C2 /r 05  [WILLAMETTE,SSE2] )]261 code0
[2(CMPNLESD xmm1,xmm2/mem64      ; F2 0F C2 /r 06  [WILLAMETTE,SSE2] )]250 code0
[2(CMPORDSD xmm1,xmm2/mem64      ; F2 0F C2 /r 07  [WILLAMETTE,SSE2])]239 code2
[(The )2(CMPccSD)0( instructions compare the low-order double-precision FP values in the source and)]222 norm1
[(destination operands, and returns the result of the comparison in the destination register. The result)]211 norm0
[(of each comparison is a quadword mask of all 1s \(comparison true\) or all 0s \(comparison false\).)]200 norm2
[(The destination is an )2(XMM)0( register. The source can be either an )2(XMM)0( register or a 128-bit memory)]183 norm1
[(location.)]172 norm2
[(The third operand is an 8-bit immediate value, of which the low 3 bits define the type of)]155 norm1
[(comparison. For ease of programming, the 8 two-operand pseudo-instructions are provided, with)]144 norm0
[(the third operand already filled in. The )( )2(Condition Predicates)0( are:)]133 norm2
[2(EQ     0   Equal )]116 code1
[2(LT     1   Less-than )]105 code0
(125)pageodd
restore showpage
%%Page: 126 126
%%BeginPageSetup
save
%%EndPageSetup
/126 pa
[2(LE     2   Less-than-or-equal )]681 code0
[2(UNORD  3   Unordered )]670 code0
[2(NE     4   Not-equal )]659 code0
[2(NLT    5   Not-less-than )]648 code0
[2(NLE    6   Not-less-than-or-equal )]637 code0
[2(ORD    7   Ordered)]626 code2
[(For more details of the comparison predicates, and details of how to emulate the "greater-than")]609 norm1
[(equivalents, see ){/section-B.2.3 xl}(section B.2.3){el}]598 norm2
[{/section-B.4.29 xa}2(CMPccSS)0(: Scalar Single-Precision FP Compare )( )( )( )( )( )( )( )](B.4.29)580 subh3
[2(CMPSS xmm1,xmm2/mem32,imm8    ; F3 0F C2 /r ib  [KATMAI,SSE])]563 code3
[2(CMPEQSS xmm1,xmm2/mem32       ; F3 0F C2 /r 00  [KATMAI,SSE] )]546 code1
[2(CMPLTSS xmm1,xmm2/mem32       ; F3 0F C2 /r 01  [KATMAI,SSE] )]535 code0
[2(CMPLESS xmm1,xmm2/mem32       ; F3 0F C2 /r 02  [KATMAI,SSE] )]524 code0
[2(CMPUNORDSS xmm1,xmm2/mem32    ; F3 0F C2 /r 03  [KATMAI,SSE] )]513 code0
[2(CMPNEQSS xmm1,xmm2/mem32      ; F3 0F C2 /r 04  [KATMAI,SSE] )]502 code0
[2(CMPNLTSS xmm1,xmm2/mem32      ; F3 0F C2 /r 05  [KATMAI,SSE] )]491 code0
[2(CMPNLESS xmm1,xmm2/mem32      ; F3 0F C2 /r 06  [KATMAI,SSE] )]480 code0
[2(CMPORDSS xmm1,xmm2/mem32      ; F3 0F C2 /r 07  [KATMAI,SSE])]469 code2
[(The )2(CMPccSS)0( instructions compare the low-order single-precision FP values in the source and)]452 norm1
[(destination operands, and returns the result of the comparison in the destination register. The result)]441 norm0
[(of each comparison is a doubleword mask of all 1s \(comparison true\) or all 0s \(comparison false\).)]430 norm2
[(The destination is an )2(XMM)0( register. The source can be either an )2(XMM)0( register or a 128-bit memory)]413 norm1
[(location.)]402 norm2
[(The third operand is an 8-bit immediate value, of which the low 3 bits define the type of)]385 norm1
[(comparison. For ease of programming, the 8 two-operand pseudo-instructions are provided, with)]374 norm0
[(the third operand already filled in. The )( )2(Condition Predicates)0( are:)]363 norm2
[2(EQ     0   Equal )]346 code1
[2(LT     1   Less-than )]335 code0
[2(LE     2   Less-than-or-equal )]324 code0
[2(UNORD  3   Unordered )]313 code0
[2(NE     4   Not-equal )]302 code0
[2(NLT    5   Not-less-than )]291 code0
[2(NLE    6   Not-less-than-or-equal )]280 code0
[2(ORD    7   Ordered)]269 code2
[(For more details of the comparison predicates, and details of how to emulate the "greater-than")]252 norm1
[(equivalents, see ){/section-B.2.3 xl}(section B.2.3){el}]241 norm2
[{/section-B.4.30 xa}2(CMPXCHG)0(, )2(CMPXCHG486)0(: Compare and Exchange)](B.4.30)223 subh3
[2(CMPXCHG r/m8,reg8             ; 0F B0 /r             [PENT] )]206 code1
[2(CMPXCHG r/m16,reg16           ; o16 0F B1 /r         [PENT] )]195 code0
[2(CMPXCHG r/m32,reg32           ; o32 0F B1 /r         [PENT])]184 code2
[2(CMPXCHG486 r/m8,reg8          ; 0F A6 /r             [486,UNDOC] )]167 code1
[2(CMPXCHG486 r/m16,reg16        ; o16 0F A7 /r         [486,UNDOC] )]156 code0
[2(CMPXCHG486 r/m32,reg32        ; o32 0F A7 /r         [486,UNDOC])]145 code2
[(These two instructions perform exactly the same operation; however, apparently some \(not all\) 486)]128 norm1
[(processors support it under a non-standard opcode, so NASM provides the undocumented)]117 norm0
[2(CMPXCHG486)0( form to generate the non-standard opcode.)]106 norm2
(126)pageeven
restore showpage
%%Page: 127 127
%%BeginPageSetup
save
%%EndPageSetup
/127 pa
[2(CMPXCHG)0( compares its destination \(first\) operand to the value in )2(AL)0(, )2(AX)0( or )2(EAX)0( \(depending on the)]681 norm1
[(operand size of the instruction\). If they are equal, it copies its source \(second\) operand into the)]670 norm0
[(destination and sets the zero flag. Otherwise, it clears the zero flag and copies the destination)]659 norm0
[(register to AL, AX or EAX.)]648 norm2
[(The destination can be either a register or a memory location. The source is a register.)]631 norm3
[2(CMPXCHG)0( is intended to be used for atomic operations in multitasking or multiprocessor)]614 norm1
[(environments. To safely update a value in shared memory, for example, you might load the value)]603 norm0
[(into )2(EAX)0(, load the updated value into )2(EBX)0(, and then execute the instruction)]592 norm0
[2(LOCK CMPXCHG [value],EBX)0(. If )2(value)0( has not changed since being loaded, it is updated)]581 norm0
[(with your desired new value, and the zero flag is set to let you know it has worked. \(The )2(LOCK)]570 norm0
[(prefix prevents another processor doing anything in the middle of this operation: it guarantees)]559 norm0
[(atomicity.\) However, if another processor has modified the value in between your load and your)]548 norm0
[(attempted store, the store does not happen, and you are notified of the failure by a cleared zero flag,)]537 norm0
[(so you can go round and try again.)]526 norm2
[{/section-B.4.31 xa}2(CMPXCHG8B)0(: Compare and Exchange Eight Bytes)](B.4.31)508 subh3
[2(CMPXCHG8B mem                 ; 0F C7 /1             [PENT])]491 code3
[(This is a larger and more unwieldy version of )2(CMPXCHG)0(: it compares the 64-bit \(eight-byte\) value)]474 norm1
[(stored at )2([mem])0( with the value in )2(EDX:EAX)0(. If they are equal, it sets the zero flag and stores)]463 norm0
[2(ECX:EBX)0( into the memory area. If they are unequal, it clears the zero flag and stores the memory)]452 norm0
[(contents into )2(EDX:EAX)0(.)]441 norm2
[2(CMPXCHG8B)0( can be used with the )2(LOCK)0( prefix, to allow atomic execution. This is useful in)]424 norm1
[(multi-processor and multi-tasking environments.)]413 norm2
[{/section-B.4.32 xa}2(COMISD)0(: Scalar Ordered Double-Precision FP Compare and Set EFLAGS)](B.4.32)395 subh3
[2(COMISD xmm1,xmm2/mem64        ; 66 0F 2F /r     [WILLAMETTE,SSE2])]378 code3
[2(COMISD)0( compares the low-order double-precision FP value in the two source operands. ZF, PF)]361 norm1
[(and CF are set according to the result. OF, AF and AF are cleared. The unordered result is returned)]350 norm0
[(if either source is a NaN \(QNaN or SNaN\).)]339 norm2
[(The destination operand is an )2(XMM)0( register. The source can be either an )2(XMM)0( register or a memory)]322 norm1
[(location.)]311 norm2
[(The flags are set according to the following rules:)]294 norm3
[2(   Result          Flags        Values)]277 code3
[2(   UNORDERED:      ZF,PF,CF <-- 111; )]260 code1
[2(   GREATER_THAN:   ZF,PF,CF <-- 000; )]249 code0
[2(   LESS_THAN:      ZF,PF,CF <-- 001; )]238 code0
[2(   EQUAL:          ZF,PF,CF <-- 100;)]227 code2
[{/section-B.4.33 xa}2(COMISS)0(: Scalar Ordered Single-Precision FP Compare and Set EFLAGS)](B.4.33)209 subh3
[2(COMISS xmm1,xmm2/mem32        ; 66 0F 2F /r     [KATMAI,SSE])]192 code3
[2(COMISS)0( compares the low-order single-precision FP value in the two source operands. ZF, PF and)]175 norm1
[(CF are set according to the result. OF, AF and AF are cleared. The unordered result is returned if)]164 norm0
[(either source is a NaN \(QNaN or SNaN\).)]153 norm2
[(The destination operand is an )2(XMM)0( register. The source can be either an )2(XMM)0( register or a memory)]136 norm1
[(location.)]125 norm2
[(The flags are set according to the following rules:)]108 norm3
(127)pageodd
restore showpage
%%Page: 128 128
%%BeginPageSetup
save
%%EndPageSetup
/128 pa
[2(   Result          Flags        Values)]681 code3
[2(   UNORDERED:      ZF,PF,CF <-- 111; )]664 code1
[2(   GREATER_THAN:   ZF,PF,CF <-- 000; )]653 code0
[2(   LESS_THAN:      ZF,PF,CF <-- 001; )]642 code0
[2(   EQUAL:          ZF,PF,CF <-- 100;)]631 code2
[{/section-B.4.34 xa}2(CPUID)0(: Get CPU Identification Code)](B.4.34)613 subh3
[2(CPUID                         ; 0F A2                [PENT])]596 code3
[2(CPUID)0( returns various information about the processor it is being executed on. It fills the four)]579 norm1
[(registers )2(EAX)0(, )2(EBX)0(, )2(ECX)0( and )2(EDX)0( with information, which varies depending on the input contents)]568 norm0
[(of )2(EAX)0(.)]557 norm2
[2(CPUID)0( also acts as a barrier to serialise instruction execution: executing the )2(CPUID)0( instruction)]540 norm1
[(guarantees that all the effects \(memory modification, flag modification, register modification\) of)]529 norm0
[(previous instructions have been completed before the next instruction gets fetched.)]518 norm2
[(The information returned is as follows:)]501 norm3
[(If )2(EAX)0( is zero on input, )2(EAX)0( on output holds the maximum acceptable input value of )2(EAX)0(, and)]484 bull1
[2(EBX:EDX:ECX)0( contain the string )2("GenuineIntel")0( \(or not, if you have a clone processor\).)]473 bull0
[(That is to say, )2(EBX)0( contains )2("Genu")0( \(in NASM's own sense of character constants, described in)]462 bull0
[{/section-3.4.2 xl}(section 3.4.2){el}(\), )2(EDX)0( contains )2("ineI")0( and )2(ECX)0( contains )2("ntel")0(.)]451 bull2
[(If )2(EAX)0( is one on input, )2(EAX)0( on output contains version information about the processor, and )2(EDX)]434 bull1
[(contains a set of feature flags, showing the presence and absence of various features. For)]423 bull0
[(example, bit 8 is set if the )2(CMPXCHG8B)0( instruction \(){/section-B.4.31 xl}(section B.4.31){el}(\) is supported, bit 15 is set if)]412 bull0
[(the conditional move instructions \(){/section-B.4.23 xl}(section B.4.23){el}( and ){/section-B.4.72 xl}(section B.4.72){el}(\) are supported, and bit 23 is)]401 bull0
[(set if )2(MMX)0( instructions are supported.)]390 bull2
[(If )2(EAX)0( is two on input, )2(EAX)0(, )2(EBX)0(, )2(ECX)0( and )2(EDX)0( all contain information about caches and TLBs)]373 bull1
[(\(Translation Lookahead Buffers\).)]362 bull2
[(For more information on the data returned from )2(CPUID)0(, see the documentation from Intel and other)]345 norm1
[(processor manufacturers.)]334 norm2
[{/section-B.4.35 xa}2(CVTDQ2PD)0(: Packed Signed INT32 to Packed Double-Precision FP Conversion)](B.4.35)316 subh3
[2(CVTDQ2PD xmm1,xmm2/mem64      ; F3 0F E6 /r     [WILLAMETTE,SSE2])]299 code3
[2(CVTDQ2PD)0( converts two packed signed doublewords from the source operand to two packed)]282 norm1
[(double-precision FP values in the destination operand.)]271 norm2
[(The destination operand is an )2(XMM)0( register. The source can be either an )2(XMM)0( register or a 64-bit)]254 norm1
[(memory location. If the source is a register, the packed integers are in the low quadword.)]243 norm2
[{/section-B.4.36 xa}2(CVTDQ2PS)0(: Packed Signed INT32 to Packed Single-Precision FP Conversion)](B.4.36)225 subh3
[2(CVTDQ2PS xmm1,xmm2/mem128     ; 0F 5B /r        [WILLAMETTE,SSE2])]208 code3
[2(CVTDQ2PS)0( converts four packed signed doublewords from the source operand to four packed)]191 norm1
[(single-precision FP values in the destination operand.)]180 norm2
[(The destination operand is an )2(XMM)0( register. The source can be either an )2(XMM)0( register or a 128-bit)]163 norm1
[(memory location.)]152 norm2
[(For more details of this instruction, see the Intel Processor manuals.)]135 norm3
[{/section-B.4.37 xa}2(CVTPD2DQ)0(: Packed Double-Precision FP to Packed Signed INT32 Conversion)](B.4.37)117 subh3
[2(CVTPD2DQ xmm1,xmm2/mem128     ; F2 0F E6 /r     [WILLAMETTE,SSE2])]100 code3
(128)pageeven
restore showpage
%%Page: 129 129
%%BeginPageSetup
save
%%EndPageSetup
/129 pa
[2(CVTPD2DQ)0( converts two packed double-precision FP values from the source operand to two)]681 norm1
[(packed signed doublewords in the low quadword of the destination operand. The high quadword of)]670 norm0
[(the destination is set to all 0s.)]659 norm2
[(The destination operand is an )2(XMM)0( register. The source can be either an )2(XMM)0( register or a 128-bit)]642 norm1
[(memory location.)]631 norm2
[(For more details of this instruction, see the Intel Processor manuals.)]614 norm3
[{/section-B.4.38 xa}2(CVTPD2PI)0(: Packed Double-Precision FP to Packed Signed INT32 Conversion)](B.4.38)596 subh3
[2(CVTPD2PI mm,xmm/mem128        ; 66 0F 2D /r     [WILLAMETTE,SSE2])]579 code3
[2(CVTPD2PI)0( converts two packed double-precision FP values from the source operand to two)]562 norm1
[(packed signed doublewords in the destination operand.)]551 norm2
[(The destination operand is an )2(MMX)0( register. The source can be either an )2(XMM)0( register or a 128-bit)]534 norm1
[(memory location.)]523 norm2
[(For more details of this instruction, see the Intel Processor manuals.)]506 norm3
[{/section-B.4.39 xa}2(CVTPD2PS)0(: Packed Double-Precision FP to Packed Single-Precision FP Conversion)](B.4.39)488 subh3
[2(CVTPD2PS xmm1,xmm2/mem128     ; 66 0F 5A /r     [WILLAMETTE,SSE2])]471 code3
[2(CVTPD2PS)0( converts two packed double-precision FP values from the source operand to two)]454 norm1
[(packed single-precision FP values in the low quadword of the destination operand. The high)]443 norm0
[(quadword of the destination is set to all 0s.)]432 norm2
[(The destination operand is an )2(XMM)0( register. The source can be either an )2(XMM)0( register or a 128-bit)]415 norm1
[(memory location.)]404 norm2
[(For more details of this instruction, see the Intel Processor manuals.)]387 norm3
[{/section-B.4.40 xa}2(CVTPI2PD)0(: Packed Signed INT32 to Packed Double-Precision FP Conversion)](B.4.40)369 subh3
[2(CVTPI2PD xmm,mm/mem64         ; 66 0F 2A /r     [WILLAMETTE,SSE2])]352 code3
[2(CVTPI2PD)0( converts two packed signed doublewords from the source operand to two packed)]335 norm1
[(double-precision FP values in the destination operand.)]324 norm2
[(The destination operand is an )2(XMM)0( register. The source can be either an )2(MMX)0( register or a 64-bit)]307 norm1
[(memory location.)]296 norm2
[(For more details of this instruction, see the Intel Processor manuals.)]279 norm3
[{/section-B.4.41 xa}2(CVTPI2PS)0(: Packed Signed INT32 to Packed Single-FP Conversion)](B.4.41)261 subh3
[2(CVTPI2PS xmm,mm/mem64         ; 0F 2A /r        [KATMAI,SSE])]244 code3
[2(CVTPI2PS)0( converts two packed signed doublewords from the source operand to two packed)]227 norm1
[(single-precision FP values in the low quadword of the destination operand. The high quadword of)]216 norm0
[(the destination remains unchanged.)]205 norm2
[(The destination operand is an )2(XMM)0( register. The source can be either an )2(MMX)0( register or a 64-bit)]188 norm1
[(memory location.)]177 norm2
[(For more details of this instruction, see the Intel Processor manuals.)]160 norm3
[{/section-B.4.42 xa}2(CVTPS2DQ)0(: Packed Single-Precision FP to Packed Signed INT32 Conversion)](B.4.42)142 subh3
[2(CVTPS2DQ xmm1,xmm2/mem128     ; 66 0F 5B /r     [WILLAMETTE,SSE2])]125 code3
(129)pageodd
restore showpage
%%Page: 130 130
%%BeginPageSetup
save
%%EndPageSetup
/130 pa
[2(CVTPS2DQ)0( converts four packed single-precision FP values from the source operand to four)]681 norm1
[(packed signed doublewords in the destination operand.)]670 norm2
[(The destination operand is an )2(XMM)0( register. The source can be either an )2(XMM)0( register or a 128-bit)]653 norm1
[(memory location.)]642 norm2
[(For more details of this instruction, see the Intel Processor manuals.)]625 norm3
[{/section-B.4.43 xa}2(CVTPS2PD)0(: Packed Single-Precision FP to Packed Double-Precision FP Conversion)](B.4.43)607 subh3
[2(CVTPS2PD xmm1,xmm2/mem64      ; 0F 5A /r        [WILLAMETTE,SSE2])]590 code3
[2(CVTPS2PD)0( converts two packed single-precision FP values from the source operand to two packed)]573 norm1
[(double-precision FP values in the destination operand.)]562 norm2
[(The destination operand is an )2(XMM)0( register. The source can be either an )2(XMM)0( register or a 64-bit)]545 norm1
[(memory location. If the source is a register, the input values are in the low quadword.)]534 norm2
[(For more details of this instruction, see the Intel Processor manuals.)]517 norm3
[{/section-B.4.44 xa}2(CVTPS2PI)0(: Packed Single-Precision FP to Packed Signed INT32 Conversion)](B.4.44)499 subh3
[2(CVTPS2PI mm,xmm/mem64         ; 0F 2D /r        [KATMAI,SSE])]482 code3
[2(CVTPS2PI)0( converts two packed single-precision FP values from the source operand to two packed)]465 norm1
[(signed doublewords in the destination operand.)]454 norm2
[(The destination operand is an )2(MMX)0( register. The source can be either an )2(XMM)0( register or a 64-bit)]437 norm1
[(memory location. If the source is a register, the input values are in the low quadword.)]426 norm2
[(For more details of this instruction, see the Intel Processor manuals.)]409 norm3
[{/section-B.4.45 xa}2(CVTSD2SI)0(: Scalar Double-Precision FP to Signed INT32 Conversion)](B.4.45)391 subh3
[2(CVTSD2SI reg32,xmm/mem64      ; F2 0F 2D /r     [WILLAMETTE,SSE2])]374 code3
[2(CVTSD2SI)0( converts a double-precision FP value from the source operand to a signed doubleword)]357 norm1
[(in the destination operand.)]346 norm2
[(The destination operand is a general purpose register. The source can be either an )2(XMM)0( register or a)]329 norm1
[(64-bit memory location. If the source is a register, the input value is in the low quadword.)]318 norm2
[(For more details of this instruction, see the Intel Processor manuals.)]301 norm3
[{/section-B.4.46 xa}2(CVTSD2SS)0(: Scalar Double-Precision FP to Scalar Single-Precision FP Conversion)](B.4.46)283 subh3
[2(CVTSD2SS xmm1,xmm2/mem64      ; F2 0F 5A /r     [KATMAI,SSE])]266 code3
[2(CVTSD2SS)0( converts a double-precision FP value from the source operand to a single-precision FP)]249 norm1
[(value in the low doubleword of the destination operand. The upper 3 doublewords are left)]238 norm0
[(unchanged.)]227 norm2
[(The destination operand is an )2(XMM)0( register. The source can be either an )2(XMM)0( register or a 64-bit)]210 norm1
[(memory location. If the source is a register, the input value is in the low quadword.)]199 norm2
[(For more details of this instruction, see the Intel Processor manuals.)]182 norm3
[{/section-B.4.47 xa}2(CVTSI2SD)0(: Signed INT32 to Scalar Double-Precision FP Conversion)](B.4.47)164 subh3
[2(CVTSI2SD xmm,r/m32            ; F2 0F 2A /r     [WILLAMETTE,SSE2])]147 code3
[2(CVTSI2SD)0( converts a signed doubleword from the source operand to a double-precision FP value)]130 norm1
[(in the low quadword of the destination operand. The high quadword is left unchanged.)]119 norm2
(130)pageeven
restore showpage
%%Page: 131 131
%%BeginPageSetup
save
%%EndPageSetup
/131 pa
[(The destination operand is an )2(XMM)0( register. The source can be either a general purpose register or a)]681 norm1
[(32-bit memory location.)]670 norm2
[(For more details of this instruction, see the Intel Processor manuals.)]653 norm3
[{/section-B.4.48 xa}2(CVTSI2SS)0(: Signed INT32 to Scalar Single-Precision FP Conversion)](B.4.48)635 subh3
[2(CVTSI2SS xmm,r/m32            ; F3 0F 2A /r     [KATMAI,SSE])]618 code3
[2(CVTSI2SS)0( converts a signed doubleword from the source operand to a single-precision FP value)]601 norm1
[(in the low doubleword of the destination operand. The upper 3 doublewords are left unchanged.)]590 norm2
[(The destination operand is an )2(XMM)0( register. The source can be either a general purpose register or a)]573 norm1
[(32-bit memory location.)]562 norm2
[(For more details of this instruction, see the Intel Processor manuals.)]545 norm3
[{/section-B.4.49 xa}2(CVTSS2SD)0(: Scalar Single-Precision FP to Scalar Double-Precision FP Conversion)](B.4.49)527 subh3
[2(CVTSS2SD xmm1,xmm2/mem32      ; F3 0F 5A /r     [WILLAMETTE,SSE2])]510 code3
[2(CVTSS2SD)0( converts a single-precision FP value from the source operand to a double-precision FP)]493 norm1
[(value in the low quadword of the destination operand. The upper quadword is left unchanged.)]482 norm2
[(The destination operand is an )2(XMM)0( register. The source can be either an )2(XMM)0( register or a 32-bit)]465 norm1
[(memory location. If the source is a register, the input value is contained in the low doubleword.)]454 norm2
[(For more details of this instruction, see the Intel Processor manuals.)]437 norm3
[{/section-B.4.50 xa}2(CVTSS2SI)0(: Scalar Single-Precision FP to Signed INT32 Conversion)](B.4.50)419 subh3
[2(CVTSS2SI reg32,xmm/mem32      ; F3 0F 2D /r     [KATMAI,SSE])]402 code3
[2(CVTSS2SI)0( converts a single-precision FP value from the source operand to a signed doubleword)]385 norm1
[(in the destination operand.)]374 norm2
[(The destination operand is a general purpose register. The source can be either an )2(XMM)0( register or a)]357 norm1
[(32-bit memory location. If the source is a register, the input value is in the low doubleword.)]346 norm2
[(For more details of this instruction, see the Intel Processor manuals.)]329 norm3
[{/section-B.4.51 xa}2(CVTTPD2DQ)0(: Packed Double-Precision FP to Packed Signed INT32 Conversion with)](B.4.51)311 subh1
[(Truncation)]299 subh2
[2(CVTTPD2DQ xmm1,xmm2/mem128    ; 66 0F E6 /r     [WILLAMETTE,SSE2])]282 code3
[2(CVTTPD2DQ)0( converts two packed double-precision FP values in the source operand to two packed)]265 norm1
[(single-precision FP values in the destination operand. If the result is inexact, it is truncated)]254 norm0
[(\(rounded toward zero\). The high quadword is set to all 0s.)]243 norm2
[(The destination operand is an )2(XMM)0( register. The source can be either an )2(XMM)0( register or a 128-bit)]226 norm1
[(memory location.)]215 norm2
[(For more details of this instruction, see the Intel Processor manuals.)]198 norm3
[{/section-B.4.52 xa}2(CVTTPD2PI)0(: Packed Double-Precision FP to Packed Signed INT32 Conversion with)](B.4.52)180 subh1
[(Truncation)]168 subh2
[2(CVTTPD2PI mm,xmm/mem128        ; 66 0F 2C /r     [WILLAMETTE,SSE2])]151 code3
[2(CVTTPD2PI)0( converts two packed double-precision FP values in the source operand to two packed)]134 norm1
[(single-precision FP values in the destination operand. If the result is inexact, it is truncated)]123 norm0
[(\(rounded toward zero\).)]112 norm2
(131)pageodd
restore showpage
%%Page: 132 132
%%BeginPageSetup
save
%%EndPageSetup
/132 pa
[(The destination operand is an )2(MMX)0( register. The source can be either an )2(XMM)0( register or a 128-bit)]681 norm1
[(memory location.)]670 norm2
[(For more details of this instruction, see the Intel Processor manuals.)]653 norm3
[{/section-B.4.53 xa}2(CVTTPS2DQ)0(: Packed Single-Precision FP to Packed Signed INT32 Conversion with)](B.4.53)635 subh1
[(Truncation)]623 subh2
[2(CVTTPS2DQ xmm1,xmm2/mem128    ; F3 0F 5B /r     [WILLAMETTE,SSE2])]606 code3
[2(CVTTPS2DQ)0( converts four packed single-precision FP values in the source operand to four packed)]589 norm1
[(signed doublewords in the destination operand. If the result is inexact, it is truncated \(rounded)]578 norm0
[(toward zero\).)]567 norm2
[(The destination operand is an )2(XMM)0( register. The source can be either an )2(XMM)0( register or a 128-bit)]550 norm1
[(memory location.)]539 norm2
[(For more details of this instruction, see the Intel Processor manuals.)]522 norm3
[{/section-B.4.54 xa}2(CVTTPS2PI)0(: Packed Single-Precision FP to Packed Signed INT32 Conversion with)](B.4.54)504 subh1
[(Truncation)]492 subh2
[2(CVTTPS2PI mm,xmm/mem64         ; 0F 2C /r       [KATMAI,SSE])]475 code3
[2(CVTTPS2PI)0( converts two packed single-precision FP values in the source operand to two packed)]458 norm1
[(signed doublewords in the destination operand. If the result is inexact, it is truncated \(rounded)]447 norm0
[(toward zero\). If the source is a register, the input values are in the low quadword.)]436 norm2
[(The destination operand is an )2(MMX)0( register. The source can be either an )2(XMM)0( register or a 64-bit)]419 norm1
[(memory location. If the source is a register, the input value is in the low quadword.)]408 norm2
[(For more details of this instruction, see the Intel Processor manuals.)]391 norm3
[{/section-B.4.55 xa}2(CVTTSD2SI)0(: Scalar Double-Precision FP to Signed INT32 Conversion with)](B.4.55)373 subh1
[(Truncation)]361 subh2
[2(CVTTSD2SI reg32,xmm/mem64      ; F2 0F 2C /r    [WILLAMETTE,SSE2])]344 code3
[2(CVTTSD2SI)0( converts a double-precision FP value in the source operand to a signed doubleword in)]327 norm1
[(the destination operand. If the result is inexact, it is truncated \(rounded toward zero\).)]316 norm2
[(The destination operand is a general purpose register. The source can be either an )2(XMM)0( register or a)]299 norm1
[(64-bit memory location. If the source is a register, the input value is in the low quadword.)]288 norm2
[(For more details of this instruction, see the Intel Processor manuals.)]271 norm3
[{/section-B.4.56 xa}2(CVTTSS2SI)0(: Scalar Single-Precision FP to Signed INT32 Conversion with)](B.4.56)253 subh1
[(Truncation)]241 subh2
[2(CVTTSD2SI reg32,xmm/mem32      ; F3 0F 2C /r    [KATMAI,SSE])]224 code3
[2(CVTTSS2SI)0( converts a single-precision FP value in the source operand to a signed doubleword in)]207 norm1
[(the destination operand. If the result is inexact, it is truncated \(rounded toward zero\).)]196 norm2
[(The destination operand is a general purpose register. The source can be either an )2(XMM)0( register or a)]179 norm1
[(32-bit memory location. If the source is a register, the input value is in the low doubleword.)]168 norm2
[(For more details of this instruction, see the Intel Processor manuals.)]151 norm3
[{/section-B.4.57 xa}2(DAA)0(, )2(DAS)0(: Decimal Adjustments)](B.4.57)133 subh3
[2(DAA                           ; 27                   [8086] )]116 code1
[2(DAS                           ; 2F                   [8086])]105 code2
(132)pageeven
restore showpage
%%Page: 133 133
%%BeginPageSetup
save
%%EndPageSetup
/133 pa
[(These instructions are used in conjunction with the add and subtract instructions to perform)]681 norm1
[(binary-coded decimal arithmetic in )1(packed)0( \(one BCD digit per nibble\) form. For the unpacked)]670 norm0
[(equivalents, see ){/section-B.4.1 xl}(section B.4.1){el}(.)]659 norm2
[2(DAA)0( should be used after a one-byte )2(ADD)0( instruction whose destination was the )2(AL)0( register: by)]642 norm1
[(means of examining the value in the )2(AL)0( and also the auxiliary carry flag )2(AF)0(, it determines whether)]631 norm0
[(either digit of the addition has overflowed, and adjusts it \(and sets the carry and auxiliary-carry)]620 norm0
[(flags\) if so. You can add long BCD strings together by doing )2(ADD)0(/)2(DAA)0( on the low two digits, then)]609 norm0
[(doing )2(ADC)0(/)2(DAA)0( on each subsequent pair of digits.)]598 norm2
[2(DAS)0( works similarly to )2(DAA)0(, but is for use after )2(SUB)0( instructions rather than )2(ADD)0(.)]581 norm3
[{/section-B.4.58 xa}2(DEC)0(: Decrement Integer)](B.4.58)563 subh3
[2(DEC reg16                     ; o16 48+r             [8086] )]546 code1
[2(DEC reg32                     ; o32 48+r             [386] )]535 code0
[2(DEC r/m8                      ; FE /1                [8086] )]524 code0
[2(DEC r/m16                     ; o16 FF /1            [8086] )]513 code0
[2(DEC r/m32                     ; o32 FF /1            [386])]502 code2
[2(DEC)0( subtracts 1 from its operand. It does )1(not)0( affect the carry flag: to affect the carry flag, use)]485 norm1
[2(SUB something,1)0( \(see ){/section-B.4.305 xl}(section B.4.305){el}(\). )2(DEC)0( affects all the other flags according to the result.)]474 norm2
[(This instruction can be used with a )2(LOCK)0( prefix to allow atomic execution.)]457 norm3
[(See also )2(INC)0( \(){/section-B.4.120 xl}(section B.4.120){el}(\).)]440 norm3
[{/section-B.4.59 xa}2(DIV)0(: Unsigned Integer Divide)](B.4.59)422 subh3
[2(DIV r/m8                      ; F6 /6                [8086] )]405 code1
[2(DIV r/m16                     ; o16 F7 /6            [8086] )]394 code0
[2(DIV r/m32                     ; o32 F7 /6            [386])]383 code2
[2(DIV)0( performs unsigned integer division. The explicit operand provided is the divisor; the dividend)]366 norm1
[(and destination operands are implicit, in the following way:)]355 norm2
[(For )2(DIV r/m8)0(, )2(AX)0( is divided by the given operand; the quotient is stored in )2(AL)0( and the)]338 bull1
[(remainder in )2(AH)0(.)]327 bull2
[(For )2(DIV r/m16)0(, )2(DX:AX)0( is divided by the given operand; the quotient is stored in )2(AX)0( and the)]310 bull1
[(remainder in )2(DX)0(.)]299 bull2
[(For )2(DIV r/m32)0(, )2(EDX:EAX)0( is divided by the given operand; the quotient is stored in )2(EAX)0( and)]282 bull1
[(the remainder in )2(EDX)0(.)]271 bull2
[(Signed integer division is performed by the )2(IDIV)0( instruction: see ){/section-B.4.117 xl}(section B.4.117){el}(.)]254 norm3
[{/section-B.4.60 xa}2(DIVPD)0(: Packed Double-Precision FP Divide)](B.4.60)236 subh3
[2(DIVPD xmm1,xmm2/mem128        ; 66 0F 5E /r     [WILLAMETTE,SSE2])]219 code3
[2(DIVPD)0( divides the two packed double-precision FP values in the destination operand by the two)]202 norm1
[(packed double-precision FP values in the source operand, and stores the packed double-precision)]191 norm0
[(results in the destination register.)]180 norm2
[(The destination is an )2(XMM)0( register. The source operand can be either an )2(XMM)0( register or a 128-bit)]163 norm1
[(memory location.)]152 norm2
[2(   dst[0-63]   := dst[0-63]   / src[0-63], )]135 code1
[2(   dst[64-127] := dst[64-127] / src[64-127].)]124 code2
(133)pageodd
restore showpage
%%Page: 134 134
%%BeginPageSetup
save
%%EndPageSetup
/134 pa
[{/section-B.4.61 xa}2(DIVPS)0(: Packed Single-Precision FP Divide)](B.4.61)680 subh3
[2(DIVPS xmm1,xmm2/mem128        ; 0F 5E /r        [KATMAI,SSE])]663 code3
[2(DIVPS)0( divides the four packed single-precision FP values in the destination operand by the four)]646 norm1
[(packed single-precision FP values in the source operand, and stores the packed single-precision)]635 norm0
[(results in the destination register.)]624 norm2
[(The destination is an )2(XMM)0( register. The source operand can be either an )2(XMM)0( register or a 128-bit)]607 norm1
[(memory location.)]596 norm2
[2(   dst[0-31]   := dst[0-31]   / src[0-31], )]579 code1
[2(   dst[32-63]  := dst[32-63]  / src[32-63], )]568 code0
[2(   dst[64-95]  := dst[64-95]  / src[64-95], )]557 code0
[2(   dst[96-127] := dst[96-127] / src[96-127].)]546 code2
[{/section-B.4.62 xa}2(DIVSD)0(: Scalar Double-Precision FP Divide)](B.4.62)528 subh3
[2(DIVSD xmm1,xmm2/mem64         ; F2 0F 5E /r     [WILLAMETTE,SSE2])]511 code3
[2(DIVSD)0( divides the low-order double-precision FP value in the destination operand by the)]494 norm1
[(low-order double-precision FP value in the source operand, and stores the double-precision result)]483 norm0
[(in the destination register.)]472 norm2
[(The destination is an )2(XMM)0( register. The source operand can be either an )2(XMM)0( register or a 64-bit)]455 norm1
[(memory location.)]444 norm2
[2(   dst[0-63]   := dst[0-63] / src[0-63], )]427 code1
[2(   dst[64-127] remains unchanged.)]416 code2
[{/section-B.4.63 xa}2(DIVSS)0(: Scalar Single-Precision FP Divide)](B.4.63)398 subh3
[2(DIVSS xmm1,xmm2/mem32         ; F3 0F 5E /r     [KATMAI,SSE])]381 code3
[2(DIVSS)0( divides the low-order single-precision FP value in the destination operand by the)]364 norm1
[(low-order single-precision FP value in the source operand, and stores the single-precision result in)]353 norm0
[(the destination register.)]342 norm2
[(The destination is an )2(XMM)0( register. The source operand can be either an )2(XMM)0( register or a 32-bit)]325 norm1
[(memory location.)]314 norm2
[2(   dst[0-31]   := dst[0-31] / src[0-31], )]297 code1
[2(   dst[32-127] remains unchanged.)]286 code2
[{/section-B.4.64 xa}2(EMMS)0(: Empty MMX State)](B.4.64)268 subh3
[2(EMMS                          ; 0F 77                [PENT,MMX])]251 code3
[2(EMMS)0( sets the FPU tag word \(marking which floating-point registers are available\) to all ones,)]234 norm1
[(meaning all registers are available for the FPU to use. It should be used after executing )2(MMX)]223 norm0
[(instructions and before executing any subsequent floating-point operations.)]212 norm2
[{/section-B.4.65 xa}2(ENTER)0(: Create Stack Frame)](B.4.65)194 subh3
[2(ENTER imm,imm                 ; C8 iw ib             [186])]177 code3
[2(ENTER)0( constructs a )2(stack frame)0( for a high-level language procedure call. The first operand)]160 norm1
[(\(the )2(iw)0( in the opcode definition above refers to the first operand\) gives the amount of stack space to)]149 norm0
[(allocate for local variables; the second \(the )2(ib)0( above\) gives the nesting level of the procedure \(for)]138 norm0
[(languages like Pascal, with nested procedures\).)]127 norm2
[(The function of )2(ENTER)0(, with a nesting level of zero, is equivalent to)]110 norm3
(134)pageeven
restore showpage
%%Page: 135 135
%%BeginPageSetup
save
%%EndPageSetup
/135 pa
[2(          PUSH EBP            ; or PUSH BP         in 16 bits )]681 code1
[2(          MOV EBP,ESP         ; or MOV BP,SP       in 16 bits )]670 code0
[2(          SUB ESP,operand1    ; or SUB SP,operand1 in 16 bits)]659 code2
[(This creates a stack frame with the procedure parameters accessible upwards from )2(EBP)0(, and local)]642 norm1
[(variables accessible downwards from )2(EBP)0(.)]631 norm2
[(With a nesting level of one, the stack frame created is 4 \(or 2\) bytes bigger, and the value of the)]614 norm1
[(final frame pointer )2(EBP)0( is accessible in memory at )2([EBP-4])0(.)]603 norm2
[(This allows )2(ENTER)0(, when called with a nesting level of two, to look at the stack frame described by)]586 norm1
[(the )1(previous)0( value of )2(EBP)0(, find the frame pointer at offset \2264 from that, and push it along with its)]575 norm0
[(new frame pointer, so that when a level-two procedure is called from within a level-one procedure,)]564 norm0
[2([EBP-4])0( holds the frame pointer of the most recent level-one procedure call and )2([EBP-8])0( holds)]553 norm0
[(that of the most recent level-two call. And so on, for nesting levels up to 31.)]542 norm2
[(Stack frames created by )2(ENTER)0( can be destroyed by the )2(LEAVE)0( instruction: see ){/section-B.4.136 xl}(section B.4.136){el}(.)]525 norm3
[{/section-B.4.66 xa}2(F2XM1)0(: Calculate 2**X-1)](B.4.66)507 subh3
[2(F2XM1                         ; D9 F0                [8086,FPU])]490 code3
[2(F2XM1)0( raises 2 to the power of )2(ST0)0(, subtracts one, and stores the result back into )2(ST0)0(. The initial)]473 norm1
[(contents of )2(ST0)0( must be a number in the range \2261.0 to +1.0.)]462 norm2
[{/section-B.4.67 xa}2(FABS)0(: Floating-Point Absolute Value)](B.4.67)444 subh3
[2(FABS                          ; D9 E1                [8086,FPU])]427 code3
[2(FABS)0( computes the absolute value of )2(ST0)0(,by clearing the sign bit, and stores the result back in )2(ST0)0(.)]410 norm3
[{/section-B.4.68 xa}2(FADD)0(, )2(FADDP)0(: Floating-Point Addition)](B.4.68)392 subh3
[2(FADD mem32                    ; D8 /0                [8086,FPU] )]375 code1
[2(FADD mem64                    ; DC /0                [8086,FPU])]364 code2
[2(FADD fpureg                   ; D8 C0+r              [8086,FPU] )]347 code1
[2(FADD ST0,fpureg               ; D8 C0+r              [8086,FPU])]336 code2
[2(FADD TO fpureg                ; DC C0+r              [8086,FPU] )]319 code1
[2(FADD fpureg,ST0               ; DC C0+r              [8086,FPU])]308 code2
[2(FADDP fpureg                  ; DE C0+r              [8086,FPU] )]291 code1
[2(FADDP fpureg,ST0              ; DE C0+r              [8086,FPU])]280 code2
[2(FADD)0(, given one operand, adds the operand to )2(ST0)0( and stores the result back in )2(ST0)0(. If the)]263 bull1
[(operand has the )2(TO)0( modifier, the result is stored in the register given rather than in )2(ST0)0(.)]252 bull2
[2(FADDP)0( performs the same function as )2(FADD TO)0(, but pops the register stack after storing the)]235 bull1
[(result.)]224 bull2
[(The given two-operand forms are synonyms for the one-operand forms.)]207 norm3
[(To add an integer value to )2(ST0)0(, use the c{FIADD} instruction \(){/section-B.4.80 xl}(section B.4.80){el}(\))]190 norm3
[{/section-B.4.69 xa}2(FBLD)0(, )2(FBSTP)0(: BCD Floating-Point Load and Store)](B.4.69)172 subh3
[2(FBLD mem80                    ; DF /4                [8086,FPU] )]155 code1
[2(FBSTP mem80                   ; DF /6                [8086,FPU])]144 code2
[2(FBLD)0( loads an 80-bit \(ten-byte\) packed binary-coded decimal number from the given memory)]127 norm1
[(address, converts it to a real, and pushes it on the register stack. )2(FBSTP)0( stores the value of )2(ST0)0(, in)]116 norm0
[(packed BCD, at the given address and then pops the register stack.)]105 norm2
(135)pageodd
restore showpage
%%Page: 136 136
%%BeginPageSetup
save
%%EndPageSetup
/136 pa
[{/section-B.4.70 xa}2(FCHS)0(: Floating-Point Change Sign)](B.4.70)680 subh3
[2(FCHS                          ; D9 E0                [8086,FPU])]663 code3
[2(FCHS)0( negates the number in )2(ST0)0(, by inverting the sign bit: negative numbers become positive, and)]646 norm1
[(vice versa.)]635 norm2
[{/section-B.4.71 xa}2(FCLEX)0(, )2(FNCLEX)0(: Clear Floating-Point Exceptions)](B.4.71)617 subh3
[2(FCLEX                         ; 9B DB E2             [8086,FPU] )]600 code1
[2(FNCLEX                        ; DB E2                [8086,FPU])]589 code2
[2(FCLEX)0( clears any floating-point exceptions which may be pending. )2(FNCLEX)0( does the same thing)]572 norm1
[(but doesn't wait for previous floating-point operations \(including the )1(handling)0( of pending)]561 norm0
[(exceptions\) to finish first.)]550 norm2
[{/section-B.4.72 xa}2(FCMOVcc)0(: Floating-Point Conditional Move)](B.4.72)532 subh3
[2(FCMOVB fpureg                 ; DA C0+r              [P6,FPU] )]515 code1
[2(FCMOVB ST0,fpureg             ; DA C0+r              [P6,FPU])]504 code2
[2(FCMOVE fpureg                 ; DA C8+r              [P6,FPU] )]487 code1
[2(FCMOVE ST0,fpureg             ; DA C8+r              [P6,FPU])]476 code2
[2(FCMOVBE fpureg                ; DA D0+r              [P6,FPU] )]459 code1
[2(FCMOVBE ST0,fpureg            ; DA D0+r              [P6,FPU])]448 code2
[2(FCMOVU fpureg                 ; DA D8+r              [P6,FPU] )]431 code1
[2(FCMOVU ST0,fpureg             ; DA D8+r              [P6,FPU])]420 code2
[2(FCMOVNB fpureg                ; DB C0+r              [P6,FPU] )]403 code1
[2(FCMOVNB ST0,fpureg            ; DB C0+r              [P6,FPU])]392 code2
[2(FCMOVNE fpureg                ; DB C8+r              [P6,FPU] )]375 code1
[2(FCMOVNE ST0,fpureg            ; DB C8+r              [P6,FPU])]364 code2
[2(FCMOVNBE fpureg               ; DB D0+r              [P6,FPU] )]347 code1
[2(FCMOVNBE ST0,fpureg           ; DB D0+r              [P6,FPU])]336 code2
[2(FCMOVNU fpureg                ; DB D8+r              [P6,FPU] )]319 code1
[2(FCMOVNU ST0,fpureg            ; DB D8+r              [P6,FPU])]308 code2
[(The )2(FCMOV)0( instructions perform conditional move operations: each of them moves the contents of)]291 norm1
[(the given register into )2(ST0)0( if its condition is satisfied, and does nothing if not.)]280 norm2
[(The conditions are not the same as the standard condition codes used with conditional jump)]263 norm1
[(instructions. The conditions )2(B)0(, )2(BE)0(, )2(NB)0(, )2(NBE)0(, )2(E)0( and )2(NE)0( are exactly as normal, but none of the other)]252 norm0
[(standard ones are supported. Instead, the condition )2(U)0( and its counterpart )2(NU)0( are provided; the )2(U)]241 norm0
[(condition is satisfied if the last two floating-point numbers compared were )1(unordered)0(, i.e. they)]230 norm0
[(were not equal but neither one could be said to be greater than the other, for example if they were)]219 norm0
[(NaNs. \(The flag state which signals this is the setting of the parity flag: so the )2(U)0( condition is)]208 norm0
[(notionally equivalent to )2(PE)0(, and )2(NU)0( is equivalent to )2(PO)0(.\))]197 norm2
[(The )2(FCMOV)0( conditions test the main processor's status flags, not the FPU status flags, so using)]180 norm1
[2(FCMOV)0( directly after )2(FCOM)0( will not work. Instead, you should either use )2(FCOMI)0( which writes)]169 norm0
[(directly to the main CPU flags word, or use )2(FSTSW)0( to extract the FPU flags.)]158 norm2
[(Although the )2(FCMOV)0( instructions are flagged )2(P6)0( above, they may not be supported by all Pentium)]141 norm1
[(Pro processors; the )2(CPUID)0( instruction \(){/section-B.4.34 xl}(section B.4.34){el}(\) will return a bit which indicates whether)]130 norm0
[(conditional moves are supported.)]119 norm2
(136)pageeven
restore showpage
%%Page: 137 137
%%BeginPageSetup
save
%%EndPageSetup
/137 pa
[{/section-B.4.73 xa}2(FCOM)0(, )2(FCOMP)0(, )2(FCOMPP)0(, )2(FCOMI)0(, )2(FCOMIP)0(: Floating-Point Compare)](B.4.73)680 subh3
[2(FCOM mem32                    ; D8 /2                [8086,FPU] )]663 code1
[2(FCOM mem64                    ; DC /2                [8086,FPU] )]652 code0
[2(FCOM fpureg                   ; D8 D0+r              [8086,FPU] )]641 code0
[2(FCOM ST0,fpureg               ; D8 D0+r              [8086,FPU])]630 code2
[2(FCOMP mem32                   ; D8 /3                [8086,FPU] )]613 code1
[2(FCOMP mem64                   ; DC /3                [8086,FPU] )]602 code0
[2(FCOMP fpureg                  ; D8 D8+r              [8086,FPU] )]591 code0
[2(FCOMP ST0,fpureg              ; D8 D8+r              [8086,FPU])]580 code2
[2(FCOMPP                        ; DE D9                [8086,FPU])]563 code3
[2(FCOMI fpureg                  ; DB F0+r              [P6,FPU] )]546 code1
[2(FCOMI ST0,fpureg              ; DB F0+r              [P6,FPU])]535 code2
[2(FCOMIP fpureg                 ; DF F0+r              [P6,FPU] )]518 code1
[2(FCOMIP ST0,fpureg             ; DF F0+r              [P6,FPU])]507 code2
[2(FCOM)0( compares )2(ST0)0( with the given operand, and sets the FPU flags accordingly. )2(ST0)0( is treated as)]490 norm1
[(the left-hand side of the comparison, so that the carry flag is set \(for a `less-than' result\) if )2(ST0)0( is)]479 norm0
[(less than the given operand.)]468 norm2
[2(FCOMP)0( does the same as )2(FCOM)0(, but pops the register stack afterwards. )2(FCOMPP)0( compares )2(ST0)]451 norm1
[(with )2(ST1)0( and then pops the register stack twice.)]440 norm2
[2(FCOMI)0( and )2(FCOMIP)0( work like the corresponding forms of )2(FCOM)0( and )2(FCOMP)0(, but write their)]423 norm1
[(results directly to the CPU flags register rather than the FPU status word, so they can be)]412 norm0
[(immediately followed by conditional jump or conditional move instructions.)]401 norm2
[(The )2(FCOM)0( instructions differ from the )2(FUCOM)0( instructions \(){/section-B.4.108 xl}(section B.4.108){el}(\) only in the way they)]384 norm1
[(handle quiet NaNs: )2(FUCOM)0( will handle them silently and set the condition code flags to an)]373 norm0
[(`unordered' result, whereas )2(FCOM)0( will generate an exception.)]362 norm2
[{/section-B.4.74 xa}2(FCOS)0(: Cosine)](B.4.74)344 subh3
[2(FCOS                          ; D9 FF                [386,FPU])]327 code3
[2(FCOS)0( computes the cosine of )2(ST0)0( \(in radians\), and stores the result in )2(ST0)0(. The absolute value of)]310 norm1
[2(ST0)0( must be less than 2**63.)]299 norm2
[(See also )2(FSINCOS)0( \(){/section-B.4.100 xl}(section B.4.100){el}(\).)]282 norm3
[{/section-B.4.75 xa}2(FDECSTP)0(: Decrement Floating-Point Stack Pointer)](B.4.75)264 subh3
[2(FDECSTP                       ; D9 F6                [8086,FPU])]247 code3
[2(FDECSTP)0( decrements the `top' field in the floating-point status word. This has the effect of)]230 norm1
[(rotating the FPU register stack by one, as if the contents of )2(ST7)0( had been pushed on the stack. See)]219 norm0
[(also )2(FINCSTP)0( \(){/section-B.4.85 xl}(section B.4.85){el}(\).)]208 norm2
[{/section-B.4.76 xa}2(FxDISI)0(, )2(FxENI)0(: Disable and Enable Floating-Point Interrupts)](B.4.76)190 subh3
[2(FDISI                         ; 9B DB E1             [8086,FPU] )]173 code1
[2(FNDISI                        ; DB E1                [8086,FPU])]162 code2
[2(FENI                          ; 9B DB E0             [8086,FPU] )]145 code1
[2(FNENI                         ; DB E0                [8086,FPU])]134 code2
[2(FDISI)0( and )2(FENI)0( disable and enable floating-point interrupts. These instructions are only)]117 norm1
[(meaningful on original 8087 processors: the 287 and above treat them as no-operation instructions.)]106 norm2
(137)pageodd
restore showpage
%%Page: 138 138
%%BeginPageSetup
save
%%EndPageSetup
/138 pa
[2(FNDISI)0( and )2(FNENI)0( do the same thing as )2(FDISI)0( and )2(FENI)0( respectively, but without waiting for)]681 norm1
[(the floating-point processor to finish what it was doing first.)]670 norm2
[{/section-B.4.77 xa}2(FDIV)0(, )2(FDIVP)0(, )2(FDIVR)0(, )2(FDIVRP)0(: Floating-Point Division)](B.4.77)652 subh3
[2(FDIV mem32                    ; D8 /6                [8086,FPU] )]635 code1
[2(FDIV mem64                    ; DC /6                [8086,FPU])]624 code2
[2(FDIV fpureg                   ; D8 F0+r              [8086,FPU] )]607 code1
[2(FDIV ST0,fpureg               ; D8 F0+r              [8086,FPU])]596 code2
[2(FDIV TO fpureg                ; DC F8+r              [8086,FPU] )]579 code1
[2(FDIV fpureg,ST0               ; DC F8+r              [8086,FPU])]568 code2
[2(FDIVR mem32                   ; D8 /7                [8086,FPU] )]551 code1
[2(FDIVR mem64                   ; DC /7                [8086,FPU])]540 code2
[2(FDIVR fpureg                  ; D8 F8+r              [8086,FPU] )]523 code1
[2(FDIVR ST0,fpureg              ; D8 F8+r              [8086,FPU])]512 code2
[2(FDIVR TO fpureg               ; DC F0+r              [8086,FPU] )]495 code1
[2(FDIVR fpureg,ST0              ; DC F0+r              [8086,FPU])]484 code2
[2(FDIVP fpureg                  ; DE F8+r              [8086,FPU] )]467 code1
[2(FDIVP fpureg,ST0              ; DE F8+r              [8086,FPU])]456 code2
[2(FDIVRP fpureg                 ; DE F0+r              [8086,FPU] )]439 code1
[2(FDIVRP fpureg,ST0             ; DE F0+r              [8086,FPU])]428 code2
[2(FDIV)0( divides )2(ST0)0( by the given operand and stores the result back in )2(ST0)0(, unless the )2(TO)]411 bull1
[(qualifier is given, in which case it divides the given operand by )2(ST0)0( and stores the result in the)]400 bull0
[(operand.)]389 bull2
[2(FDIVR)0( does the same thing, but does the division the other way up: so if )2(TO)0( is not given, it)]372 bull1
[(divides the given operand by )2(ST0)0( and stores the result in )2(ST0)0(, whereas if )2(TO)0( is given it divides)]361 bull0
[2(ST0)0( by its operand and stores the result in the operand.)]350 bull2
[2(FDIVP)0( operates like )2(FDIV TO)0(, but pops the register stack once it has finished.)]333 bull3
[2(FDIVRP)0( operates like )2(FDIVR TO)0(, but pops the register stack once it has finished.)]316 bull3
[(For FP/Integer divisions, see )2(FIDIV)0( \(){/section-B.4.82 xl}(section B.4.82){el}(\).)]299 norm3
[{/section-B.4.78 xa}2(FEMMS)0(: Faster Enter/Exit of the MMX or floating-point state)](B.4.78)281 subh3
[2(FEMMS                         ; 0F 0E           [PENT,3DNOW])]264 code3
[2(FEMMS)0( can be used in place of the )2(EMMS)0( instruction on processors which support the 3DNow!)]247 norm1
[(instruction set. Following execution of )2(FEMMS)0(, the state of the )2(MMX/FP)0( registers is undefined, and)]236 norm0
[(this allows a faster context switch between )2(FP)0( and )2(MMX)0( instructions. The )2(FEMMS)0( instruction can)]225 norm0
[(also be used )1(before)0( executing )2(MMX)0( instructions)]214 norm2
[{/section-B.4.79 xa}2(FFREE)0(: Flag Floating-Point Register as Unused)](B.4.79)196 subh3
[2(FFREE fpureg                  ; DD C0+r              [8086,FPU] )]179 code1
[2(FFREEP fpureg                 ; DF C0+r              [286,FPU,UNDOC])]168 code2
[2(FFREE)0( marks the given register as being empty.)]151 norm3
[2(FFREEP)0( marks the given register as being empty, and then pops the register stack.)]134 norm3
(138)pageeven
restore showpage
%%Page: 139 139
%%BeginPageSetup
save
%%EndPageSetup
/139 pa
[{/section-B.4.80 xa}2(FIADD)0(: Floating-Point/Integer Addition)](B.4.80)680 subh3
[2(FIADD mem16                   ; DE /0                [8086,FPU] )]663 code1
[2(FIADD mem32                   ; DA /0                [8086,FPU])]652 code2
[2(FIADD)0( adds the 16-bit or 32-bit integer stored in the given memory location to )2(ST0)0(, storing the)]635 norm1
[(result in )2(ST0)0(.)]624 norm2
[{/section-B.4.81 xa}2(FICOM)0(, )2(FICOMP)0(: Floating-Point/Integer Compare)](B.4.81)606 subh3
[2(FICOM mem16                   ; DE /2                [8086,FPU] )]589 code1
[2(FICOM mem32                   ; DA /2                [8086,FPU])]578 code2
[2(FICOMP mem16                  ; DE /3                [8086,FPU] )]561 code1
[2(FICOMP mem32                  ; DA /3                [8086,FPU])]550 code2
[2(FICOM)0( compares )2(ST0)0( with the 16-bit or 32-bit integer stored in the given memory location, and)]533 norm1
[(sets the FPU flags accordingly. )2(FICOMP)0( does the same, but pops the register stack afterwards.)]522 norm2
[{/section-B.4.82 xa}2(FIDIV)0(, )2(FIDIVR)0(: Floating-Point/Integer Division)](B.4.82)504 subh3
[2(FIDIV mem16                   ; DE /6                [8086,FPU] )]487 code1
[2(FIDIV mem32                   ; DA /6                [8086,FPU])]476 code2
[2(FIDIVR mem16                  ; DE /7                [8086,FPU] )]459 code1
[2(FIDIVR mem32                  ; DA /7                [8086,FPU])]448 code2
[2(FIDIV)0( divides )2(ST0)0( by the 16-bit or 32-bit integer stored in the given memory location, and stores)]431 norm1
[(the result in )2(ST0)0(. )2(FIDIVR)0( does the division the other way up: it divides the integer by )2(ST0)0(, but)]420 norm0
[(still stores the result in )2(ST0)0(.)]409 norm2
[{/section-B.4.83 xa}2(FILD)0(, )2(FIST)0(, )2(FISTP)0(: Floating-Point/Integer Conversion)](B.4.83)391 subh3
[2(FILD mem16                    ; DF /0                [8086,FPU] )]374 code1
[2(FILD mem32                    ; DB /0                [8086,FPU] )]363 code0
[2(FILD mem64                    ; DF /5                [8086,FPU])]352 code2
[2(FIST mem16                    ; DF /2                [8086,FPU] )]335 code1
[2(FIST mem32                    ; DB /2                [8086,FPU])]324 code2
[2(FISTP mem16                   ; DF /3                [8086,FPU] )]307 code1
[2(FISTP mem32                   ; DB /3                [8086,FPU] )]296 code0
[2(FISTP mem64                   ; DF /7                [8086,FPU])]285 code2
[2(FILD)0( loads an integer out of a memory location, converts it to a real, and pushes it on the FPU)]268 norm1
[(register stack. )2(FIST)0( converts )2(ST0)0( to an integer and stores that in memory; )2(FISTP)0( does the same)]257 norm0
[(as )2(FIST)0(, but pops the register stack afterwards.)]246 norm2
[{/section-B.4.84 xa}2(FIMUL)0(: Floating-Point/Integer Multiplication)](B.4.84)228 subh3
[2(FIMUL mem16                   ; DE /1                [8086,FPU] )]211 code1
[2(FIMUL mem32                   ; DA /1                [8086,FPU])]200 code2
[2(FIMUL)0( multiplies )2(ST0)0( by the 16-bit or 32-bit integer stored in the given memory location, and)]183 norm1
[(stores the result in )2(ST0)0(.)]172 norm2
[{/section-B.4.85 xa}2(FINCSTP)0(: Increment Floating-Point Stack Pointer)](B.4.85)154 subh3
[2(FINCSTP                       ; D9 F7                [8086,FPU])]137 code3
[2(FINCSTP)0( increments the `top' field in the floating-point status word. This has the effect of rotating)]120 norm1
[(the FPU register stack by one, as if the register stack had been popped; however, unlike the popping)]109 norm0
(139)pageodd
restore showpage
%%Page: 140 140
%%BeginPageSetup
save
%%EndPageSetup
/140 pa
[(of the stack performed by many FPU instructions, it does not flag the new )2(ST7)0( \(previously )2(ST0)0(\) as)]681 norm0
[(empty. See also )2(FDECSTP)0( \(){/section-B.4.75 xl}(section B.4.75){el}(\).)]670 norm2
[{/section-B.4.86 xa}2(FINIT)0(, )2(FNINIT)0(: Initialise Floating-Point Unit)](B.4.86)652 subh3
[2(FINIT                         ; 9B DB E3             [8086,FPU] )]635 code1
[2(FNINIT                        ; DB E3                [8086,FPU])]624 code2
[2(FINIT)0( initialises the FPU to its default state. It flags all registers as empty, without actually change)]607 norm1
[(their values, clears the top of stack pointer. )2(FNINIT)0( does the same, without first waiting for)]596 norm0
[(pending exceptions to clear.)]585 norm2
[{/section-B.4.87 xa}2(FISUB)0(: Floating-Point/Integer Subtraction)](B.4.87)567 subh3
[2(FISUB mem16                   ; DE /4                [8086,FPU] )]550 code1
[2(FISUB mem32                   ; DA /4                [8086,FPU])]539 code2
[2(FISUBR mem16                  ; DE /5                [8086,FPU] )]522 code1
[2(FISUBR mem32                  ; DA /5                [8086,FPU])]511 code2
[2(FISUB)0( subtracts the 16-bit or 32-bit integer stored in the given memory location from )2(ST0)0(, and)]494 norm1
[(stores the result in )2(ST0)0(. )2(FISUBR)0( does the subtraction the other way round, i.e. it subtracts )2(ST0)]483 norm0
[(from the given integer, but still stores the result in )2(ST0)0(.)]472 norm2
[{/section-B.4.88 xa}2(FLD)0(: Floating-Point Load)](B.4.88)454 subh3
[2(FLD mem32                     ; D9 /0                [8086,FPU] )]437 code1
[2(FLD mem64                     ; DD /0                [8086,FPU] )]426 code0
[2(FLD mem80                     ; DB /5                [8086,FPU] )]415 code0
[2(FLD fpureg                    ; D9 C0+r              [8086,FPU])]404 code2
[2(FLD)0( loads a floating-point value out of the given register or memory location, and pushes it on the)]387 norm1
[(FPU register stack.)]376 norm2
[{/section-B.4.89 xa}2(FLDxx)0(: Floating-Point Load Constants)](B.4.89)358 subh3
[2(FLD1                          ; D9 E8                [8086,FPU] )]341 code1
[2(FLDL2E                        ; D9 EA                [8086,FPU] )]330 code0
[2(FLDL2T                        ; D9 E9                [8086,FPU] )]319 code0
[2(FLDLG2                        ; D9 EC                [8086,FPU] )]308 code0
[2(FLDLN2                        ; D9 ED                [8086,FPU] )]297 code0
[2(FLDPI                         ; D9 EB                [8086,FPU] )]286 code0
[2(FLDZ                          ; D9 EE                [8086,FPU])]275 code2
[(These instructions push specific standard constants on the FPU register stack.)]258 norm3
[2( Instruction    Constant pushed)]241 code3
[2( FLD1           1 )]224 code1
[2( FLDL2E         base-2 logarithm of e )]213 code0
[2( FLDL2T         base-2 log of 10 )]202 code0
[2( FLDLG2         base-10 log of 2 )]191 code0
[2( FLDLN2         base-e log of 2 )]180 code0
[2( FLDPI          pi )]169 code0
[2( FLDZ           zero)]158 code2
[{/section-B.4.90 xa}2(FLDCW)0(: Load Floating-Point Control Word)](B.4.90)140 subh3
[2(FLDCW mem16                   ; D9 /5                [8086,FPU])]123 code3
(140)pageeven
restore showpage
%%Page: 141 141
%%BeginPageSetup
save
%%EndPageSetup
/141 pa
[2(FLDCW)0( loads a 16-bit value out of memory and stores it into the FPU control word \(governing)]681 norm1
[(things like the rounding mode, the precision, and the exception masks\). See also )2(FSTCW)0( \(){/section-B.4.103 xl}(section){el}]670 norm0
[{/section-B.4.103 xl}(B.4.103){el}(\). If exceptions are enabled and you don't want to generate one, use )2(FCLEX)0( or )2(FNCLEX)]659 norm0
[(\(){/section-B.4.71 xl}(section B.4.71){el}(\) before loading the new control word.)]648 norm2
[{/section-B.4.91 xa}2(FLDENV)0(: Load Floating-Point Environment)](B.4.91)630 subh3
[2(FLDENV mem                    ; D9 /4                [8086,FPU])]613 code3
[2(FLDENV)0( loads the FPU operating environment \(control word, status word, tag word, instruction)]596 norm1
[(pointer, data pointer and last opcode\) from memory. The memory area is 14 or 28 bytes long,)]585 norm0
[(depending on the CPU mode at the time. See also )2(FSTENV)0( \(){/section-B.4.104 xl}(section B.4.104){el}(\).)]574 norm2
[{/section-B.4.92 xa}2(FMUL)0(, )2(FMULP)0(: Floating-Point Multiply)](B.4.92)556 subh3
[2(FMUL mem32                    ; D8 /1                [8086,FPU] )]539 code1
[2(FMUL mem64                    ; DC /1                [8086,FPU])]528 code2
[2(FMUL fpureg                   ; D8 C8+r              [8086,FPU] )]511 code1
[2(FMUL ST0,fpureg               ; D8 C8+r              [8086,FPU])]500 code2
[2(FMUL TO fpureg                ; DC C8+r              [8086,FPU] )]483 code1
[2(FMUL fpureg,ST0               ; DC C8+r              [8086,FPU])]472 code2
[2(FMULP fpureg                  ; DE C8+r              [8086,FPU] )]455 code1
[2(FMULP fpureg,ST0              ; DE C8+r              [8086,FPU])]444 code2
[2(FMUL)0( multiplies )2(ST0)0( by the given operand, and stores the result in )2(ST0)0(, unless the )2(TO)0( qualifier is)]427 norm1
[(used in which case it stores the result in the operand. )2(FMULP)0( performs the same operation as)]416 norm0
[2(FMUL TO)0(, and then pops the register stack.)]405 norm2
[{/section-B.4.93 xa}2(FNOP)0(: Floating-Point No Operation)](B.4.93)387 subh3
[2(FNOP                          ; D9 D0                [8086,FPU])]370 code3
[2(FNOP)0( does nothing.)]353 norm3
[{/section-B.4.94 xa}2(FPATAN)0(, )2(FPTAN)0(: Arctangent and Tangent)](B.4.94)335 subh3
[2(FPATAN                        ; D9 F3                [8086,FPU] )]318 code1
[2(FPTAN                         ; D9 F2                [8086,FPU])]307 code2
[2(FPATAN)0( computes the arctangent, in radians, of the result of dividing )2(ST1)0( by )2(ST0)0(, stores the result)]290 norm1
[(in )2(ST1)0(, and pops the register stack. It works like the C )2(atan2)0( function, in that changing the sign of)]279 norm0
[(both )2(ST0)0( and )2(ST1)0( changes the output value by pi \(so it performs true rectangular-to-polar)]268 norm0
[(coordinate conversion, with )2(ST1)0( being the Y coordinate and )2(ST0)0( being the X coordinate, not)]257 norm0
[(merely an arctangent\).)]246 norm2
[2(FPTAN)0( computes the tangent of the value in )2(ST0)0( \(in radians\), and stores the result back into )2(ST0)0(.)]229 norm3
[(The absolute value of )2(ST0)0( must be less than 2**63.)]212 norm3
[{/section-B.4.95 xa}2(FPREM)0(, )2(FPREM1)0(: Floating-Point Partial Remainder)](B.4.95)194 subh3
[2(FPREM                         ; D9 F8                [8086,FPU] )]177 code1
[2(FPREM1                        ; D9 F5                [386,FPU])]166 code2
[(These instructions both produce the remainder obtained by dividing )2(ST0)0( by )2(ST1)0(. This is)]149 norm1
[(calculated, notionally, by dividing )2(ST0)0( by )2(ST1)0(, rounding the result to an integer, multiplying by)]138 norm0
[2(ST1)0( again, and computing the value which would need to be added back on to the result to get back)]127 norm0
[(to the original value in )2(ST0)0(.)]116 norm2
(141)pageodd
restore showpage
%%Page: 142 142
%%BeginPageSetup
save
%%EndPageSetup
/142 pa
[(The two instructions differ in the way the notional round-to-integer operation is performed.)]681 norm1
[2(FPREM)0( does it by rounding towards zero, so that the remainder it returns always has the same sign)]670 norm0
[(as the original value in )2(ST0)0(; )2(FPREM1)0( does it by rounding to the nearest integer, so that the)]659 norm0
[(remainder always has at most half the magnitude of )2(ST1)0(.)]648 norm2
[(Both instructions calculate )1(partial)0( remainders, meaning that they may not manage to provide the)]631 norm1
[(final result, but might leave intermediate results in )2(ST0)0( instead. If this happens, they will set the C2)]620 norm0
[(flag in the FPU status word; therefore, to calculate a remainder, you should repeatedly execute)]609 norm0
[2(FPREM)0( or )2(FPREM1)0( until C2 becomes clear.)]598 norm2
[{/section-B.4.96 xa}2(FRNDINT)0(: Floating-Point Round to Integer)](B.4.96)580 subh3
[2(FRNDINT                       ; D9 FC                [8086,FPU])]563 code3
[2(FRNDINT)0( rounds the contents of )2(ST0)0( to an integer, according to the current rounding mode set in)]546 norm1
[(the FPU control word, and stores the result back in )2(ST0)0(.)]535 norm2
[{/section-B.4.97 xa}2(FSAVE)0(, )2(FRSTOR)0(: Save/Restore Floating-Point State)](B.4.97)517 subh3
[2(FSAVE mem                     ; 9B DD /6             [8086,FPU] )]500 code1
[2(FNSAVE mem                    ; DD /6                [8086,FPU])]489 code2
[2(FRSTOR mem                    ; DD /4                [8086,FPU])]472 code3
[2(FSAVE)0( saves the entire floating-point unit state, including all the information saved by )2(FSTENV)]455 norm1
[(\(){/section-B.4.104 xl}(section B.4.104){el}(\) plus the contents of all the registers, to a 94 or 108 byte area of memory)]444 norm0
[(\(depending on the CPU mode\). )2(FRSTOR)0( restores the floating-point state from the same area of)]433 norm0
[(memory.)]422 norm2
[2(FNSAVE)0( does the same as )2(FSAVE)0(, without first waiting for pending floating-point exceptions to)]405 norm1
[(clear.)]394 norm2
[{/section-B.4.98 xa}2(FSCALE)0(: Scale Floating-Point Value by Power of Two)](B.4.98)376 subh3
[2(FSCALE                        ; D9 FD                [8086,FPU])]359 code3
[2(FSCALE)0( scales a number by a power of two: it rounds )2(ST1)0( towards zero to obtain an integer, then)]342 norm1
[(multiplies )2(ST0)0( by two to the power of that integer, and stores the result in )2(ST0)0(.)]331 norm2
[{/section-B.4.99 xa}2(FSETPM)0(: Set Protected Mode)](B.4.99)313 subh3
[2(FSETPM                        ; DB E4                [286,FPU])]296 code3
[(This instruction initialises protected mode on the 287 floating-point coprocessor. It is only)]279 norm1
[(meaningful on that processor: the 387 and above treat the instruction as a no-operation.)]268 norm2
[{/section-B.4.100 xa}2(FSIN)0(, )2(FSINCOS)0(: Sine and Cosine)](B.4.100)250 subh3
[2(FSIN                          ; D9 FE                [386,FPU] )]233 code1
[2(FSINCOS                       ; D9 FB                [386,FPU])]222 code2
[2(FSIN)0( calculates the sine of )2(ST0)0( \(in radians\) and stores the result in )2(ST0)0(. )2(FSINCOS)0( does the same,)]205 norm1
[(but then pushes the cosine of the same value on the register stack, so that the sine ends up in )2(ST1)]194 norm0
[(and the cosine in )2(ST0)0(. )2(FSINCOS)0( is faster than executing )2(FSIN)0( and )2(FCOS)0( \(see ){/section-B.4.74 xl}(section B.4.74){el}(\) in)]183 norm0
[(succession.)]172 norm2
[(The absolute value of )2(ST0)0( must be less than 2**63.)]155 norm3
[{/section-B.4.101 xa}2(FSQRT)0(: Floating-Point Square Root)](B.4.101)137 subh3
[2(FSQRT                         ; D9 FA                [8086,FPU])]120 code3
[2(FSQRT)0( calculates the square root of )2(ST0)0( and stores the result in )2(ST0)0(.)]103 norm3
(142)pageeven
restore showpage
%%Page: 143 143
%%BeginPageSetup
save
%%EndPageSetup
/143 pa
[{/section-B.4.102 xa}2(FST)0(, )2(FSTP)0(: Floating-Point Store)](B.4.102)680 subh3
[2(FST mem32                     ; D9 /2                [8086,FPU] )]663 code1
[2(FST mem64                     ; DD /2                [8086,FPU] )]652 code0
[2(FST fpureg                    ; DD D0+r              [8086,FPU])]641 code2
[2(FSTP mem32                    ; D9 /3                [8086,FPU] )]624 code1
[2(FSTP mem64                    ; DD /3                [8086,FPU] )]613 code0
[2(FSTP mem80                    ; DB /7                [8086,FPU] )]602 code0
[2(FSTP fpureg                   ; DD D8+r              [8086,FPU])]591 code2
[2(FST)0( stores the value in )2(ST0)0( into the given memory location or other FPU register. )2(FSTP)0( does the)]574 norm1
[(same, but then pops the register stack.)]563 norm2
[{/section-B.4.103 xa}2(FSTCW)0(: Store Floating-Point Control Word)](B.4.103)545 subh3
[2(FSTCW mem16                   ; 9B D9 /7             [8086,FPU] )]528 code1
[2(FNSTCW mem16                  ; D9 /7                [8086,FPU])]517 code2
[2(FSTCW)0( stores the )2(FPU)0( control word \(governing things like the rounding mode, the precision, and)]500 norm1
[(the exception masks\) into a 2-byte memory area. See also )2(FLDCW)0( \(){/section-B.4.90 xl}(section B.4.90){el}(\).)]489 norm2
[2(FNSTCW)0( does the same thing as )2(FSTCW)0(, without first waiting for pending floating-point exceptions)]472 norm1
[(to clear.)]461 norm2
[{/section-B.4.104 xa}2(FSTENV)0(: Store Floating-Point Environment)](B.4.104)443 subh3
[2(FSTENV mem                    ; 9B D9 /6             [8086,FPU] )]426 code1
[2(FNSTENV mem                   ; D9 /6                [8086,FPU])]415 code2
[2(FSTENV)0( stores the )2(FPU)0( operating environment \(control word, status word, tag word, instruction)]398 norm1
[(pointer, data pointer and last opcode\) into memory. The memory area is 14 or 28 bytes long,)]387 norm0
[(depending on the CPU mode at the time. See also )2(FLDENV)0( \(){/section-B.4.91 xl}(section B.4.91){el}(\).)]376 norm2
[2(FNSTENV)0( does the same thing as )2(FSTENV)0(, without first waiting for pending floating-point)]359 norm1
[(exceptions to clear.)]348 norm2
[{/section-B.4.105 xa}2(FSTSW)0(: Store Floating-Point Status Word)](B.4.105)330 subh3
[2(FSTSW mem16                   ; 9B DD /7             [8086,FPU] )]313 code1
[2(FSTSW AX                      ; 9B DF E0             [286,FPU])]302 code2
[2(FNSTSW mem16                  ; DD /7                [8086,FPU] )]285 code1
[2(FNSTSW AX                     ; DF E0                [286,FPU])]274 code2
[2(FSTSW)0( stores the )2(FPU)0( status word into )2(AX)0( or into a 2-byte memory area.)]257 norm3
[2(FNSTSW)0( does the same thing as )2(FSTSW)0(, without first waiting for pending floating-point exceptions)]240 norm1
[(to clear.)]229 norm2
[{/section-B.4.106 xa}2(FSUB)0(, )2(FSUBP)0(, )2(FSUBR)0(, )2(FSUBRP)0(: Floating-Point Subtract)](B.4.106)211 subh3
[2(FSUB mem32                    ; D8 /4                [8086,FPU] )]194 code1
[2(FSUB mem64                    ; DC /4                [8086,FPU])]183 code2
[2(FSUB fpureg                   ; D8 E0+r              [8086,FPU] )]166 code1
[2(FSUB ST0,fpureg               ; D8 E0+r              [8086,FPU])]155 code2
[2(FSUB TO fpureg                ; DC E8+r              [8086,FPU] )]138 code1
[2(FSUB fpureg,ST0               ; DC E8+r              [8086,FPU])]127 code2
(143)pageodd
restore showpage
%%Page: 144 144
%%BeginPageSetup
save
%%EndPageSetup
/144 pa
[2(FSUBR mem32                   ; D8 /5                [8086,FPU] )]681 code1
[2(FSUBR mem64                   ; DC /5                [8086,FPU])]670 code2
[2(FSUBR fpureg                  ; D8 E8+r              [8086,FPU] )]653 code1
[2(FSUBR ST0,fpureg              ; D8 E8+r              [8086,FPU])]642 code2
[2(FSUBR TO fpureg               ; DC E0+r              [8086,FPU] )]625 code1
[2(FSUBR fpureg,ST0              ; DC E0+r              [8086,FPU])]614 code2
[2(FSUBP fpureg                  ; DE E8+r              [8086,FPU] )]597 code1
[2(FSUBP fpureg,ST0              ; DE E8+r              [8086,FPU])]586 code2
[2(FSUBRP fpureg                 ; DE E0+r              [8086,FPU] )]569 code1
[2(FSUBRP fpureg,ST0             ; DE E0+r              [8086,FPU])]558 code2
[2(FSUB)0( subtracts the given operand from )2(ST0)0( and stores the result back in )2(ST0)0(, unless the )2(TO)]541 bull1
[(qualifier is given, in which case it subtracts )2(ST0)0( from the given operand and stores the result in)]530 bull0
[(the operand.)]519 bull2
[2(FSUBR)0( does the same thing, but does the subtraction the other way up: so if )2(TO)0( is not given, it)]502 bull1
[(subtracts )2(ST0)0( from the given operand and stores the result in )2(ST0)0(, whereas if )2(TO)0( is given it)]491 bull0
[(subtracts its operand from )2(ST0)0( and stores the result in the operand.)]480 bull2
[2(FSUBP)0( operates like )2(FSUB TO)0(, but pops the register stack once it has finished.)]463 bull3
[2(FSUBRP)0( operates like )2(FSUBR TO)0(, but pops the register stack once it has finished.)]446 bull3
[{/section-B.4.107 xa}2(FTST)0(: Test )2(ST0)0( Against Zero)](B.4.107)428 subh3
[2(FTST                          ; D9 E4                [8086,FPU])]411 code3
[2(FTST)0( compares )2(ST0)0( with zero and sets the FPU flags accordingly. )2(ST0)0( is treated as the left-hand)]394 norm1
[(side of the comparison, so that a `less-than' result is generated if )2(ST0)0( is negative.)]383 norm2
[{/section-B.4.108 xa}2(FUCOMxx)0(: Floating-Point Unordered Compare)](B.4.108)365 subh3
[2(FUCOM fpureg                  ; DD E0+r              [386,FPU] )]348 code1
[2(FUCOM ST0,fpureg              ; DD E0+r              [386,FPU])]337 code2
[2(FUCOMP fpureg                 ; DD E8+r              [386,FPU] )]320 code1
[2(FUCOMP ST0,fpureg             ; DD E8+r              [386,FPU])]309 code2
[2(FUCOMPP                       ; DA E9                [386,FPU])]292 code3
[2(FUCOMI fpureg                 ; DB E8+r              [P6,FPU] )]275 code1
[2(FUCOMI ST0,fpureg             ; DB E8+r              [P6,FPU])]264 code2
[2(FUCOMIP fpureg                ; DF E8+r              [P6,FPU] )]247 code1
[2(FUCOMIP ST0,fpureg            ; DF E8+r              [P6,FPU])]236 code2
[2(FUCOM)0( compares )2(ST0)0( with the given operand, and sets the FPU flags accordingly. )2(ST0)0( is)]219 bull1
[(treated as the left-hand side of the comparison, so that the carry flag is set \(for a `less-than')]208 bull0
[(result\) if )2(ST0)0( is less than the given operand.)]197 bull2
[2(FUCOMP)0( does the same as )2(FUCOM)0(, but pops the register stack afterwards. )2(FUCOMPP)0( compares)]180 bull1
[2(ST0)0( with )2(ST1)0( and then pops the register stack twice.)]169 bull2
[2(FUCOMI)0( and )2(FUCOMIP)0( work like the corresponding forms of )2(FUCOM)0( and )2(FUCOMP)0(, but write)]152 bull1
[(their results directly to the CPU flags register rather than the FPU status word, so they can be)]141 bull0
[(immediately followed by conditional jump or conditional move instructions.)]130 bull2
(144)pageeven
restore showpage
%%Page: 145 145
%%BeginPageSetup
save
%%EndPageSetup
/145 pa
[(The )2(FUCOM)0( instructions differ from the )2(FCOM)0( instructions \(){/section-B.4.73 xl}(section B.4.73){el}(\) only in the way they)]681 norm1
[(handle quiet NaNs: )2(FUCOM)0( will handle them silently and set the condition code flags to an)]670 norm0
[(`unordered' result, whereas )2(FCOM)0( will generate an exception.)]659 norm2
[{/section-B.4.109 xa}2(FXAM)0(: Examine Class of Value in )2(ST0)](B.4.109)641 subh3
[2(FXAM                          ; D9 E5                [8086,FPU])]624 code3
[2(FXAM)0( sets the FPU flags )2(C3)0(, )2(C2)0( and )2(C0)0( depending on the type of value stored in )2(ST0)0(:)]607 norm3
[2( Register contents     Flags)]590 code3
[2( Unsupported format    000 )]573 code1
[2( NaN                   001 )]562 code0
[2( Finite number         010 )]551 code0
[2( Infinity              011 )]540 code0
[2( Zero                  100 )]529 code0
[2( Empty register        101 )]518 code0
[2( Denormal              110)]507 code2
[(Additionally, the )2(C1)0( flag is set to the sign of the number.)]490 norm3
[{/section-B.4.110 xa}2(FXCH)0(: Floating-Point Exchange)](B.4.110)472 subh3
[2(FXCH                          ; D9 C9                [8086,FPU] )]455 code1
[2(FXCH fpureg                   ; D9 C8+r              [8086,FPU] )]444 code0
[2(FXCH fpureg,ST0               ; D9 C8+r              [8086,FPU] )]433 code0
[2(FXCH ST0,fpureg               ; D9 C8+r              [8086,FPU])]422 code2
[2(FXCH)0( exchanges )2(ST0)0( with a given FPU register. The no-operand form exchanges )2(ST0)0( with )2(ST1)0(.)]405 norm3
[{/section-B.4.111 xa}2(FXRSTOR)0(: Restore )2(FP)0(, )2(MMX)0( and )2(SSE)0( State)](B.4.111)387 subh3
[2(FXRSTOR memory                ; 0F AE /1               [P6,SSE,FPU])]370 code3
[(The )2(FXRSTOR)0( instruction reloads the )2(FPU)0(, )2(MMX)0( and )2(SSE)0( state \(environment and registers\), from)]353 norm1
[(the 512 byte memory area defined by the source operand. This data should have been written by a)]342 norm0
[(previous )2(FXSAVE)0(.)]331 norm2
[{/section-B.4.112 xa}2(FXSAVE)0(: Store )2(FP)0(, )2(MMX)0( and )2(SSE)0( State)](B.4.112)313 subh3
[2(FXSAVE memory                 ; 0F AE /0         [P6,SSE,FPU])]296 code3
[2(FXSAVE)0(The FXSAVE instruction writes the current )2(FPU)0(, )2(MMX)0( and )2(SSE)0( technology states)]279 norm1
[(\(environment and registers\), to the 512 byte memory area defined by the destination operand. It)]268 norm0
[(does this without checking for pending unmasked floating-point exceptions \(similar to the)]257 norm0
[(operation of )2(FNSAVE)0(\).)]246 norm2
[(Unlike the )2(FSAVE/FNSAVE)0( instructions, the processor retains the contents of the )2(FPU)0(, )2(MMX)0( and)]229 norm1
[2(SSE)0( state in the processor after the state has been saved. This instruction has been optimised to)]218 norm0
[(maximize floating-point save performance.)]207 norm2
[{/section-B.4.113 xa}2(FXTRACT)0(: Extract Exponent and Significand)](B.4.113)189 subh3
[2(FXTRACT                       ; D9 F4                [8086,FPU])]172 code3
[2(FXTRACT)0( separates the number in )2(ST0)0( into its exponent and significand \(mantissa\), stores the)]155 norm1
[(exponent back into )2(ST0)0(, and then pushes the significand on the register stack \(so that the)]144 norm0
[(significand ends up in )2(ST0)0(, and the exponent in )2(ST1)0(\).)]133 norm2
(145)pageodd
restore showpage
%%Page: 146 146
%%BeginPageSetup
save
%%EndPageSetup
/146 pa
[{/section-B.4.114 xa}2(FYL2X)0(, )2(FYL2XP1)0(: Compute Y times Log2\(X\) or Log2\(X+1\))](B.4.114)680 subh3
[2(FYL2X                         ; D9 F1                [8086,FPU] )]663 code1
[2(FYL2XP1                       ; D9 F9                [8086,FPU])]652 code2
[2(FYL2X)0( multiplies )2(ST1)0( by the base-2 logarithm of )2(ST0)0(, stores the result in )2(ST1)0(, and pops the)]635 norm1
[(register stack \(so that the result ends up in )2(ST0)0(\). )2(ST0)0( must be non-zero and positive.)]624 norm2
[2(FYL2XP1)0( works the same way, but replacing the base-2 log of )2(ST0)0( with that of )2(ST0)0( plus one.)]607 norm1
[(This time, )2(ST0)0( must have magnitude no greater than 1 minus half the square root of two.)]596 norm2
[{/section-B.4.115 xa}2(HLT)0(: Halt Processor)](B.4.115)578 subh3
[2(HLT                           ; F4                   [8086,PRIV])]561 code3
[2(HLT)0( puts the processor into a halted state, where it will perform no more operations until restarted)]544 norm1
[(by an interrupt or a reset.)]533 norm2
[(On the 286 and later processors, this is a privileged instruction.)]516 norm3
[{/section-B.4.116 xa}2(IBTS)0(: Insert Bit String)](B.4.116)498 subh3
[2(IBTS r/m16,reg16              ; o16 0F A7 /r         [386,UNDOC] )]481 code1
[2(IBTS r/m32,reg32              ; o32 0F A7 /r         [386,UNDOC])]470 code2
[(The implied operation of this instruction is:)]453 norm3
[2(IBTS r/m16,AX,CL,reg16 )]436 code1
[2(IBTS r/m32,EAX,CL,reg32)]425 code2
[(Writes a bit string from the source operand to the destination. )2(CL)0( indicates the number of bits to be)]408 norm1
[(copied, from the low bits of the source. )2(\(E\)AX)0( indicates the low order bit offset in the destination)]397 norm0
[(that is written to. For example, if )2(CL)0( is set to 4 and )2(AX)0( \(for 16-bit code\) is set to 5, bits 0-3 of )2(src)]386 norm0
[(will be copied to bits 5-8 of )2(dst)0(. This instruction is very poorly documented, and I have been)]375 norm0
[(unable to find any official source of documentation on it.)]364 norm2
[2(IBTS)0( is supported only on the early Intel 386s, and conflicts with the opcodes for )2(CMPXCHG486)]347 norm1
[(\(on early Intel 486s\). NASM supports it only for completeness. Its counterpart is )2(XBTS)0( \(see ){/section-B.4.332 xl}(section){el}]336 norm0
[{/section-B.4.332 xl}(B.4.332){el}(\).)]325 norm2
[{/section-B.4.117 xa}2(IDIV)0(: Signed Integer Divide)](B.4.117)307 subh3
[2(IDIV r/m8                     ; F6 /7                [8086] )]290 code1
[2(IDIV r/m16                    ; o16 F7 /7            [8086] )]279 code0
[2(IDIV r/m32                    ; o32 F7 /7            [386])]268 code2
[2(IDIV)0( performs signed integer division. The explicit operand provided is the divisor; the dividend)]251 norm1
[(and destination operands are implicit, in the following way:)]240 norm2
[(For )2(IDIV r/m8)0(, )2(AX)0( is divided by the given operand; the quotient is stored in )2(AL)0( and the)]223 bull1
[(remainder in )2(AH)0(.)]212 bull2
[(For )2(IDIV r/m16)0(, )2(DX:AX)0( is divided by the given operand; the quotient is stored in )2(AX)0( and the)]195 bull1
[(remainder in )2(DX)0(.)]184 bull2
[(For )2(IDIV r/m32)0(, )2(EDX:EAX)0( is divided by the given operand; the quotient is stored in )2(EAX)0( and)]167 bull1
[(the remainder in )2(EDX)0(.)]156 bull2
[(Unsigned integer division is performed by the )2(DIV)0( instruction: see ){/section-B.4.59 xl}(section B.4.59){el}(.)]139 norm3
(146)pageeven
restore showpage
%%Page: 147 147
%%BeginPageSetup
save
%%EndPageSetup
/147 pa
[{/section-B.4.118 xa}2(IMUL)0(: Signed Integer Multiply)](B.4.118)680 subh3
[2(IMUL r/m8                     ; F6 /5                [8086] )]663 code1
[2(IMUL r/m16                    ; o16 F7 /5            [8086] )]652 code0
[2(IMUL r/m32                    ; o32 F7 /5            [386])]641 code2
[2(IMUL reg16,r/m16              ; o16 0F AF /r         [386] )]624 code1
[2(IMUL reg32,r/m32              ; o32 0F AF /r         [386])]613 code2
[2(IMUL reg16,imm8               ; o16 6B /r ib         [186] )]596 code1
[2(IMUL reg16,imm16              ; o16 69 /r iw         [186] )]585 code0
[2(IMUL reg32,imm8               ; o32 6B /r ib         [386] )]574 code0
[2(IMUL reg32,imm32              ; o32 69 /r id         [386])]563 code2
[2(IMUL reg16,r/m16,imm8         ; o16 6B /r ib         [186] )]546 code1
[2(IMUL reg16,r/m16,imm16        ; o16 69 /r iw         [186] )]535 code0
[2(IMUL reg32,r/m32,imm8         ; o32 6B /r ib         [386] )]524 code0
[2(IMUL reg32,r/m32,imm32        ; o32 69 /r id         [386])]513 code2
[2(IMUL)0( performs signed integer multiplication. For the single-operand form, the other operand and)]496 norm1
[(destination are implicit, in the following way:)]485 norm2
[(For )2(IMUL r/m8)0(, )2(AL)0( is multiplied by the given operand; the product is stored in )2(AX)0(.)]468 bull3
[(For )2(IMUL r/m16)0(, )2(AX)0( is multiplied by the given operand; the product is stored in )2(DX:AX)0(.)]451 bull3
[(For )2(IMUL r/m32)0(, )2(EAX)0( is multiplied by the given operand; the product is stored in )2(EDX:EAX)0(.)]434 bull3
[(The two-operand form multiplies its two operands and stores the result in the destination \(first\))]417 norm1
[(operand. The three-operand form multiplies its last two operands and stores the result in the first)]406 norm0
[(operand.)]395 norm2
[(The two-operand form with an immediate second operand is in fact a shorthand for the)]378 norm1
[(three-operand form, as can be seen by examining the opcode descriptions: in the two-operand)]367 norm0
[(form, the code )2(/r)0( takes both its register and )2(r/m)0( parts from the same operand \(the first one\).)]356 norm2
[(In the forms with an 8-bit immediate operand and another longer source operand, the immediate)]339 norm1
[(operand is considered to be signed, and is sign-extended to the length of the other source operand.)]328 norm0
[(In these cases, the )2(BYTE)0( qualifier is necessary to force NASM to generate this form of the)]317 norm0
[(instruction.)]306 norm2
[(Unsigned integer multiplication is performed by the )2(MUL)0( instruction: see ){/section-B.4.184 xl}(section B.4.184){el}(.)]289 norm3
[{/section-B.4.119 xa}2(IN)0(: Input from I/O Port)](B.4.119)271 subh3
[2(IN AL,imm8                    ; E4 ib                [8086] )]254 code1
[2(IN AX,imm8                    ; o16 E5 ib            [8086] )]243 code0
[2(IN EAX,imm8                   ; o32 E5 ib            [386] )]232 code0
[2(IN AL,DX                      ; EC                   [8086] )]221 code0
[2(IN AX,DX                      ; o16 ED               [8086] )]210 code0
[2(IN EAX,DX                     ; o32 ED               [386])]199 code2
[2(IN)0( reads a byte, word or doubleword from the specified I/O port, and stores it in the given)]182 norm1
[(destination register. The port number may be specified as an immediate value if it is between 0 and)]171 norm0
[(255, and otherwise must be stored in )2(DX)0(. See also )2(OUT)0( \(){/section-B.4.194 xl}(section B.4.194){el}(\).)]160 norm2
[{/section-B.4.120 xa}2(INC)0(: Increment Integer)](B.4.120)142 subh3
[2(INC reg16                     ; o16 40+r             [8086] )]125 code1
[2(INC reg32                     ; o32 40+r             [386] )]114 code0
[2(INC r/m8                      ; FE /0                [8086] )]103 code0
(147)pageodd
restore showpage
%%Page: 148 148
%%BeginPageSetup
save
%%EndPageSetup
/148 pa
[2(INC r/m16                     ; o16 FF /0            [8086] )]681 code0
[2(INC r/m32                     ; o32 FF /0            [386])]670 code2
[2(INC)0( adds 1 to its operand. It does )1(not)0( affect the carry flag: to affect the carry flag, use)]653 norm1
[2(ADD something,1)0( \(see ){/section-B.4.3 xl}(section B.4.3){el}(\). )2(INC)0( affects all the other flags according to the result.)]642 norm2
[(This instruction can be used with a )2(LOCK)0( prefix to allow atomic execution.)]625 norm3
[(See also )2(DEC)0( \(){/section-B.4.58 xl}(section B.4.58){el}(\).)]608 norm3
[{/section-B.4.121 xa}2(INSB)0(, )2(INSW)0(, )2(INSD)0(: Input String from I/O Port)](B.4.121)590 subh3
[2(INSB                          ; 6C                   [186] )]573 code1
[2(INSW                          ; o16 6D               [186] )]562 code0
[2(INSD                          ; o32 6D               [386])]551 code2
[2(INSB)0( inputs a byte from the I/O port specified in )2(DX)0( and stores it at )2([ES:DI])0( or )2([ES:EDI])0(. It)]534 norm1
[(then increments or decrements \(depending on the direction flag: increments if the flag is clear,)]523 norm0
[(decrements if it is set\) )2(DI)0( or )2(EDI)0(.)]512 norm2
[(The register used is )2(DI)0( if the address size is 16 bits, and )2(EDI)0( if it is 32 bits. If you need to use an)]495 norm1
[(address size not equal to the current )2(BITS)0( setting, you can use an explicit )2(a16)0( or )2(a32)0( prefix.)]484 norm2
[(Segment override prefixes have no effect for this instruction: the use of )2(ES)0( for the load from )2([DI])]467 norm1
[(or )2([EDI])0( cannot be overridden.)]456 norm2
[2(INSW)0( and )2(INSD)0( work in the same way, but they input a word or a doubleword instead of a byte,)]439 norm1
[(and increment or decrement the addressing register by 2 or 4 instead of 1.)]428 norm2
[(The )2(REP)0( prefix may be used to repeat the instruction )2(CX)0( \(or )2(ECX)0( \226 again, the address size chooses)]411 norm1
[(which\) times.)]400 norm2
[(See also )2(OUTSB)0(, )2(OUTSW)0( and )2(OUTSD)0( \(){/section-B.4.195 xl}(section B.4.195){el}(\).)]383 norm3
[{/section-B.4.122 xa}2(INT)0(: Software Interrupt)](B.4.122)365 subh3
[2(INT imm8                      ; CD ib                [8086])]348 code3
[2(INT)0( causes a software interrupt through a specified vector number from 0 to 255.)]331 norm3
[(The code generated by the )2(INT)0( instruction is always two bytes long: although there are short forms)]314 norm1
[(for some )2(INT)0( instructions, NASM does not generate them when it sees the )2(INT)0( mnemonic. In)]303 norm0
[(order to generate single-byte breakpoint instructions, use the )2(INT3)0( or )2(INT1)0( instructions \(see)]292 norm0
[{/section-B.4.123 xl}(section B.4.123){el}(\) instead.)]281 norm2
[{/section-B.4.123 xa}2(INT3)0(, )2(INT1)0(, )2(ICEBP)0(, )2(INT01)0(: Breakpoints)](B.4.123)263 subh3
[2(INT1                          ; F1                   [P6] )]246 code1
[2(ICEBP                         ; F1                   [P6] )]235 code0
[2(INT01                         ; F1                   [P6])]224 code2
[2(INT3                          ; CC                   [8086] )]207 code1
[2(INT03                         ; CC                   [8086])]196 code2
[2(INT1)0( and )2(INT3)0( are short one-byte forms of the instructions )2(INT 1)0( and )2(INT 3)0( \(see ){/section-B.4.122 xl}(section){el}]179 norm1
[{/section-B.4.122 xl}(B.4.122){el}(\). They perform a similar function to their longer counterparts, but take up less code space.)]168 norm0
[(They are used as breakpoints by debuggers.)]157 norm2
[2(INT1)0(, and its alternative synonyms )2(INT01)0( and )2(ICEBP)0(, is an instruction used by in-circuit)]140 bull1
[(emulators \(ICEs\). It is present, though not documented, on some processors down to the 286, but)]129 bull0
[(is only documented for the Pentium Pro. )2(INT3)0( is the instruction normally used as a breakpoint)]118 bull0
[(by debuggers.)]107 bull2
(148)pageeven
restore showpage
%%Page: 149 149
%%BeginPageSetup
save
%%EndPageSetup
/149 pa
[2(INT3)0(, and its synonym )2(INT03)0(, is not precisely equivalent to )2(INT 3)0(: the short form, since it is)]681 bull1
[(designed to be used as a breakpoint, bypasses the normal )2(IOPL)0( checks in virtual-8086 mode,)]670 bull0
[(and also does not go through interrupt redirection.)]659 bull2
[{/section-B.4.124 xa}2(INTO)0(: Interrupt if Overflow)](B.4.124)641 subh3
[2(INTO                          ; CE                   [8086])]624 code3
[2(INTO)0( performs an )2(INT 4)0( software interrupt \(see ){/section-B.4.122 xl}(section B.4.122){el}(\) if and only if the overflow flag)]607 norm1
[(is set.)]596 norm2
[{/section-B.4.125 xa}2(INVD)0(: Invalidate Internal Caches)](B.4.125)578 subh3
[2(INVD                          ; 0F 08                [486])]561 code3
[2(INVD)0( invalidates and empties the processor's internal caches, and causes the processor to instruct)]544 norm1
[(external caches to do the same. It does not write the contents of the caches back to memory first:)]533 norm0
[(any modified data held in the caches will be lost. To write the data back first, use )2(WBINVD)0( \(){/section-B.4.328 xl}(section){el}]522 norm0
[{/section-B.4.328 xl}(B.4.328){el}(\).)]511 norm2
[{/section-B.4.126 xa}2(INVLPG)0(: Invalidate TLB Entry)](B.4.126)493 subh3
[2(INVLPG mem                    ; 0F 01 /7             [486])]476 code3
[2(INVLPG)0( invalidates the translation lookahead buffer \(TLB\) entry associated with the supplied)]459 norm1
[(memory address.)]448 norm2
[{/section-B.4.127 xa}2(IRET)0(, )2(IRETW)0(, )2(IRETD)0(: Return from Interrupt)](B.4.127)430 subh3
[2(IRET                          ; CF                   [8086] )]413 code1
[2(IRETW                         ; o16 CF               [8086] )]402 code0
[2(IRETD                         ; o32 CF               [386])]391 code2
[2(IRET)0( returns from an interrupt \(hardware or software\) by means of popping )2(IP)0( \(or )2(EIP)0(\), )2(CS)0( and)]374 norm1
[(the flags off the stack and then continuing execution from the new )2(CS:IP)0(.)]363 norm2
[2(IRETW)0( pops )2(IP)0(, )2(CS)0( and the flags as 2 bytes each, taking 6 bytes off the stack in total. )2(IRETD)0( pops)]346 norm1
[2(EIP)0( as 4 bytes, pops a further 4 bytes of which the top two are discarded and the bottom two go)]335 norm0
[(into )2(CS)0(, and pops the flags as 4 bytes as well, taking 12 bytes off the stack.)]324 norm2
[2(IRET)0( is a shorthand for either )2(IRETW)0( or )2(IRETD)0(, depending on the default )2(BITS)0( setting at the time.)]307 norm3
[{/section-B.4.128 xa}2(Jcc)0(: Conditional Branch)](B.4.128)289 subh3
[2(Jcc imm                       ; 70+cc rb             [8086] )]272 code1
[2(Jcc NEAR imm                  ; 0F 80+cc rw/rd       [386])]261 code2
[(The )(conditional jump instructions execute a near \(same segment\) jump if and only if their)]244 norm1
[(conditions are satisfied. For example, )2(JNZ)0( jumps only if the zero flag is not set.)]233 norm2
[(The ordinary form of the instructions has only a 128-byte range; the )2(NEAR)0( form is a 386 extension)]216 norm1
[(to the instruction set, and can span the full size of a segment. NASM will not override your choice)]205 norm0
[(of jump instruction: if you want )2(Jcc NEAR)0(, you have to use the )2(NEAR)0( keyword.)]194 norm2
[(The )2(SHORT)0( keyword is allowed on the first form of the instruction, for clarity, but is not necessary.)]177 norm3
[(For details of the condition codes, see ){/section-B.2.2 xl}(section B.2.2){el}(.)]160 norm3
[{/section-B.4.129 xa}2(JCXZ)0(, )2(JECXZ)0(: Jump if CX/ECX Zero)](B.4.129)142 subh3
[2(JCXZ imm                      ; a16 E3 rb            [8086] )]125 code1
[2(JECXZ imm                     ; a32 E3 rb            [386])]114 code2
(149)pageodd
restore showpage
%%Page: 150 150
%%BeginPageSetup
save
%%EndPageSetup
/150 pa
[2(JCXZ)0( performs a short jump \(with maximum range 128 bytes\) if and only if the contents of the )2(CX)]681 norm1
[(register is 0. )2(JECXZ)0( does the same thing, but with )2(ECX)0(.)]670 norm2
[{/section-B.4.130 xa}2(JMP)0(: Jump)](B.4.130)652 subh3
[2(JMP imm                       ; E9 rw/rd             [8086] )]635 code1
[2(JMP SHORT imm                 ; EB rb                [8086] )]624 code0
[2(JMP imm:imm16                 ; o16 EA iw iw         [8086] )]613 code0
[2(JMP imm:imm32                 ; o32 EA id iw         [386] )]602 code0
[2(JMP FAR mem                   ; o16 FF /5            [8086] )]591 code0
[2(JMP FAR mem32                 ; o32 FF /5            [386] )]580 code0
[2(JMP r/m16                     ; o16 FF /4            [8086] )]569 code0
[2(JMP r/m32                     ; o32 FF /4            [386])]558 code2
[2(JMP)0( jumps to a given address. The address may be specified as an absolute segment and offset, or)]541 norm1
[(as a relative jump within the current segment.)]530 norm2
[2(JMP SHORT imm)0( has a maximum range of 128 bytes, since the displacement is specified as only)]513 norm1
[(8 bits, but takes up less code space. NASM does not choose when to generate )2(JMP SHORT)0( for you:)]502 norm0
[(you must explicitly code )2(SHORT)0( every time you want a short jump.)]491 norm2
[(You can choose between the two immediate )(far jump forms \()2(JMP imm:imm)0(\) by the use of the)]474 norm1
[2(WORD)0( and )2(DWORD)0( keywords: )2(JMP WORD 0x1234:0x5678)0(\) or)]463 norm0
[2(JMP DWORD 0x1234:0x56789abc)0(.)]452 norm2
[(The )2(JMP FAR mem)0( forms execute a far jump by loading the destination address out of memory.)]435 norm1
[(The address loaded consists of 16 or 32 bits of offset \(depending on the operand size\), and 16 bits of)]424 norm0
[(segment. The operand size may be overridden using )2(JMP WORD FAR mem)0( or)]413 norm0
[2(JMP DWORD FAR mem)0(.)]402 norm2
[(The )2(JMP r/m)0( forms execute a )(near jump \(within the same segment\), loading the destination)]385 norm1
[(address out of memory or out of a register. The keyword )2(NEAR)0( may be specified, for clarity, in)]374 norm0
[(these forms, but is not necessary. Again, operand size can be overridden using )2(JMP WORD mem)0( or)]363 norm0
[2(JMP DWORD mem)0(.)]352 norm2
[(As a convenience, NASM does not require you to jump to a far symbol by coding the cumbersome)]335 norm1
[2(JMP SEG routine:routine)0(, but instead allows the easier synonym )2(JMP FAR routine)0(.)]324 norm2
[(The )2(CALL r/m)0( forms given above are near calls; NASM will accept the )2(NEAR)0( keyword \(e.g.)]307 norm1
[2(CALL NEAR [address])0(\), even though it is not strictly necessary.)]296 norm2
[{/section-B.4.131 xa}2(LAHF)0(: Load AH from Flags)](B.4.131)278 subh3
[2(LAHF                          ; 9F                   [8086])]261 code3
[2(LAHF)0( sets the )2(AH)0( register according to the contents of the low byte of the flags word.)]244 norm3
[(The operation of )2(LAHF)0( is:)]227 norm3
[2( AH <-- SF:ZF:0:AF:0:PF:1:CF)]210 code3
[(See also )2(SAHF)0( \(){/section-B.4.282 xl}(section B.4.282){el}(\).)]193 norm3
[{/section-B.4.132 xa}2(LAR)0(: Load Access Rights)](B.4.132)175 subh3
[2(LAR reg16,r/m16               ; o16 0F 02 /r         [286,PRIV] )]158 code1
[2(LAR reg32,r/m32               ; o32 0F 02 /r         [286,PRIV])]147 code2
[2(LAR)0( takes the segment selector specified by its source \(second\) operand, finds the corresponding)]130 norm1
[(segment descriptor in the GDT or LDT, and loads the access-rights byte of the descriptor into its)]119 norm0
[(destination \(first\) operand.)]108 norm2
(150)pageeven
restore showpage
%%Page: 151 151
%%BeginPageSetup
save
%%EndPageSetup
/151 pa
[{/section-B.4.133 xa}2(LDMXCSR)0(: Load Streaming SIMD Extension Control/Status)](B.4.133)680 subh3
[2(LDMXCSR mem32                 ; 0F AE /2        [KATMAI,SSE])]663 code3
[2(LDMXCSR)0( loads 32-bits of data from the specified memory location into the )2(MXCSR)0( control/status)]646 norm1
[(register. )2(MXCSR)0( is used to enable masked/unmasked exception handling, to set rounding modes, to)]635 norm0
[(set flush-to-zero mode, and to view exception status flags.)]624 norm2
[(For details of the )2(MXCSR)0( register, see the Intel processor docs.)]607 norm3
[(See also )2(STMXCSR)0( \(){/section-B.4.302 xl}(section B.4.302){el}]590 norm3
[{/section-B.4.134 xa}2(LDS)0(, )2(LES)0(, )2(LFS)0(, )2(LGS)0(, )2(LSS)0(: Load Far Pointer)](B.4.134)572 subh3
[2(LDS reg16,mem                 ; o16 C5 /r            [8086] )]555 code1
[2(LDS reg32,mem                 ; o32 C5 /r            [386])]544 code2
[2(LES reg16,mem                 ; o16 C4 /r            [8086] )]527 code1
[2(LES reg32,mem                 ; o32 C4 /r            [386])]516 code2
[2(LFS reg16,mem                 ; o16 0F B4 /r         [386] )]499 code1
[2(LFS reg32,mem                 ; o32 0F B4 /r         [386])]488 code2
[2(LGS reg16,mem                 ; o16 0F B5 /r         [386] )]471 code1
[2(LGS reg32,mem                 ; o32 0F B5 /r         [386])]460 code2
[2(LSS reg16,mem                 ; o16 0F B2 /r         [386] )]443 code1
[2(LSS reg32,mem                 ; o32 0F B2 /r         [386])]432 code2
[(These instructions load an entire far pointer \(16 or 32 bits of offset, plus 16 bits of segment\) out of)]415 norm1
[(memory in one go. )2(LDS)0(, for example, loads 16 or 32 bits from the given memory address into the)]404 norm0
[(given register \(depending on the size of the register\), then loads the )1(next)0( 16 bits from memory into)]393 norm0
[2(DS)0(. )2(LES)0(, )2(LFS)0(, )2(LGS)0( and )2(LSS)0( work in the same way but use the other segment registers.)]382 norm2
[{/section-B.4.135 xa}2(LEA)0(: Load Effective Address)](B.4.135)364 subh3
[2(LEA reg16,mem                 ; o16 8D /r            [8086] )]347 code1
[2(LEA reg32,mem                 ; o32 8D /r            [386])]336 code2
[2(LEA)0(, despite its syntax, does not access memory. It calculates the effective address specified by its)]319 norm1
[(second operand as if it were going to load or store data from it, but instead it stores the calculated)]308 norm0
[(address into the register specified by its first operand. This can be used to perform quite complex)]297 norm0
[(calculations \(e.g. )2(LEA EAX,[EBX+ECX*4+100])0(\) in one instruction.)]286 norm2
[2(LEA)0(, despite being a purely arithmetic instruction which accesses no memory, still requires square)]269 norm1
[(brackets around its second operand, as if it were a memory reference.)]258 norm2
[(The size of the calculation is the current )1(address)0( size, and the size that the result is stored as is the)]241 norm1
[(current )1(operand)0( size. If the address and operand size are not the same, then if the addressing mode)]230 norm0
[(was 32-bits, the low 16-bits are stored, and if the address was 16-bits, it is zero-extended to)]219 norm0
[(32-bits before storing.)]208 norm2
[{/section-B.4.136 xa}2(LEAVE)0(: Destroy Stack Frame)](B.4.136)190 subh3
[2(LEAVE                         ; C9                   [186])]173 code3
[2(LEAVE)0( destroys a stack frame of the form created by the )2(ENTER)0( instruction \(see ){/section-B.4.65 xl}(section B.4.65){el}(\). It)]156 norm1
[(is functionally equivalent to )2(MOV ESP,EBP)0( followed by )2(POP EBP)0( \(or )2(MOV SP,BP)0( followed by)]145 norm0
[2(POP BP)0( in 16-bit mode\).)]134 norm2
(151)pageodd
restore showpage
%%Page: 152 152
%%BeginPageSetup
save
%%EndPageSetup
/152 pa
[{/section-B.4.137 xa}2(LFENCE)0(: Load Fence)](B.4.137)680 subh3
[2(LFENCE                        ; 0F AE /5        [WILLAMETTE,SSE2])]663 code3
[2(LFENCE)0( performs a serialising operation on all loads from memory that were issued before the)]646 norm1
[2(LFENCE)0( instruction. This guarantees that all memory reads before the )2(LFENCE)0( instruction are)]635 norm0
[(visible before any reads after the )2(LFENCE)0( instruction.)]624 norm2
[2(LFENCE)0( is ordered respective to other )2(LFENCE)0( instruction, )2(MFENCE)0(, any memory read and any)]607 norm1
[(other serialising instruction \(such as )2(CPUID)0(\).)]596 norm2
[(Weakly ordered memory types can be used to achieve higher processor performance through such)]579 norm1
[(techniques as out-of-order issue and speculative reads. The degree to which a consumer of data)]568 norm0
[(recognizes or knows that the data is weakly ordered varies among applications and may be)]557 norm0
[(unknown to the producer of this data. The )2(LFENCE)0( instruction provides a performance-efficient)]546 norm0
[(way of ensuring load ordering between routines that produce weakly-ordered results and routines)]535 norm0
[(that consume that data.)]524 norm2
[2(LFENCE)0( uses the following ModRM encoding:)]507 norm3
[2(          Mod \(7:6\)        = 11B )]490 code1
[2(          Reg/Opcode \(5:3\) = 101B )]479 code0
[2(          R/M \(2:0\)        = 000B)]468 code2
[(All other ModRM encodings are defined to be reserved, and use of these encodings risks)]451 norm1
[(incompatibility with future processors.)]440 norm2
[(See also )2(SFENCE)0( \(){/section-B.4.288 xl}(section B.4.288){el}(\) and )2(MFENCE)0( \(){/section-B.4.151 xl}(section B.4.151){el}(\).)]423 norm3
[{/section-B.4.138 xa}2(LGDT)0(, )2(LIDT)0(, )2(LLDT)0(: Load Descriptor Tables)](B.4.138)405 subh3
[2(LGDT mem                      ; 0F 01 /2             [286,PRIV] )]388 code1
[2(LIDT mem                      ; 0F 01 /3             [286,PRIV] )]377 code0
[2(LLDT r/m16                    ; 0F 00 /2             [286,PRIV])]366 code2
[2(LGDT)0( and )2(LIDT)0( both take a 6-byte memory area as an operand: they load a 32-bit linear address)]349 norm1
[(and a 16-bit size limit from that area \(in the opposite order\) into the )2(GDTR)0( \(global descriptor table)]338 norm0
[(register\) or )2(IDTR)0( \(interrupt descriptor table register\). These are the only instructions which directly)]327 norm0
[(use )1(linear)0( addresses, rather than segment/offset pairs.)]316 norm2
[2(LLDT)0( takes a segment selector as an operand. The processor looks up that selector in the GDT and)]299 norm1
[(stores the limit and base address given there into the )2(LDTR)0( \(local descriptor table register\).)]288 norm2
[(See also )2(SGDT)0(, )2(SIDT)0( and )2(SLDT)0( \(){/section-B.4.289 xl}(section B.4.289){el}(\).)]271 norm3
[{/section-B.4.139 xa}2(LMSW)0(: Load/Store Machine Status Word)](B.4.139)253 subh3
[2(LMSW r/m16                    ; 0F 01 /6             [286,PRIV])]236 code3
[2(LMSW)0( loads the bottom four bits of the source operand into the bottom four bits of the )2(CR0)0( control)]219 norm1
[(register \(or the Machine Status Word, on 286 processors\). See also )2(SMSW)0( \(){/section-B.4.296 xl}(section B.4.296){el}(\).)]208 norm2
[{/section-B.4.140 xa}2(LOADALL)0(, )2(LOADALL286)0(: Load Processor State)](B.4.140)190 subh3
[2(LOADALL                       ; 0F 07                [386,UNDOC] )]173 code1
[2(LOADALL286                    ; 0F 05                [286,UNDOC])]162 code2
[(This instruction, in its two different-opcode forms, is apparently supported on most 286 processors,)]145 norm1
[(some 386 and possibly some 486. The opcode differs between the 286 and the 386.)]134 norm2
(152)pageeven
restore showpage
%%Page: 153 153
%%BeginPageSetup
save
%%EndPageSetup
/153 pa
[(The function of the instruction is to load all information relating to the state of the processor out of a)]681 norm1
[(block of memory: on the 286, this block is located implicitly at absolute address )2(0x800)0(, and on the)]670 norm0
[(386 and 486 it is at )2([ES:EDI])0(.)]659 norm2
[{/section-B.4.141 xa}2(LODSB)0(, )2(LODSW)0(, )2(LODSD)0(: Load from String)](B.4.141)641 subh3
[2(LODSB                         ; AC                   [8086] )]624 code1
[2(LODSW                         ; o16 AD               [8086] )]613 code0
[2(LODSD                         ; o32 AD               [386])]602 code2
[2(LODSB)0( loads a byte from )2([DS:SI])0( or )2([DS:ESI])0( into )2(AL)0(. It then increments or decrements)]585 norm1
[(\(depending on the direction flag: increments if the flag is clear, decrements if it is set\) )2(SI)0( or )2(ESI)0(.)]574 norm2
[(The register used is )2(SI)0( if the address size is 16 bits, and )2(ESI)0( if it is 32 bits. If you need to use an)]557 norm1
[(address size not equal to the current )2(BITS)0( setting, you can use an explicit )2(a16)0( or )2(a32)0( prefix.)]546 norm2
[(The segment register used to load from )2([SI])0( or )2([ESI])0( can be overridden by using a segment)]529 norm1
[(register name as a prefix \(for example, )2(ES LODSB)0(\).)]518 norm2
[2(LODSW)0( and )2(LODSD)0( work in the same way, but they load a word or a doubleword instead of a byte,)]501 norm1
[(and increment or decrement the addressing registers by 2 or 4 instead of 1.)]490 norm2
[{/section-B.4.142 xa}2(LOOP)0(, )2(LOOPE)0(, )2(LOOPZ)0(, )2(LOOPNE)0(, )2(LOOPNZ)0(: Loop with Counter)](B.4.142)472 subh3
[2(LOOP imm                      ; E2 rb                [8086] )]455 code1
[2(LOOP imm,CX                   ; a16 E2 rb            [8086] )]444 code0
[2(LOOP imm,ECX                  ; a32 E2 rb            [386])]433 code2
[2(LOOPE imm                     ; E1 rb                [8086] )]416 code1
[2(LOOPE imm,CX                  ; a16 E1 rb            [8086] )]405 code0
[2(LOOPE imm,ECX                 ; a32 E1 rb            [386] )]394 code0
[2(LOOPZ imm                     ; E1 rb                [8086] )]383 code0
[2(LOOPZ imm,CX                  ; a16 E1 rb            [8086] )]372 code0
[2(LOOPZ imm,ECX                 ; a32 E1 rb            [386])]361 code2
[2(LOOPNE imm                    ; E0 rb                [8086] )]344 code1
[2(LOOPNE imm,CX                 ; a16 E0 rb            [8086] )]333 code0
[2(LOOPNE imm,ECX                ; a32 E0 rb            [386] )]322 code0
[2(LOOPNZ imm                    ; E0 rb                [8086] )]311 code0
[2(LOOPNZ imm,CX                 ; a16 E0 rb            [8086] )]300 code0
[2(LOOPNZ imm,ECX                ; a32 E0 rb            [386])]289 code2
[2(LOOP)0( decrements its counter register \(either )2(CX)0( or )2(ECX)0( \226 if one is not specified explicitly, the)]272 norm1
[2(BITS)0( setting dictates which is used\) by one, and if the counter does not become zero as a result of)]261 norm0
[(this operation, it jumps to the given label. The jump has a range of 128 bytes.)]250 norm2
[2(LOOPE)0( \(or its synonym )2(LOOPZ)0(\) adds the additional condition that it only jumps if the counter is)]233 norm1
[(nonzero )1(and)0( the zero flag is set. Similarly, )2(LOOPNE)0( \(and )2(LOOPNZ)0(\) jumps only if the counter is)]222 norm0
[(nonzero and the zero flag is clear.)]211 norm2
[{/section-B.4.143 xa}2(LSL)0(: Load Segment Limit)](B.4.143)193 subh3
[2(LSL reg16,r/m16               ; o16 0F 03 /r         [286,PRIV] )]176 code1
[2(LSL reg32,r/m32               ; o32 0F 03 /r         [286,PRIV])]165 code2
[2(LSL)0( is given a segment selector in its source \(second\) operand; it computes the segment limit value)]148 norm1
[(by loading the segment limit field from the associated segment descriptor in the )2(GDT)0( or )2(LDT)0(. \(This)]137 norm0
[(involves shifting left by 12 bits if the segment limit is page-granular, and not if it is byte-granular;)]126 norm0
[(so you end up with a byte limit in either case.\) The segment limit obtained is then loaded into the)]115 norm0
[(destination \(first\) operand.)]104 norm2
(153)pageodd
restore showpage
%%Page: 154 154
%%BeginPageSetup
save
%%EndPageSetup
/154 pa
[{/section-B.4.144 xa}2(LTR)0(: Load Task Register)](B.4.144)680 subh3
[2(LTR r/m16                     ; 0F 00 /3             [286,PRIV])]663 code3
[2(LTR)0( looks up the segment base and limit in the GDT or LDT descriptor specified by the segment)]646 norm1
[(selector given as its operand, and loads them into the Task Register.)]635 norm2
[{/section-B.4.145 xa}2(MASKMOVDQU)0(: Byte Mask Write)](B.4.145)617 subh3
[2(MASKMOVDQU xmm1,xmm2          ; 66 0F F7 /r     [WILLAMETTE,SSE2])]600 code3
[2(MASKMOVDQU)0( stores data from xmm1 to the location specified by )2(ES:\(E\)DI)0(. The size of the)]583 norm1
[(store depends on the address-size attribute. The most significant bit in each byte of the mask)]572 norm0
[(register xmm2 is used to selectively write the data \(0 = no write, 1 = write\) on a per-byte basis.)]561 norm2
[{/section-B.4.146 xa}2(MASKMOVQ)0(: Byte Mask Write)](B.4.146)543 subh3
[2(MASKMOVQ mm1,mm2              ; 0F F7 /r        [KATMAI,MMX])]526 code3
[2(MASKMOVQ)0( stores data from mm1 to the location specified by )2(ES:\(E\)DI)0(. The size of the store)]509 norm1
[(depends on the address-size attribute. The most significant bit in each byte of the mask register)]498 norm0
[(mm2 is used to selectively write the data \(0 = no write, 1 = write\) on a per-byte basis.)]487 norm2
[{/section-B.4.147 xa}2(MAXPD)0(: Return Packed Double-Precision FP Maximum)](B.4.147)469 subh3
[2(MAXPD xmm1,xmm2/m128          ; 66 0F 5F /r     [WILLAMETTE,SSE2])]452 code3
[2(MAXPD)0( performs a SIMD compare of the packed double-precision FP numbers from xmm1 and)]435 norm1
[(xmm2/mem, and stores the maximum values of each pair of values in xmm1. If the values being)]424 norm0
[(compared are both zeroes, source2 \(xmm2/m128\) would be returned. If source2 \(xmm2/m128\) is an)]413 norm0
[(SNaN, this SNaN is forwarded unchanged to the destination \(i.e., a QNaN version of the SNaN is)]402 norm0
[(not returned\).)]391 norm2
[{/section-B.4.148 xa}2(MAXPS)0(: Return Packed Single-Precision FP Maximum)](B.4.148)373 subh3
[2(MAXPS xmm1,xmm2/m128          ; 0F 5F /r        [KATMAI,SSE])]356 code3
[2(MAXPS)0( performs a SIMD compare of the packed single-precision FP numbers from xmm1 and)]339 norm1
[(xmm2/mem, and stores the maximum values of each pair of values in xmm1. If the values being)]328 norm0
[(compared are both zeroes, source2 \(xmm2/m128\) would be returned. If source2 \(xmm2/m128\) is an)]317 norm0
[(SNaN, this SNaN is forwarded unchanged to the destination \(i.e., a QNaN version of the SNaN is)]306 norm0
[(not returned\).)]295 norm2
[{/section-B.4.149 xa}2(MAXSD)0(: Return Scalar Double-Precision FP Maximum)](B.4.149)277 subh3
[2(MAXSD xmm1,xmm2/m64           ; F2 0F 5F /r     [WILLAMETTE,SSE2])]260 code3
[2(MAXSD)0( compares the low-order double-precision FP numbers from xmm1 and xmm2/mem, and)]243 norm1
[(stores the maximum value in xmm1. If the values being compared are both zeroes, source2)]232 norm0
[(\(xmm2/m64\) would be returned. If source2 \(xmm2/m64\) is an SNaN, this SNaN is forwarded)]221 norm0
[(unchanged to the destination \(i.e., a QNaN version of the SNaN is not returned\). The high)]210 norm0
[(quadword of the destination is left unchanged.)]199 norm2
[{/section-B.4.150 xa}2(MAXSS)0(: Return Scalar Single-Precision FP Maximum)](B.4.150)181 subh3
[2(MAXSS xmm1,xmm2/m32           ; F3 0F 5F /r     [KATMAI,SSE])]164 code3
[2(MAXSS)0( compares the low-order single-precision FP numbers from xmm1 and xmm2/mem, and)]147 norm1
[(stores the maximum value in xmm1. If the values being compared are both zeroes, source2)]136 norm0
[(\(xmm2/m32\) would be returned. If source2 \(xmm2/m32\) is an SNaN, this SNaN is forwarded)]125 norm0
[(unchanged to the destination \(i.e., a QNaN version of the SNaN is not returned\). The high three)]114 norm0
[(doublewords of the destination are left unchanged.)]103 norm2
(154)pageeven
restore showpage
%%Page: 155 155
%%BeginPageSetup
save
%%EndPageSetup
/155 pa
[{/section-B.4.151 xa}2(MFENCE)0(: Memory Fence)](B.4.151)680 subh3
[2(MFENCE                        ; 0F AE /6        [WILLAMETTE,SSE2])]663 code3
[2(MFENCE)0( performs a serialising operation on all loads from memory and writes to memory that were)]646 norm1
[(issued before the )2(MFENCE)0( instruction. This guarantees that all memory reads and writes before the)]635 norm0
[2(MFENCE)0( instruction are completed before any reads and writes after the )2(MFENCE)0( instruction.)]624 norm2
[2(MFENCE)0( is ordered respective to other )2(MFENCE)0( instructions, )2(LFENCE)0(, )2(SFENCE)0(, any memory read)]607 norm1
[(and any other serialising instruction \(such as )2(CPUID)0(\).)]596 norm2
[(Weakly ordered memory types can be used to achieve higher processor performance through such)]579 norm1
[(techniques as out-of-order issue, speculative reads, write-combining, and write-collapsing. The)]568 norm0
[(degree to which a consumer of data recognizes or knows that the data is weakly ordered varies)]557 norm0
[(among applications and may be unknown to the producer of this data. The )2(MFENCE)0( instruction)]546 norm0
[(provides a performance-efficient way of ensuring load and store ordering between routines that)]535 norm0
[(produce weakly-ordered results and routines that consume that data.)]524 norm2
[2(MFENCE)0( uses the following ModRM encoding:)]507 norm3
[2(          Mod \(7:6\)        = 11B )]490 code1
[2(          Reg/Opcode \(5:3\) = 110B )]479 code0
[2(          R/M \(2:0\)        = 000B)]468 code2
[(All other ModRM encodings are defined to be reserved, and use of these encodings risks)]451 norm1
[(incompatibility with future processors.)]440 norm2
[(See also )2(LFENCE)0( \(){/section-B.4.137 xl}(section B.4.137){el}(\) and )2(SFENCE)0( \(){/section-B.4.288 xl}(section B.4.288){el}(\).)]423 norm3
[{/section-B.4.152 xa}2(MINPD)0(: Return Packed Double-Precision FP Minimum)](B.4.152)405 subh3
[2(MINPD xmm1,xmm2/m128          ; 66 0F 5D /r     [WILLAMETTE,SSE2])]388 code3
[2(MINPD)0( performs a SIMD compare of the packed double-precision FP numbers from xmm1 and)]371 norm1
[(xmm2/mem, and stores the minimum values of each pair of values in xmm1. If the values being)]360 norm0
[(compared are both zeroes, source2 \(xmm2/m128\) would be returned. If source2 \(xmm2/m128\) is an)]349 norm0
[(SNaN, this SNaN is forwarded unchanged to the destination \(i.e., a QNaN version of the SNaN is)]338 norm0
[(not returned\).)]327 norm2
[{/section-B.4.153 xa}2(MINPS)0(: Return Packed Single-Precision FP Minimum)](B.4.153)309 subh3
[2(MINPS xmm1,xmm2/m128          ; 0F 5D /r        [KATMAI,SSE])]292 code3
[2(MINPS)0( performs a SIMD compare of the packed single-precision FP numbers from xmm1 and)]275 norm1
[(xmm2/mem, and stores the minimum values of each pair of values in xmm1. If the values being)]264 norm0
[(compared are both zeroes, source2 \(xmm2/m128\) would be returned. If source2 \(xmm2/m128\) is an)]253 norm0
[(SNaN, this SNaN is forwarded unchanged to the destination \(i.e., a QNaN version of the SNaN is)]242 norm0
[(not returned\).)]231 norm2
[{/section-B.4.154 xa}2(MINSD)0(: Return Scalar Double-Precision FP Minimum)](B.4.154)213 subh3
[2(MINSD xmm1,xmm2/m64           ; F2 0F 5D /r     [WILLAMETTE,SSE2])]196 code3
[2(MINSD)0( compares the low-order double-precision FP numbers from xmm1 and xmm2/mem, and)]179 norm1
[(stores the minimum value in xmm1. If the values being compared are both zeroes, source2)]168 norm0
[(\(xmm2/m64\) would be returned. If source2 \(xmm2/m64\) is an SNaN, this SNaN is forwarded)]157 norm0
[(unchanged to the destination \(i.e., a QNaN version of the SNaN is not returned\). The high)]146 norm0
[(quadword of the destination is left unchanged.)]135 norm2
[{/section-B.4.155 xa}2(MINSS)0(: Return Scalar Single-Precision FP Minimum)](B.4.155)117 subh3
[2(MINSS xmm1,xmm2/m32           ; F3 0F 5D /r     [KATMAI,SSE])]100 code3
(155)pageodd
restore showpage
%%Page: 156 156
%%BeginPageSetup
save
%%EndPageSetup
/156 pa
[2(MINSS)0( compares the low-order single-precision FP numbers from xmm1 and xmm2/mem, and)]681 norm1
[(stores the minimum value in xmm1. If the values being compared are both zeroes, source2)]670 norm0
[(\(xmm2/m32\) would be returned. If source2 \(xmm2/m32\) is an SNaN, this SNaN is forwarded)]659 norm0
[(unchanged to the destination \(i.e., a QNaN version of the SNaN is not returned\). The high three)]648 norm0
[(doublewords of the destination are left unchanged.)]637 norm2
[{/section-B.4.156 xa}2(MOV)0(: Move Data)](B.4.156)619 subh3
[2(MOV r/m8,reg8                 ; 88 /r                [8086] )]602 code1
[2(MOV r/m16,reg16               ; o16 89 /r            [8086] )]591 code0
[2(MOV r/m32,reg32               ; o32 89 /r            [386] )]580 code0
[2(MOV reg8,r/m8                 ; 8A /r                [8086] )]569 code0
[2(MOV reg16,r/m16               ; o16 8B /r            [8086] )]558 code0
[2(MOV reg32,r/m32               ; o32 8B /r            [386])]547 code2
[2(MOV reg8,imm8                 ; B0+r ib              [8086] )]530 code1
[2(MOV reg16,imm16               ; o16 B8+r iw          [8086] )]519 code0
[2(MOV reg32,imm32               ; o32 B8+r id          [386] )]508 code0
[2(MOV r/m8,imm8                 ; C6 /0 ib             [8086] )]497 code0
[2(MOV r/m16,imm16               ; o16 C7 /0 iw         [8086] )]486 code0
[2(MOV r/m32,imm32               ; o32 C7 /0 id         [386])]475 code2
[2(MOV AL,memoffs8               ; A0 ow/od             [8086] )]458 code1
[2(MOV AX,memoffs16              ; o16 A1 ow/od         [8086] )]447 code0
[2(MOV EAX,memoffs32             ; o32 A1 ow/od         [386] )]436 code0
[2(MOV memoffs8,AL               ; A2 ow/od             [8086] )]425 code0
[2(MOV memoffs16,AX              ; o16 A3 ow/od         [8086] )]414 code0
[2(MOV memoffs32,EAX             ; o32 A3 ow/od         [386])]403 code2
[2(MOV r/m16,segreg              ; o16 8C /r            [8086] )]386 code1
[2(MOV r/m32,segreg              ; o32 8C /r            [386] )]375 code0
[2(MOV segreg,r/m16              ; o16 8E /r            [8086] )]364 code0
[2(MOV segreg,r/m32              ; o32 8E /r            [386])]353 code2
[2(MOV reg32,CR0/2/3/4           ; 0F 20 /r             [386] )]336 code1
[2(MOV reg32,DR0/1/2/3/6/7       ; 0F 21 /r             [386] )]325 code0
[2(MOV reg32,TR3/4/5/6/7         ; 0F 24 /r             [386] )]314 code0
[2(MOV CR0/2/3/4,reg32           ; 0F 22 /r             [386] )]303 code0
[2(MOV DR0/1/2/3/6/7,reg32       ; 0F 23 /r             [386] )]292 code0
[2(MOV TR3/4/5/6/7,reg32         ; 0F 26 /r             [386])]281 code2
[2(MOV)0( copies the contents of its source \(second\) operand into its destination \(first\) operand.)]264 norm3
[(In all forms of the )2(MOV)0( instruction, the two operands are the same size, except for moving between)]247 norm1
[(a segment register and an )2(r/m32)0( operand. These instructions are treated exactly like the)]236 norm0
[(corresponding 16-bit equivalent \(so that, for example, )2(MOV DS,EAX)0( functions identically to)]225 norm0
[2(MOV DS,AX)0( but saves a prefix when in 32-bit mode\), except that when a segment register is)]214 norm0
[(moved into a 32-bit destination, the top two bytes of the result are undefined.)]203 norm2
[2(MOV)0( may not use )2(CS)0( as a destination.)]186 norm3
[2(CR4)0( is only a supported register on the Pentium and above.)]169 norm3
[(Test registers are supported on 386/486 processors and on some non-Intel Pentium class processors.)]152 norm3
[{/section-B.4.157 xa}2(MOVAPD)0(: Move Aligned Packed Double-Precision FP Values)](B.4.157)134 subh3
[2(MOVAPD xmm1,xmm2/mem128       ; 66 0F 28 /r     [WILLAMETTE,SSE2] )]117 code1
[2(MOVAPD xmm1/mem128,xmm2       ; 66 0F 29 /r     [WILLAMETTE,SSE2])]106 code2
(156)pageeven
restore showpage
%%Page: 157 157
%%BeginPageSetup
save
%%EndPageSetup
/157 pa
[2(MOVAPD)0( moves a double quadword containing 2 packed double-precision FP values from the)]681 norm1
[(source operand to the destination. When the source or destination operand is a memory location, it)]670 norm0
[(must be aligned on a 16-byte boundary.)]659 norm2
[(To move data in and out of memory locations that are not known to be on 16-byte boundaries, use)]642 norm1
[(the )2(MOVUPD)0( instruction \(){/section-B.4.182 xl}(section B.4.182){el}(\).)]631 norm2
[{/section-B.4.158 xa}2(MOVAPS)0(: Move Aligned Packed Single-Precision FP Values)](B.4.158)613 subh3
[2(MOVAPS xmm1,xmm2/mem128       ; 0F 28 /r        [KATMAI,SSE] )]596 code1
[2(MOVAPS xmm1/mem128,xmm2       ; 0F 29 /r        [KATMAI,SSE])]585 code2
[2(MOVAPS)0( moves a double quadword containing 4 packed single-precision FP values from the)]568 norm1
[(source operand to the destination. When the source or destination operand is a memory location, it)]557 norm0
[(must be aligned on a 16-byte boundary.)]546 norm2
[(To move data in and out of memory locations that are not known to be on 16-byte boundaries, use)]529 norm1
[(the )2(MOVUPS)0( instruction \(){/section-B.4.183 xl}(section B.4.183){el}(\).)]518 norm2
[{/section-B.4.159 xa}2(MOVD)0(: Move Doubleword to/from MMX Register)](B.4.159)500 subh3
[2(MOVD mm,r/m32                 ; 0F 6E /r             [PENT,MMX] )]483 code1
[2(MOVD r/m32,mm                 ; 0F 7E /r             [PENT,MMX] )]472 code0
[2(MOVD xmm,r/m32                ; 66 0F 6E /r     [WILLAMETTE,SSE2] )]461 code0
[2(MOVD r/m32,xmm                ; 66 0F 7E /r     [WILLAMETTE,SSE2])]450 code2
[2(MOVD)0( copies 32 bits from its source \(second\) operand into its destination \(first\) operand. When the)]433 norm1
[(destination is a 64-bit )2(MMX)0( register or a 128-bit )2(XMM)0( register, the input value is zero-extended to)]422 norm0
[(fill the destination register.)]411 norm2
[{/section-B.4.160 xa}2(MOVDQ2Q)0(: Move Quadword from XMM to MMX register.)](B.4.160)393 subh3
[2(MOVDQ2Q mm,xmm                ; F2 OF D6 /r     [WILLAMETTE,SSE2])]376 code3
[2(MOVDQ2Q)0( moves the low quadword from the source operand to the destination operand.)]359 norm3
[{/section-B.4.161 xa}2(MOVDQA)0(: Move Aligned Double Quadword)](B.4.161)341 subh3
[2(MOVDQA xmm1,xmm2/m128         ; 66 OF 6F /r     [WILLAMETTE,SSE2] )]324 code1
[2(MOVDQA xmm1/m128,xmm2         ; 66 OF 7F /r     [WILLAMETTE,SSE2])]313 code2
[2(MOVDQA)0( moves a double quadword from the source operand to the destination operand. When the)]296 norm1
[(source or destination operand is a memory location, it must be aligned to a 16-byte boundary.)]285 norm2
[(To move a double quadword to or from unaligned memory locations, use the )2(MOVDQU)0( instruction)]268 norm1
[(\(){/section-B.4.162 xl}(section B.4.162){el}(\).)]257 norm2
[{/section-B.4.162 xa}2(MOVDQU)0(: Move Unaligned Double Quadword)](B.4.162)239 subh3
[2(MOVDQU xmm1,xmm2/m128         ; F3 OF 6F /r     [WILLAMETTE,SSE2] )]222 code1
[2(MOVDQU xmm1/m128,xmm2         ; F3 OF 7F /r     [WILLAMETTE,SSE2])]211 code2
[2(MOVDQU)0( moves a double quadword from the source operand to the destination operand. When the)]194 norm1
[(source or destination operand is a memory location, the memory may be unaligned.)]183 norm2
[(To move a double quadword to or from known aligned memory locations, use the )2(MOVDQA)]166 norm1
[(instruction \(){/section-B.4.161 xl}(section B.4.161){el}(\).)]155 norm2
[{/section-B.4.163 xa}2(MOVHLPS)0(: Move Packed Single-Precision FP High to Low)](B.4.163)137 subh3
[2(MOVHLPS xmm1,xmm2             ; OF 12 /r        [KATMAI,SSE])]120 code3
(157)pageodd
restore showpage
%%Page: 158 158
%%BeginPageSetup
save
%%EndPageSetup
/158 pa
[2(MOVHLPS)0( moves the two packed single-precision FP values from the high quadword of the source)]681 norm1
[(register xmm2 to the low quadword of the destination register, xmm2. The upper quadword of)]670 norm0
[(xmm1 is left unchanged.)]659 norm2
[(The operation of this instruction is:)]642 norm3
[2(   dst[0-63]   := src[64-127], )]625 code1
[2(   dst[64-127] remains unchanged.)]614 code2
[{/section-B.4.164 xa}2(MOVHPD)0(: Move High Packed Double-Precision FP)](B.4.164)596 subh3
[2(MOVHPD xmm,m64               ; 66 OF 16 /r      [WILLAMETTE,SSE2] )]579 code1
[2(MOVHPD m64,xmm               ; 66 OF 17 /r      [WILLAMETTE,SSE2])]568 code2
[2(MOVHPD)0( moves a double-precision FP value between the source and destination operands. One of)]551 norm1
[(the operands is a 64-bit memory location, the other is the high quadword of an )2(XMM)0( register.)]540 norm2
[(The operation of this instruction is:)]523 norm3
[2(   mem[0-63]   := xmm[64-127];)]506 code3
[(or)]489 norm3
[2(   xmm[0-63]   remains unchanged; )]472 code1
[2(   xmm[64-127] := mem[0-63].)]461 code2
[{/section-B.4.165 xa}2(MOVHPS)0(: Move High Packed Single-Precision FP)](B.4.165)443 subh3
[2(MOVHPS xmm,m64               ; 0F 16 /r         [KATMAI,SSE] )]426 code1
[2(MOVHPS m64,xmm               ; 0F 17 /r         [KATMAI,SSE])]415 code2
[2(MOVHPS)0( moves two packed single-precision FP values between the source and destination)]398 norm1
[(operands. One of the operands is a 64-bit memory location, the other is the high quadword of an)]387 norm0
[2(XMM)0( register.)]376 norm2
[(The operation of this instruction is:)]359 norm3
[2(   mem[0-63]   := xmm[64-127];)]342 code3
[(or)]325 norm3
[2(   xmm[0-63]   remains unchanged; )]308 code1
[2(   xmm[64-127] := mem[0-63].)]297 code2
[{/section-B.4.166 xa}2(MOVLHPS)0(: Move Packed Single-Precision FP Low to High)](B.4.166)279 subh3
[2(MOVLHPS xmm1,xmm2             ; OF 16 /r         [KATMAI,SSE])]262 code3
[2(MOVLHPS)0( moves the two packed single-precision FP values from the low quadword of the source)]245 norm1
[(register xmm2 to the high quadword of the destination register, xmm2. The low quadword of xmm1)]234 norm0
[(is left unchanged.)]223 norm2
[(The operation of this instruction is:)]206 norm3
[2(   dst[0-63]   remains unchanged; )]189 code1
[2(   dst[64-127] := src[0-63].)]178 code2
[{/section-B.4.167 xa}2(MOVLPD)0(: Move Low Packed Double-Precision FP)](B.4.167)160 subh3
[2(MOVLPD xmm,m64                ; 66 OF 12 /r     [WILLAMETTE,SSE2] )]143 code1
[2(MOVLPD m64,xmm                ; 66 OF 13 /r     [WILLAMETTE,SSE2])]132 code2
[2(MOVLPD)0( moves a double-precision FP value between the source and destination operands. One of)]115 norm1
[(the operands is a 64-bit memory location, the other is the low quadword of an )2(XMM)0( register.)]104 norm2
(158)pageeven
restore showpage
%%Page: 159 159
%%BeginPageSetup
save
%%EndPageSetup
/159 pa
[(The operation of this instruction is:)]681 norm3
[2(   mem\(0-63\)   := xmm\(0-63\);)]664 code3
[(or)]647 norm3
[2(   xmm\(0-63\)   := mem\(0-63\); )]630 code1
[2(   xmm\(64-127\) remains unchanged.)]619 code2
[{/section-B.4.168 xa}2(MOVLPS)0(: Move Low Packed Single-Precision FP)](B.4.168)601 subh3
[2(MOVLPS xmm,m64                ; OF 12 /r        [KATMAI,SSE] )]584 code1
[2(MOVLPS m64,xmm                ; OF 13 /r        [KATMAI,SSE])]573 code2
[2(MOVLPS)0( moves two packed single-precision FP values between the source and destination)]556 norm1
[(operands. One of the operands is a 64-bit memory location, the other is the low quadword of an)]545 norm0
[2(XMM)0( register.)]534 norm2
[(The operation of this instruction is:)]517 norm3
[2(   mem\(0-63\)   := xmm\(0-63\);)]500 code3
[(or)]483 norm3
[2(   xmm\(0-63\)   := mem\(0-63\); )]466 code1
[2(   xmm\(64-127\) remains unchanged.)]455 code2
[{/section-B.4.169 xa}2(MOVMSKPD)0(: Extract Packed Double-Precision FP Sign Mask)](B.4.169)437 subh3
[2(MOVMSKPD reg32,xmm              ; 66 0F 50 /r   [WILLAMETTE,SSE2])]420 code3
[2(MOVMSKPD)0( inserts a 2-bit mask in r32, formed of the most significant bits of each)]403 norm1
[(double-precision FP number of the source operand.)]392 norm2
[{/section-B.4.170 xa}2(MOVMSKPS)0(: Extract Packed Single-Precision FP Sign Mask)](B.4.170)374 subh3
[2(MOVMSKPS reg32,xmm              ; 0F 50 /r      [KATMAI,SSE])]357 code3
[2(MOVMSKPS)0( inserts a 4-bit mask in r32, formed of the most significant bits of each single-precision)]340 norm1
[(FP number of the source operand.)]329 norm2
[{/section-B.4.171 xa}2(MOVNTDQ)0(: Move Double Quadword Non Temporal)](B.4.171)311 subh3
[2(MOVNTDQ m128,xmm              ; 66 0F E7 /r     [WILLAMETTE,SSE2])]294 code3
[2(MOVNTDQ)0( moves the double quadword from the )2(XMM)0( source register to the destination memory)]277 norm1
[(location, using a non-temporal hint. This store instruction minimizes cache pollution.)]266 norm2
[{/section-B.4.172 xa}2(MOVNTI)0(: Move Doubleword Non Temporal)](B.4.172)248 subh3
[2(MOVNTI m32,reg32              ; 0F C3 /r        [WILLAMETTE,SSE2])]231 code3
[2(MOVNTI)0( moves the doubleword in the source register to the destination memory location, using a)]214 norm1
[(non-temporal hint. This store instruction minimizes cache pollution.)]203 norm2
[{/section-B.4.173 xa}2(MOVNTPD)0(: Move Aligned Four Packed Single-Precision FP Values Non Temporal)](B.4.173)185 subh3
[2(MOVNTPD m128,xmm              ; 66 0F 2B /r     [WILLAMETTE,SSE2])]168 code3
[2(MOVNTPD)0( moves the double quadword from the )2(XMM)0( source register to the destination memory)]151 norm1
[(location, using a non-temporal hint. This store instruction minimizes cache pollution. The memory)]140 norm0
[(location must be aligned to a 16-byte boundary.)]129 norm2
(159)pageodd
restore showpage
%%Page: 160 160
%%BeginPageSetup
save
%%EndPageSetup
/160 pa
[{/section-B.4.174 xa}2(MOVNTPS)0(: Move Aligned Four Packed Single-Precision FP Values Non Temporal)](B.4.174)680 subh3
[2(MOVNTPS m128,xmm              ; 0F 2B /r        [KATMAI,SSE])]663 code3
[2(MOVNTPS)0( moves the double quadword from the )2(XMM)0( source register to the destination memory)]646 norm1
[(location, using a non-temporal hint. This store instruction minimizes cache pollution. The memory)]635 norm0
[(location must be aligned to a 16-byte boundary.)]624 norm2
[{/section-B.4.175 xa}2(MOVNTQ)0(: Move Quadword Non Temporal)](B.4.175)606 subh3
[2(MOVNTQ m64,mm                 ; 0F E7 /r        [KATMAI,MMX])]589 code3
[2(MOVNTQ)0( moves the quadword in the )2(MMX)0( source register to the destination memory location, using)]572 norm1
[(a non-temporal hint. This store instruction minimizes cache pollution.)]561 norm2
[{/section-B.4.176 xa}2(MOVQ)0(: Move Quadword to/from MMX Register)](B.4.176)543 subh3
[2(MOVQ mm1,mm2/m64               ; 0F 6F /r             [PENT,MMX] )]526 code1
[2(MOVQ mm1/m64,mm2               ; 0F 7F /r             [PENT,MMX])]515 code2
[2(MOVQ xmm1,xmm2/m64             ; F3 0F 7E /r    [WILLAMETTE,SSE2] )]498 code1
[2(MOVQ xmm1/m64,xmm2             ; 66 0F D6 /r    [WILLAMETTE,SSE2])]487 code2
[2(MOVQ)0( copies 64 bits from its source \(second\) operand into its destination \(first\) operand. When the)]470 norm1
[(source is an )2(XMM)0( register, the low quadword is moved. When the destination is an )2(XMM)0( register, the)]459 norm0
[(destination is the low quadword, and the high quadword is cleared.)]448 norm2
[{/section-B.4.177 xa}2(MOVQ2DQ)0(: Move Quadword from MMX to XMM register.)](B.4.177)430 subh3
[2(MOVQ2DQ xmm,mm                ; F3 OF D6 /r     [WILLAMETTE,SSE2])]413 code3
[2(MOVQ2DQ)0( moves the quadword from the source operand to the low quadword of the destination)]396 norm1
[(operand, and clears the high quadword.)]385 norm2
[{/section-B.4.178 xa}2(MOVSB)0(, )2(MOVSW)0(, )2(MOVSD)0(: Move String)](B.4.178)367 subh3
[2(MOVSB                         ; A4                   [8086] )]350 code1
[2(MOVSW                         ; o16 A5               [8086] )]339 code0
[2(MOVSD                         ; o32 A5               [386])]328 code2
[2(MOVSB)0( copies the byte at )2([DS:SI])0( or )2([DS:ESI])0( to )2([ES:DI])0( or )2([ES:EDI])0(. It then increments)]311 norm1
[(or decrements \(depending on the direction flag: increments if the flag is clear, decrements if it is)]300 norm0
[(set\) )2(SI)0( and )2(DI)0( \(or )2(ESI)0( and )2(EDI)0(\).)]289 norm2
[(The registers used are )2(SI)0( and )2(DI)0( if the address size is 16 bits, and )2(ESI)0( and )2(EDI)0( if it is 32 bits. If)]272 norm1
[(you need to use an address size not equal to the current )2(BITS)0( setting, you can use an explicit )2(a16)]261 norm0
[(or )2(a32)0( prefix.)]250 norm2
[(The segment register used to load from )2([SI])0( or )2([ESI])0( can be overridden by using a segment)]233 norm1
[(register name as a prefix \(for example, )2(es movsb)0(\). The use of )2(ES)0( for the store to )2([DI])0( or )2([EDI])]222 norm0
[(cannot be overridden.)]211 norm2
[2(MOVSW)0( and )2(MOVSD)0( work in the same way, but they copy a word or a doubleword instead of a byte,)]194 norm1
[(and increment or decrement the addressing registers by 2 or 4 instead of 1.)]183 norm2
[(The )2(REP)0( prefix may be used to repeat the instruction )2(CX)0( \(or )2(ECX)0( \226 again, the address size chooses)]166 norm1
[(which\) times.)]155 norm2
[{/section-B.4.179 xa}2(MOVSD)0(: Move Scalar Double-Precision FP Value)](B.4.179)137 subh3
[2(MOVSD xmm1,xmm2/m64           ; F2 0F 10 /r     [WILLAMETTE,SSE2] )]120 code1
[2(MOVSD xmm1/m64,xmm2           ; F2 0F 11 /r     [WILLAMETTE,SSE2])]109 code2
(160)pageeven
restore showpage
%%Page: 161 161
%%BeginPageSetup
save
%%EndPageSetup
/161 pa
[2(MOVSD)0( moves a double-precision FP value from the source operand to the destination operand.)]681 norm1
[(When the source or destination is a register, the low-order FP value is read or written.)]670 norm2
[{/section-B.4.180 xa}2(MOVSS)0(: Move Scalar Single-Precision FP Value)](B.4.180)652 subh3
[2(MOVSS xmm1,xmm2/m32           ; F3 0F 10 /r     [KATMAI,SSE] )]635 code1
[2(MOVSS xmm1/m32,xmm2           ; F3 0F 11 /r     [KATMAI,SSE])]624 code2
[2(MOVSS)0( moves a single-precision FP value from the source operand to the destination operand.)]607 norm1
[(When the source or destination is a register, the low-order FP value is read or written.)]596 norm2
[{/section-B.4.181 xa}2(MOVSX)0(, )2(MOVZX)0(: Move Data with Sign or Zero Extend)](B.4.181)578 subh3
[2(MOVSX reg16,r/m8              ; o16 0F BE /r         [386] )]561 code1
[2(MOVSX reg32,r/m8              ; o32 0F BE /r         [386] )]550 code0
[2(MOVSX reg32,r/m16             ; o32 0F BF /r         [386])]539 code2
[2(MOVZX reg16,r/m8              ; o16 0F B6 /r         [386] )]522 code1
[2(MOVZX reg32,r/m8              ; o32 0F B6 /r         [386] )]511 code0
[2(MOVZX reg32,r/m16             ; o32 0F B7 /r         [386])]500 code2
[2(MOVSX)0( sign-extends its source \(second\) operand to the length of its destination \(first\) operand, and)]483 norm1
[(copies the result into the destination operand. )2(MOVZX)0( does the same, but zero-extends rather than)]472 norm0
[(sign-extending.)]461 norm2
[{/section-B.4.182 xa}2(MOVUPD)0(: Move Unaligned Packed Double-Precision FP Values)](B.4.182)443 subh3
[2(MOVUPD xmm1,xmm2/mem128       ; 66 0F 10 /r     [WILLAMETTE,SSE2] )]426 code1
[2(MOVUPD xmm1/mem128,xmm2       ; 66 0F 11 /r     [WILLAMETTE,SSE2])]415 code2
[2(MOVUPD)0( moves a double quadword containing 2 packed double-precision FP values from the)]398 norm1
[(source operand to the destination. This instruction makes no assumptions about alignment of)]387 norm0
[(memory operands.)]376 norm2
[(To move data in and out of memory locations that are known to be on 16-byte boundaries, use the)]359 norm1
[2(MOVAPD)0( instruction \(){/section-B.4.157 xl}(section B.4.157){el}(\).)]348 norm2
[{/section-B.4.183 xa}2(MOVUPS)0(: Move Unaligned Packed Single-Precision FP Values)](B.4.183)330 subh3
[2(MOVUPS xmm1,xmm2/mem128       ; 0F 10 /r        [KATMAI,SSE] )]313 code1
[2(MOVUPS xmm1/mem128,xmm2       ; 0F 11 /r        [KATMAI,SSE])]302 code2
[2(MOVUPS)0( moves a double quadword containing 4 packed single-precision FP values from the)]285 norm1
[(source operand to the destination. This instruction makes no assumptions about alignment of)]274 norm0
[(memory operands.)]263 norm2
[(To move data in and out of memory locations that are known to be on 16-byte boundaries, use the)]246 norm1
[2(MOVAPS)0( instruction \(){/section-B.4.158 xl}(section B.4.158){el}(\).)]235 norm2
[{/section-B.4.184 xa}2(MUL)0(: Unsigned Integer Multiply)](B.4.184)217 subh3
[2(MUL r/m8                      ; F6 /4                [8086] )]200 code1
[2(MUL r/m16                     ; o16 F7 /4            [8086] )]189 code0
[2(MUL r/m32                     ; o32 F7 /4            [386])]178 code2
[2(MUL)0( performs unsigned integer multiplication. The other operand to the multiplication, and the)]161 norm1
[(destination operand, are implicit, in the following way:)]150 norm2
[(For )2(MUL r/m8)0(, )2(AL)0( is multiplied by the given operand; the product is stored in )2(AX)0(.)]133 bull3
[(For )2(MUL r/m16)0(, )2(AX)0( is multiplied by the given operand; the product is stored in )2(DX:AX)0(.)]116 bull3
(161)pageodd
restore showpage
%%Page: 162 162
%%BeginPageSetup
save
%%EndPageSetup
/162 pa
[(For )2(MUL r/m32)0(, )2(EAX)0( is multiplied by the given operand; the product is stored in )2(EDX:EAX)0(.)]681 bull3
[(Signed integer multiplication is performed by the )2(IMUL)0( instruction: see ){/section-B.4.118 xl}(section B.4.118){el}(.)]664 norm3
[{/section-B.4.185 xa}2(MULPD)0(: Packed Single-FP Multiply)](B.4.185)646 subh3
[2(MULPD xmm1,xmm2/mem128        ; 66 0F 59 /r     [WILLAMETTE,SSE2])]629 code3
[2(MULPD)0( performs a SIMD multiply of the packed double-precision FP values in both operands, and)]612 norm1
[(stores the results in the destination register.)]601 norm2
[{/section-B.4.186 xa}2(MULPS)0(: Packed Single-FP Multiply)](B.4.186)583 subh3
[2(MULPS xmm1,xmm2/mem128        ; 0F 59 /r        [KATMAI,SSE])]566 code3
[2(MULPS)0( performs a SIMD multiply of the packed single-precision FP values in both operands, and)]549 norm1
[(stores the results in the destination register.)]538 norm2
[{/section-B.4.187 xa}2(MULSD)0(: Scalar Single-FP Multiply)](B.4.187)520 subh3
[2(MULSD xmm1,xmm2/mem32         ; F2 0F 59 /r     [WILLAMETTE,SSE2])]503 code3
[2(MULSD)0( multiplies the lowest double-precision FP values of both operands, and stores the result in)]486 norm1
[(the low quadword of xmm1.)]475 norm2
[{/section-B.4.188 xa}2(MULSS)0(: Scalar Single-FP Multiply)](B.4.188)457 subh3
[2(MULSS xmm1,xmm2/mem32         ; F3 0F 59 /r     [KATMAI,SSE])]440 code3
[2(MULSS)0( multiplies the lowest single-precision FP values of both operands, and stores the result in)]423 norm1
[(the low doubleword of xmm1.)]412 norm2
[{/section-B.4.189 xa}2(NEG)0(, )2(NOT)0(: Two's and One's Complement)](B.4.189)394 subh3
[2(NEG r/m8                      ; F6 /3                [8086] )]377 code1
[2(NEG r/m16                     ; o16 F7 /3            [8086] )]366 code0
[2(NEG r/m32                     ; o32 F7 /3            [386])]355 code2
[2(NOT r/m8                      ; F6 /2                [8086] )]338 code1
[2(NOT r/m16                     ; o16 F7 /2            [8086] )]327 code0
[2(NOT r/m32                     ; o32 F7 /2            [386])]316 code2
[2(NEG)0( replaces the contents of its operand by the two's complement negation \(invert all the bits and)]299 norm1
[(then add one\) of the original value. )2(NOT)0(, similarly, performs one's complement \(inverts all the bits\).)]288 norm2
[{/section-B.4.190 xa}2(NOP)0(: No Operation)](B.4.190)270 subh3
[2(NOP                           ; 90                   [8086])]253 code3
[2(NOP)0( performs no operation. Its opcode is the same as that generated by )2(XCHG AX,AX)0( or)]236 norm1
[2(XCHG EAX,EAX)0( \(depending on the processor mode; see ){/section-B.4.333 xl}(section B.4.333){el}(\).)]225 norm2
[{/section-B.4.191 xa}2(OR)0(: Bitwise OR)](B.4.191)207 subh3
[2(OR r/m8,reg8                  ; 08 /r                [8086] )]190 code1
[2(OR r/m16,reg16                ; o16 09 /r            [8086] )]179 code0
[2(OR r/m32,reg32                ; o32 09 /r            [386])]168 code2
[2(OR reg8,r/m8                  ; 0A /r                [8086] )]151 code1
[2(OR reg16,r/m16                ; o16 0B /r            [8086] )]140 code0
[2(OR reg32,r/m32                ; o32 0B /r            [386])]129 code2
(162)pageeven
restore showpage
%%Page: 163 163
%%BeginPageSetup
save
%%EndPageSetup
/163 pa
[2(OR r/m8,imm8                  ; 80 /1 ib             [8086] )]681 code1
[2(OR r/m16,imm16                ; o16 81 /1 iw         [8086] )]670 code0
[2(OR r/m32,imm32                ; o32 81 /1 id         [386])]659 code2
[2(OR r/m16,imm8                 ; o16 83 /1 ib         [8086] )]642 code1
[2(OR r/m32,imm8                 ; o32 83 /1 ib         [386])]631 code2
[2(OR AL,imm8                    ; 0C ib                [8086] )]614 code1
[2(OR AX,imm16                   ; o16 0D iw            [8086] )]603 code0
[2(OR EAX,imm32                  ; o32 0D id            [386])]592 code2
[2(OR)0( performs a bitwise OR operation between its two operands \(i.e. each bit of the result is 1 if and)]575 norm1
[(only if at least one of the corresponding bits of the two inputs was 1\), and stores the result in the)]564 norm0
[(destination \(first\) operand.)]553 norm2
[(In the forms with an 8-bit immediate second operand and a longer first operand, the second operand)]536 norm1
[(is considered to be signed, and is sign-extended to the length of the first operand. In these cases, the)]525 norm0
[2(BYTE)0( qualifier is necessary to force NASM to generate this form of the instruction.)]514 norm2
[(The MMX instruction )2(POR)0( \(see ){/section-B.4.247 xl}(section B.4.247){el}(\) performs the same operation on the 64-bit MMX)]497 norm1
[(registers.)]486 norm2
[{/section-B.4.192 xa}2(ORPD)0(: Bit-wise Logical OR of Double-Precision FP Data)](B.4.192)468 subh3
[2(ORPD xmm1,xmm2/m128           ; 66 0F 56 /r     [WILLAMETTE,SSE2])]451 code3
[2(ORPD)0( return a bit-wise logical OR between xmm1 and xmm2/mem, and stores the result in xmm1.)]434 norm1
[(If the source operand is a memory location, it must be aligned to a 16-byte boundary.)]423 norm2
[{/section-B.4.193 xa}2(ORPS)0(: Bit-wise Logical OR of Single-Precision FP Data)](B.4.193)405 subh3
[2(ORPS xmm1,xmm2/m128           ; 0F 56 /r        [KATMAI,SSE])]388 code3
[2(ORPS)0( return a bit-wise logical OR between xmm1 and xmm2/mem, and stores the result in xmm1.)]371 norm1
[(If the source operand is a memory location, it must be aligned to a 16-byte boundary.)]360 norm2
[{/section-B.4.194 xa}2(OUT)0(: Output Data to I/O Port)](B.4.194)342 subh3
[2(OUT imm8,AL                   ; E6 ib                [8086] )]325 code1
[2(OUT imm8,AX                   ; o16 E7 ib            [8086] )]314 code0
[2(OUT imm8,EAX                  ; o32 E7 ib            [386] )]303 code0
[2(OUT DX,AL                     ; EE                   [8086] )]292 code0
[2(OUT DX,AX                     ; o16 EF               [8086] )]281 code0
[2(OUT DX,EAX                    ; o32 EF               [386])]270 code2
[2(OUT)0( writes the contents of the given source register to the specified I/O port. The port number may)]253 norm1
[(be specified as an immediate value if it is between 0 and 255, and otherwise must be stored in )2(DX)0(.)]242 norm0
[(See also )2(IN)0( \(){/section-B.4.119 xl}(section B.4.119){el}(\).)]231 norm2
[{/section-B.4.195 xa}2(OUTSB)0(, )2(OUTSW)0(, )2(OUTSD)0(: Output String to I/O Port)](B.4.195)213 subh3
[2(OUTSB                         ; 6E                   [186] )]196 code1
[2(OUTSW                         ; o16 6F               [186] )]185 code0
[2(OUTSD                         ; o32 6F               [386])]174 code2
[2(OUTSB)0( loads a byte from )2([DS:SI])0( or )2([DS:ESI])0( and writes it to the I/O port specified in )2(DX)0(. It)]157 norm1
[(then increments or decrements \(depending on the direction flag: increments if the flag is clear,)]146 norm0
[(decrements if it is set\) )2(SI)0( or )2(ESI)0(.)]135 norm2
[(The register used is )2(SI)0( if the address size is 16 bits, and )2(ESI)0( if it is 32 bits. If you need to use an)]118 norm1
[(address size not equal to the current )2(BITS)0( setting, you can use an explicit )2(a16)0( or )2(a32)0( prefix.)]107 norm2
(163)pageodd
restore showpage
%%Page: 164 164
%%BeginPageSetup
save
%%EndPageSetup
/164 pa
[(The segment register used to load from )2([SI])0( or )2([ESI])0( can be overridden by using a segment)]681 norm1
[(register name as a prefix \(for example, )2(es outsb)0(\).)]670 norm2
[2(OUTSW)0( and )2(OUTSD)0( work in the same way, but they output a word or a doubleword instead of a)]653 norm1
[(byte, and increment or decrement the addressing registers by 2 or 4 instead of 1.)]642 norm2
[(The )2(REP)0( prefix may be used to repeat the instruction )2(CX)0( \(or )2(ECX)0( \226 again, the address size chooses)]625 norm1
[(which\) times.)]614 norm2
[{/section-B.4.196 xa}2(PACKSSDW)0(, )2(PACKSSWB)0(, )2(PACKUSWB)0(: Pack Data)](B.4.196)596 subh3
[2(PACKSSDW mm1,mm2/m64          ; 0F 6B /r             [PENT,MMX] )]579 code1
[2(PACKSSWB mm1,mm2/m64          ; 0F 63 /r             [PENT,MMX] )]568 code0
[2(PACKUSWB mm1,mm2/m64          ; 0F 67 /r             [PENT,MMX])]557 code2
[2(PACKSSDW xmm1,xmm2/m128       ; 66 0F 6B /r     [WILLAMETTE,SSE2] )]540 code1
[2(PACKSSWB xmm1,xmm2/m128       ; 66 0F 63 /r     [WILLAMETTE,SSE2] )]529 code0
[2(PACKUSWB xmm1,xmm2/m128       ; 66 0F 67 /r     [WILLAMETTE,SSE2])]518 code2
[(All these instructions start by combining the source and destination operands, and then splitting the)]501 norm1
[(result in smaller sections which it then packs into the destination register. The )2(MMX)0( versions pack)]490 norm0
[(two 64-bit operands into one 64-bit register, while the )2(SSE)0( versions pack two 128-bit operands)]479 norm0
[(into one 128-bit register.)]468 norm2
[2(PACKSSWB)0( splits the combined value into words, and then reduces the words to bytes, using)]451 bull1
[(signed saturation. It then packs the bytes into the destination register in the same order the words)]440 bull0
[(were in.)]429 bull2
[2(PACKSSDW)0( performs the same operation as )2(PACKSSWB)0(, except that it reduces doublewords to)]412 bull1
[(words, then packs them into the destination register.)]401 bull2
[2(PACKUSWB)0( performs the same operation as )2(PACKSSWB)0(, except that it uses unsigned saturation)]384 bull1
[(when reducing the size of the elements.)]373 bull2
[(To perform signed saturation on a number, it is replaced by the largest signed number \()2(7FFFh)0( or)]356 norm1
[2(7Fh)0(\) that )1(will)0( fit, and if it is too small it is replaced by the smallest signed number \()2(8000h)0( or )2(80h)0(\))]345 norm0
[(that will fit. To perform unsigned saturation, the input is treated as unsigned, and the input is)]334 norm0
[(replaced by the largest unsigned number that will fit.)]323 norm2
[{/section-B.4.197 xa}2(PADDB)0(, )2(PADDW)0(, )2(PADDD)0(: Add Packed Integers)](B.4.197)305 subh3
[2(PADDB mm1,mm2/m64             ; 0F FC /r             [PENT,MMX] )]288 code1
[2(PADDW mm1,mm2/m64             ; 0F FD /r             [PENT,MMX] )]277 code0
[2(PADDD mm1,mm2/m64             ; 0F FE /r             [PENT,MMX])]266 code2
[2(PADDB xmm1,xmm2/m128          ; 66 0F FC /r     [WILLAMETTE,SSE2] )]249 code1
[2(PADDW xmm1,xmm2/m128          ; 66 0F FD /r     [WILLAMETTE,SSE2] )]238 code0
[2(PADDD xmm1,xmm2/m128          ; 66 0F FE /r     [WILLAMETTE,SSE2])]227 code2
[2(PADDx)0( performs packed addition of the two operands, storing the result in the destination \(first\))]210 norm1
[(operand.)]199 norm2
[2(PADDB)0( treats the operands as packed bytes, and adds each byte individually;)]182 bull3
[2(PADDW)0( treats the operands as packed words;)]165 bull3
[2(PADDD)0( treats its operands as packed doublewords.)]148 bull3
[(When an individual result is too large to fit in its destination, it is wrapped around and the low bits)]131 norm1
[(are stored, with the carry bit discarded.)]120 norm2
(164)pageeven
restore showpage
%%Page: 165 165
%%BeginPageSetup
save
%%EndPageSetup
/165 pa
[{/section-B.4.198 xa}2(PADDQ)0(: Add Packed Quadword Integers)](B.4.198)680 subh3
[2(PADDQ mm1,mm2/m64             ; 0F D4 /r             [PENT,MMX])]663 code3
[2(PADDQ xmm1,xmm2/m128          ; 66 0F D4 /r     [WILLAMETTE,SSE2])]646 code3
[2(PADDQ)0( adds the quadwords in the source and destination operands, and stores the result in the)]629 norm1
[(destination register.)]618 norm2
[(When an individual result is too large to fit in its destination, it is wrapped around and the low bits)]601 norm1
[(are stored, with the carry bit discarded.)]590 norm2
[{/section-B.4.199 xa}2(PADDSB)0(, )2(PADDSW)0(: Add Packed Signed Integers With Saturation)](B.4.199)572 subh3
[2(PADDSB mm1,mm2/m64            ; 0F EC /r             [PENT,MMX] )]555 code1
[2(PADDSW mm1,mm2/m64            ; 0F ED /r             [PENT,MMX])]544 code2
[2(PADDSB xmm1,xmm2/m128         ; 66 0F EC /r     [WILLAMETTE,SSE2] )]527 code1
[2(PADDSW xmm1,xmm2/m128         ; 66 0F ED /r     [WILLAMETTE,SSE2])]516 code2
[2(PADDSx)0( performs packed addition of the two operands, storing the result in the destination \(first\))]499 norm1
[(operand. )2(PADDSB)0( treats the operands as packed bytes, and adds each byte individually; and)]488 norm0
[2(PADDSW)0( treats the operands as packed words.)]477 norm2
[(When an individual result is too large to fit in its destination, a saturated value is stored. The)]460 norm1
[(resulting value is the value with the largest magnitude of the same sign as the result which will fit in)]449 norm0
[(the available space.)]438 norm2
[{/section-B.4.200 xa}2(PADDSIW)0(: MMX Packed Addition to Implicit Destination)](B.4.200)420 subh3
[2(PADDSIW mmxreg,r/m64          ; 0F 51 /r             [CYRIX,MMX])]403 code3
[2(PADDSIW)0(, specific to the Cyrix extensions to the MMX instruction set, performs the same function)]386 norm1
[(as )2(PADDSW)0(, except that the result is placed in an implied register.)]375 norm2
[(To work out the implied register, invert the lowest bit in the register number. So)]358 norm1
[2(PADDSIW MM0,MM2)0( would put the result in )2(MM1)0(, but )2(PADDSIW MM1,MM2)0( would put the result)]347 norm0
[(in )2(MM0)0(.)]336 norm2
[{/section-B.4.201 xa}2(PADDUSB)0(, )2(PADDUSW)0(: Add Packed Unsigned Integers With Saturation)](B.4.201)318 subh3
[2(PADDUSB mm1,mm2/m64           ; 0F DC /r             [PENT,MMX] )]301 code1
[2(PADDUSW mm1,mm2/m64           ; 0F DD /r             [PENT,MMX])]290 code2
[2(PADDUSB xmm1,xmm2/m128         ; 66 0F DC /r    [WILLAMETTE,SSE2] )]273 code1
[2(PADDUSW xmm1,xmm2/m128         ; 66 0F DD /r    [WILLAMETTE,SSE2])]262 code2
[2(PADDUSx)0( performs packed addition of the two operands, storing the result in the destination \(first\))]245 norm1
[(operand. )2(PADDUSB)0( treats the operands as packed bytes, and adds each byte individually; and)]234 norm0
[2(PADDUSW)0( treats the operands as packed words.)]223 norm2
[(When an individual result is too large to fit in its destination, a saturated value is stored. The)]206 norm1
[(resulting value is the maximum value that will fit in the available space.)]195 norm2
[{/section-B.4.202 xa}2(PAND)0(, )2(PANDN)0(: MMX Bitwise AND and AND-NOT)](B.4.202)177 subh3
[2(PAND mm1,mm2/m64              ; 0F DB /r             [PENT,MMX] )]160 code1
[2(PANDN mm1,mm2/m64             ; 0F DF /r             [PENT,MMX])]149 code2
[2(PAND xmm1,xmm2/m128           ; 66 0F DB /r     [WILLAMETTE,SSE2] )]132 code1
[2(PANDN xmm1,xmm2/m128          ; 66 0F DF /r     [WILLAMETTE,SSE2])]121 code2
(165)pageodd
restore showpage
%%Page: 166 166
%%BeginPageSetup
save
%%EndPageSetup
/166 pa
[2(PAND)0( performs a bitwise AND operation between its two operands \(i.e. each bit of the result is 1 if)]681 norm1
[(and only if the corresponding bits of the two inputs were both 1\), and stores the result in the)]670 norm0
[(destination \(first\) operand.)]659 norm2
[2(PANDN)0( performs the same operation, but performs a one's complement operation on the destination)]642 norm1
[(\(first\) operand first.)]631 norm2
[{/section-B.4.203 xa}2(PAUSE)0(: Spin Loop Hint)](B.4.203)613 subh3
[2(PAUSE                         ; F3 90           [WILLAMETTE,SSE2])]596 code3
[2(PAUSE)0( provides a hint to the processor that the following code is a spin loop. This improves)]579 norm1
[(processor performance by bypassing possible memory order violations. On older processors, this)]568 norm0
[(instruction operates as a )2(NOP)0(.)]557 norm2
[{/section-B.4.204 xa}2(PAVEB)0(: MMX Packed Average)](B.4.204)539 subh3
[2(PAVEB mmxreg,r/m64            ; 0F 50 /r             [CYRIX,MMX])]522 code3
[2(PAVEB)0(, specific to the Cyrix MMX extensions, treats its two operands as vectors of eight unsigned)]505 norm1
[(bytes, and calculates the average of the corresponding bytes in the operands. The resulting vector of)]494 norm0
[(eight averages is stored in the first operand.)]483 norm2
[(This opcode maps to )2(MOVMSKPS r32, xmm)0( on processors that support the SSE instruction set.)]466 norm3
[{/section-B.4.205 xa}2(PAVGB)0( )2(PAVGW)0(: Average Packed Integers)](B.4.205)448 subh3
[2(PAVGB mm1,mm2/m64             ; 0F E0 /r        [KATMAI,MMX] )]431 code1
[2(PAVGW mm1,mm2/m64             ; 0F E3 /r        [KATMAI,MMX,SM])]420 code2
[2(PAVGB xmm1,xmm2/m128          ; 66 0F E0 /r     [WILLAMETTE,SSE2] )]403 code1
[2(PAVGW xmm1,xmm2/m128          ; 66 0F E3 /r     [WILLAMETTE,SSE2])]392 code2
[2(PAVGB)0( and )2(PAVGW)0( add the unsigned data elements of the source operand to the unsigned data)]375 norm1
[(elements of the destination register, then adds 1 to the temporary results. The results of the add are)]364 norm0
[(then each independently right-shifted by one bit position. The high order bits of each element are)]353 norm0
[(filled with the carry bits of the corresponding sum.)]342 norm2
[2(PAVGB)0( operates on packed unsigned bytes, and)]325 bull3
[2(PAVGW)0( operates on packed unsigned words.)]308 bull3
[{/section-B.4.206 xa}2(PAVGUSB)0(: Average of unsigned packed 8-bit values)](B.4.206)290 subh3
[2(PAVGUSB mm1,mm2/m64           ; 0F 0F /r BF          [PENT,3DNOW])]273 code3
[2(PAVGUSB)0( adds the unsigned data elements of the source operand to the unsigned data elements of)]256 norm1
[(the destination register, then adds 1 to the temporary results. The results of the add are then each)]245 norm0
[(independently right-shifted by one bit position. The high order bits of each element are filled with)]234 norm0
[(the carry bits of the corresponding sum.)]223 norm2
[(This instruction performs exactly the same operations as the )2(PAVGB)0( )2(MMX)0( instruction \(){/section-B.4.205 xl}(section){el}]206 norm1
[{/section-B.4.205 xl}(B.4.205){el}(\).)]195 norm2
[{/section-B.4.207 xa}2(PCMPxx)0(: Compare Packed Integers.)](B.4.207)177 subh3
[2(PCMPEQB mm1,mm2/m64           ; 0F 74 /r             [PENT,MMX] )]160 code1
[2(PCMPEQW mm1,mm2/m64           ; 0F 75 /r             [PENT,MMX] )]149 code0
[2(PCMPEQD mm1,mm2/m64           ; 0F 76 /r             [PENT,MMX])]138 code2
(166)pageeven
restore showpage
%%Page: 167 167
%%BeginPageSetup
save
%%EndPageSetup
/167 pa
[2(PCMPGTB mm1,mm2/m64           ; 0F 64 /r             [PENT,MMX] )]681 code1
[2(PCMPGTW mm1,mm2/m64           ; 0F 65 /r             [PENT,MMX] )]670 code0
[2(PCMPGTD mm1,mm2/m64           ; 0F 66 /r             [PENT,MMX])]659 code2
[2(PCMPEQB xmm1,xmm2/m128        ; 66 0F 74 /r     [WILLAMETTE,SSE2] )]642 code1
[2(PCMPEQW xmm1,xmm2/m128        ; 66 0F 75 /r     [WILLAMETTE,SSE2] )]631 code0
[2(PCMPEQD xmm1,xmm2/m128        ; 66 0F 76 /r     [WILLAMETTE,SSE2])]620 code2
[2(PCMPGTB xmm1,xmm2/m128        ; 66 0F 64 /r     [WILLAMETTE,SSE2] )]603 code1
[2(PCMPGTW xmm1,xmm2/m128        ; 66 0F 65 /r     [WILLAMETTE,SSE2] )]592 code0
[2(PCMPGTD xmm1,xmm2/m128        ; 66 0F 66 /r     [WILLAMETTE,SSE2])]581 code2
[(The )2(PCMPxx)0( instructions all treat their operands as vectors of bytes, words, or doublewords;)]564 norm1
[(corresponding elements of the source and destination are compared, and the corresponding element)]553 norm0
[(of the destination \(first\) operand is set to all zeros or all ones depending on the result of the)]542 norm0
[(comparison.)]531 norm2
[2(PCMPxxB)0( treats the operands as vectors of bytes;)]514 bull3
[2(PCMPxxW)0( treats the operands as vectors of words;)]497 bull3
[2(PCMPxxD)0( treats the operands as vectors of doublewords;)]480 bull3
[2(PCMPEQx)0( sets the corresponding element of the destination operand to all ones if the two)]463 bull1
[(elements compared are equal;)]452 bull2
[2(PCMPGTx)0( sets the destination element to all ones if the element of the first \(destination\) operand)]435 bull1
[(is greater \(treated as a signed integer\) than that of the second \(source\) operand.)]424 bull2
[{/section-B.4.208 xa}2(PDISTIB)0(: MMX Packed Distance and Accumulate with Implied Register)](B.4.208)406 subh3
[2(PDISTIB mm,m64                ; 0F 54 /r             [CYRIX,MMX])]389 code3
[2(PDISTIB)0(, specific to the Cyrix MMX extensions, treats its two input operands as vectors of eight)]372 norm1
[(unsigned bytes. For each byte position, it finds the absolute difference between the bytes in that)]361 norm0
[(position in the two input operands, and adds that value to the byte in the same position in the)]350 norm0
[(implied output register. The addition is saturated to an unsigned byte in the same way as )2(PADDUSB)0(.)]339 norm2
[(To work out the implied register, invert the lowest bit in the register number. So)]322 norm1
[2(PDISTIB MM0,M64)0( would put the result in )2(MM1)0(, but )2(PDISTIB MM1,M64)0( would put the result)]311 norm0
[(in )2(MM0)0(.)]300 norm2
[(Note that )2(PDISTIB)0( cannot take a register as its second source operand.)]283 norm3
[(Operation:)]266 norm3
[2(   dstI[0-7]     := dstI[0-7]   + ABS\(src0[0-7] - src1[0-7]\), )]249 code1
[2(   dstI[8-15]    := dstI[8-15]  + ABS\(src0[8-15] - src1[8-15]\), )]238 code0
[2(   ....... )]227 code0
[2(   ....... )]216 code0
[2(   dstI[56-63]   := dstI[56-63] + ABS\(src0[56-63] - src1[56-63]\).)]205 code2
[{/section-B.4.209 xa}2(PEXTRW)0(: Extract Word)](B.4.209)187 subh3
[2(PEXTRW reg32,mm,imm8          ; 0F C5 /r ib     [KATMAI,MMX] )]170 code1
[2(PEXTRW reg32,xmm,imm8         ; 66 0F C5 /r ib  [WILLAMETTE,SSE2])]159 code2
[2(PEXTRW)0( moves the word in the source register \(second operand\) that is pointed to by the count)]142 norm1
[(operand \(third operand\), into the lower half of a 32-bit general purpose register. The upper half of)]131 norm0
[(the register is cleared to all 0s.)]120 norm2
(167)pageodd
restore showpage
%%Page: 168 168
%%BeginPageSetup
save
%%EndPageSetup
/168 pa
[(When the source operand is an )2(MMX)0( register, the two least significant bits of the count specify the)]681 norm1
[(source word. When it is an )2(SSE)0( register, the three least significant bits specify the word location.)]670 norm2
[{/section-B.4.210 xa}2(PF2ID)0(: Packed Single-Precision FP to Integer Convert)](B.4.210)652 subh3
[2(PF2ID mm1,mm2/m64             ; 0F 0F /r 1D          [PENT,3DNOW])]635 code3
[2(PF2ID)0( converts two single-precision FP values in the source operand to signed 32-bit integers,)]618 norm1
[(using truncation, and stores them in the destination operand. Source values that are outside the)]607 norm0
[(range supported by the destination are saturated to the largest absolute value of the same sign.)]596 norm2
[{/section-B.4.211 xa}2(PF2IW)0(: Packed Single-Precision FP to Integer Word Convert)](B.4.211)578 subh3
[2(PF2IW mm1,mm2/m64             ; 0F 0F /r 1C          [PENT,3DNOW])]561 code3
[2(PF2IW)0( converts two single-precision FP values in the source operand to signed 16-bit integers,)]544 norm1
[(using truncation, and stores them in the destination operand. Source values that are outside the)]533 norm0
[(range supported by the destination are saturated to the largest absolute value of the same sign.)]522 norm2
[(In the K6-2 and K6-III, the 16-bit value is zero-extended to 32-bits before storing.)]505 bull3
[(In the K6-2+, K6-III+ and Athlon processors, the value is sign-extended to 32-bits before)]488 bull1
[(storing.)]477 bull2
[{/section-B.4.212 xa}2(PFACC)0(: Packed Single-Precision FP Accumulate)](B.4.212)459 subh3
[2(PFACC mm1,mm2/m64             ; 0F 0F /r AE          [PENT,3DNOW])]442 code3
[2(PFACC)0( adds the two single-precision FP values from the destination operand together, then adds)]425 norm1
[(the two single-precision FP values from the source operand, and places the results in the low and)]414 norm0
[(high doublewords of the destination operand.)]403 norm2
[(The operation is:)]386 norm3
[2(   dst[0-31]   := dst[0-31] + dst[32-63], )]369 code1
[2(   dst[32-63]  := src[0-31] + src[32-63].)]358 code2
[{/section-B.4.213 xa}2(PFADD)0(: Packed Single-Precision FP Addition)](B.4.213)340 subh3
[2(PFADD mm1,mm2/m64             ; 0F 0F /r 9E          [PENT,3DNOW])]323 code3
[2(PFADD)0( performs addition on each of two packed single-precision FP value pairs.)]306 norm3
[2(   dst[0-31]   := dst[0-31]  + src[0-31], )]289 code1
[2(   dst[32-63]  := dst[32-63] + src[32-63].)]278 code2
[{/section-B.4.214 xa}2(PFCMPxx)0(: Packed Single-Precision FP Compare )( )( )](B.4.214)260 subh3
[2(PFCMPEQ mm1,mm2/m64           ; 0F 0F /r B0          [PENT,3DNOW] )]243 code1
[2(PFCMPGE mm1,mm2/m64           ; 0F 0F /r 90          [PENT,3DNOW] )]232 code0
[2(PFCMPGT mm1,mm2/m64           ; 0F 0F /r A0          [PENT,3DNOW])]221 code2
[(The )2(PFCMPxx)0( instructions compare the packed single-point FP values in the source and)]204 norm1
[(destination operands, and set the destination according to the result. If the condition is true, the)]193 norm0
[(destination is set to all 1s, otherwise it's set to all 0s.)]182 norm2
[2(PFCMPEQ)0( tests whether dst == src;)]165 bull3
[2(PFCMPGE)0( tests whether dst >= src;)]148 bull3
[2(PFCMPGT)0( tests whether dst > src.)]131 bull3
(168)pageeven
restore showpage
%%Page: 169 169
%%BeginPageSetup
save
%%EndPageSetup
/169 pa
[{/section-B.4.215 xa}2(PFMAX)0(: Packed Single-Precision FP Maximum)](B.4.215)680 subh3
[2(PFMAX mm1,mm2/m64             ; 0F 0F /r A4          [PENT,3DNOW])]663 code3
[2(PFMAX)0( returns the higher of each pair of single-precision FP values. If the higher value is zero, it is)]646 norm1
[(returned as positive zero.)]635 norm2
[{/section-B.4.216 xa}2(PFMIN)0(: Packed Single-Precision FP Minimum)](B.4.216)617 subh3
[2(PFMIN mm1,mm2/m64             ; 0F 0F /r 94          [PENT,3DNOW])]600 code3
[2(PFMIN)0( returns the lower of each pair of single-precision FP values. If the lower value is zero, it is)]583 norm1
[(returned as positive zero.)]572 norm2
[{/section-B.4.217 xa}2(PFMUL)0(: Packed Single-Precision FP Multiply)](B.4.217)554 subh3
[2(PFMUL mm1,mm2/m64             ; 0F 0F /r B4          [PENT,3DNOW])]537 code3
[2(PFMUL)0( returns the product of each pair of single-precision FP values.)]520 norm3
[2(   dst[0-31]  := dst[0-31]  * src[0-31], )]503 code1
[2(   dst[32-63] := dst[32-63] * src[32-63].)]492 code2
[{/section-B.4.218 xa}2(PFNACC)0(: Packed Single-Precision FP Negative Accumulate)](B.4.218)474 subh3
[2(PFNACC mm1,mm2/m64            ; 0F 0F /r 8A          [PENT,3DNOW])]457 code3
[2(PFNACC)0( performs a negative accumulate of the two single-precision FP values in the source and)]440 norm1
[(destination registers. The result of the accumulate from the destination register is stored in the low)]429 norm0
[(doubleword of the destination, and the result of the source accumulate is stored in the high)]418 norm0
[(doubleword of the destination register.)]407 norm2
[(The operation is:)]390 norm3
[2(   dst[0-31]  := dst[0-31] - dst[32-63], )]373 code1
[2(   dst[32-63] := src[0-31] - src[32-63].)]362 code2
[{/section-B.4.219 xa}2(PFPNACC)0(: Packed Single-Precision FP Mixed Accumulate)](B.4.219)344 subh3
[2(PFPNACC mm1,mm2/m64           ; 0F 0F /r 8E          [PENT,3DNOW])]327 code3
[2(PFPNACC)0( performs a positive accumulate of the two single-precision FP values in the source)]310 norm1
[(register and a negative accumulate of the destination register. The result of the accumulate from the)]299 norm0
[(destination register is stored in the low doubleword of the destination, and the result of the source)]288 norm0
[(accumulate is stored in the high doubleword of the destination register.)]277 norm2
[(The operation is:)]260 norm3
[2(   dst[0-31]  := dst[0-31] - dst[32-63], )]243 code1
[2(   dst[32-63] := src[0-31] + src[32-63].)]232 code2
[{/section-B.4.220 xa}2(PFRCP)0(: Packed Single-Precision FP Reciprocal Approximation)](B.4.220)214 subh3
[2(PFRCP mm1,mm2/m64             ; 0F 0F /r 96          [PENT,3DNOW])]197 code3
[2(PFRCP)0( performs a low precision estimate of the reciprocal of the low-order single-precision FP)]180 norm1
[(value in the source operand, storing the result in both halves of the destination register. The result is)]169 norm0
[(accurate to 14 bits.)]158 norm2
[(For higher precision reciprocals, this instruction should be followed by two more instructions:)]141 norm1
[2(PFRCPIT1)0( \(){/section-B.4.221 xl}(section B.4.221){el}(\) and )2(PFRCPIT2)0( \(){/section-B.4.221 xl}(section B.4.221){el}(\). This will result in a 24-bit)]130 norm0
[(accuracy. For more details, see the AMD 3DNow! technology manual.)]119 norm2
(169)pageodd
restore showpage
%%Page: 170 170
%%BeginPageSetup
save
%%EndPageSetup
/170 pa
[{/section-B.4.221 xa}2(PFRCPIT1)0(: Packed Single-Precision FP Reciprocal, First Iteration Step)](B.4.221)680 subh3
[2(PFRCPIT1 mm1,mm2/m64          ; 0F 0F /r A6          [PENT,3DNOW])]663 code3
[2(PFRCPIT1)0( performs the first intermediate step in the calculation of the reciprocal of a)]646 norm1
[(single-precision FP value. The first source value \()2(mm1)0( is the original value, and the second source)]635 norm0
[(value \()2(mm2/m64)0( is the result of a )2(PFRCP)0( instruction.)]624 norm2
[(For the final step in a reciprocal, returning the full 24-bit accuracy of a single-precision FP value,)]607 norm1
[(see )2(PFRCPIT2)0( \(){/section-B.4.222 xl}(section B.4.222){el}(\). For more details, see the AMD 3DNow! technology manual.)]596 norm2
[{/section-B.4.222 xa}2(PFRCPIT2)0(: Packed Single-Precision FP Reciprocal/ Reciprocal Square Root, Second)](B.4.222)578 subh1
[(Iteration Step)]566 subh2
[2(PFRCPIT2 mm1,mm2/m64          ; 0F 0F /r B6          [PENT,3DNOW])]549 code3
[2(PFRCPIT2)0( performs the second and final intermediate step in the calculation of a reciprocal or)]532 norm1
[(reciprocal square root, refining the values returned by the )2(PFRCP)0( and )2(PFRSQRT)0( instructions,)]521 norm0
[(respectively.)]510 norm2
[(The first source value \()2(mm1)0(\) is the output of either a )2(PFRCPIT1)0( or a )2(PFRSQIT1)0( instruction, and)]493 norm1
[(the second source is the output of either the )2(PFRCP)0( or the )2(PFRSQRT)0( instruction. For more details,)]482 norm0
[(see the AMD 3DNow! technology manual.)]471 norm2
[{/section-B.4.223 xa}2(PFRSQIT1)0(: Packed Single-Precision FP Reciprocal Square Root, First Iteration Step)](B.4.223)453 subh3
[2(PFRSQIT1 mm1,mm2/m64          ; 0F 0F /r A7          [PENT,3DNOW])]436 code3
[2(PFRSQIT1)0( performs the first intermediate step in the calculation of the reciprocal square root of a)]419 norm1
[(single-precision FP value. The first source value \()2(mm1)0( is the square of the result of a )2(PFRSQRT)]408 norm0
[(instruction, and the second source value \()2(mm2/m64)0( is the original value.)]397 norm2
[(For the final step in a calculation, returning the full 24-bit accuracy of a single-precision FP value,)]380 norm1
[(see )2(PFRCPIT2)0( \(){/section-B.4.222 xl}(section B.4.222){el}(\). For more details, see the AMD 3DNow! technology manual.)]369 norm2
[{/section-B.4.224 xa}2(PFRSQRT)0(: Packed Single-Precision FP Reciprocal Square Root Approximation)](B.4.224)351 subh3
[2(PFRSQRT mm1,mm2/m64           ; 0F 0F /r 97          [PENT,3DNOW])]334 code3
[2(PFRSQRT)0( performs a low precision estimate of the reciprocal square root of the low-order)]317 norm1
[(single-precision FP value in the source operand, storing the result in both halves of the destination)]306 norm0
[(register. The result is accurate to 15 bits.)]295 norm2
[(For higher precision reciprocals, this instruction should be followed by two more instructions:)]278 norm1
[2(PFRSQIT1)0( \(){/section-B.4.223 xl}(section B.4.223){el}(\) and )2(PFRCPIT2)0( \(){/section-B.4.221 xl}(section B.4.221){el}(\). This will result in a 24-bit)]267 norm0
[(accuracy. For more details, see the AMD 3DNow! technology manual.)]256 norm2
[{/section-B.4.225 xa}2(PFSUB)0(: Packed Single-Precision FP Subtract)](B.4.225)238 subh3
[2(PFSUB mm1,mm2/m64             ; 0F 0F /r 9A          [PENT,3DNOW])]221 code3
[2(PFSUB)0( subtracts the single-precision FP values in the source from those in the destination, and)]204 norm1
[(stores the result in the destination operand.)]193 norm2
[2(   dst[0-31]  := dst[0-31]  - src[0-31], )]176 code1
[2(   dst[32-63] := dst[32-63] - src[32-63].)]165 code2
[{/section-B.4.226 xa}2(PFSUBR)0(: Packed Single-Precision FP Reverse Subtract)](B.4.226)147 subh3
[2(PFSUBR mm1,mm2/m64            ; 0F 0F /r AA          [PENT,3DNOW])]130 code3
[2(PFSUBR)0( subtracts the single-precision FP values in the destination from those in the source, and)]113 norm1
[(stores the result in the destination operand.)]102 norm2
(170)pageeven
restore showpage
%%Page: 171 171
%%BeginPageSetup
save
%%EndPageSetup
/171 pa
[2(   dst[0-31]  := src[0-31]  - dst[0-31], )]681 code1
[2(   dst[32-63] := src[32-63] - dst[32-63].)]670 code2
[{/section-B.4.227 xa}2(PI2FD)0(: Packed Doubleword Integer to Single-Precision FP Convert)](B.4.227)652 subh3
[2(PI2FD mm1,mm2/m64             ; 0F 0F /r 0D          [PENT,3DNOW])]635 code3
[2(PF2ID)0( converts two signed 32-bit integers in the source operand to single-precision FP values,)]618 norm1
[(using truncation of significant digits, and stores them in the destination operand.)]607 norm2
[{/section-B.4.228 xa}2(PF2IW)0(: Packed Word Integer to Single-Precision FP Convert)](B.4.228)589 subh3
[2(PI2FW mm1,mm2/m64             ; 0F 0F /r 0C          [PENT,3DNOW])]572 code3
[2(PF2IW)0( converts two signed 16-bit integers in the source operand to single-precision FP values,)]555 norm1
[(and stores them in the destination operand. The input values are in the low word of each)]544 norm0
[(doubleword.)]533 norm2
[{/section-B.4.229 xa}2(PINSRW)0(: Insert Word)](B.4.229)515 subh3
[2(PINSRW mm,r16/r32/m16,imm8    ;0F C4 /r ib      [KATMAI,MMX] )]498 code1
[2(PINSRW xmm,r16/r32/m16,imm8   ;66 0F C4 /r ib   [WILLAMETTE,SSE2])]487 code2
[2(PINSRW)0( loads a word from a 16-bit register \(or the low half of a 32-bit register\), or from memory,)]470 norm1
[(and loads it to the word position in the destination register, pointed at by the count operand \(third)]459 norm0
[(operand\). If the destination is an )2(MMX)0( register, the low two bits of the count byte are used, if it is an)]448 norm0
[2(XMM)0( register the low 3 bits are used. The insertion is done in such a way that the other words from)]437 norm0
[(the destination register are left untouched.)]426 norm2
[{/section-B.4.230 xa}2(PMACHRIW)0(: Packed Multiply and Accumulate with Rounding)](B.4.230)408 subh3
[2(PMACHRIW mm,m64               ; 0F 5E /r             [CYRIX,MMX])]391 code3
[2(PMACHRIW)0( takes two packed 16-bit integer inputs, multiplies the values in the inputs, rounds on)]374 norm1
[(bit 15 of each result, then adds bits 15-30 of each result to the corresponding position of the )1(implied)]363 norm0
[(destination register.)]352 norm2
[(The operation of this instruction is:)]335 norm3
[2(   dstI[0-15]  := dstI[0-15]  + \(mm[0-15] *m64[0-15] )]318 code1
[2(                                          + 0x00004000\)[15-30], )]307 code0
[2(   dstI[16-31] := dstI[16-31] + \(mm[16-31]*m64[16-31] )]296 code0
[2(                                          + 0x00004000\)[15-30], )]285 code0
[2(   dstI[32-47] := dstI[32-47] + \(mm[32-47]*m64[32-47] )]274 code0
[2(                                          + 0x00004000\)[15-30], )]263 code0
[2(   dstI[48-63] := dstI[48-63] + \(mm[48-63]*m64[48-63] )]252 code0
[2(                                          + 0x00004000\)[15-30].)]241 code2
[(Note that )2(PMACHRIW)0( cannot take a register as its second source operand.)]224 norm3
[{/section-B.4.231 xa}2(PMADDWD)0(: MMX Packed Multiply and Add)](B.4.231)206 subh3
[2(PMADDWD mm1,mm2/m64           ; 0F F5 /r             [PENT,MMX] )]189 code1
[2(PMADDWD xmm1,xmm2/m128        ; 66 0F F5 /r     [WILLAMETTE,SSE2])]178 code2
[2(PMADDWD)0( treats its two inputs as vectors of signed words. It multiplies corresponding elements of)]161 norm1
[(the two operands, giving doubleword results. These are then added together in pairs and stored in)]150 norm0
[(the destination operand.)]139 norm2
[(The operation of this instruction is:)]122 norm3
(171)pageodd
restore showpage
%%Page: 172 172
%%BeginPageSetup
save
%%EndPageSetup
/172 pa
[2(   dst[0-31]   := \(dst[0-15] * src[0-15]\) )]681 code1
[2(                               + \(dst[16-31] * src[16-31]\); )]670 code0
[2(   dst[32-63]  := \(dst[32-47] * src[32-47]\) )]659 code0
[2(                               + \(dst[48-63] * src[48-63]\);)]648 code2
[(The following apply to the )2(SSE)0( version of the instruction:)]631 norm3
[2(   dst[64-95]  := \(dst[64-79] * src[64-79]\) )]614 code1
[2(                               + \(dst[80-95] * src[80-95]\); )]603 code0
[2(   dst[96-127] := \(dst[96-111] * src[96-111]\) )]592 code0
[2(                               + \(dst[112-127] * src[112-127]\).)]581 code2
[{/section-B.4.232 xa}2(PMAGW)0(: MMX Packed Magnitude)](B.4.232)563 subh3
[2(PMAGW mm1,mm2/m64             ; 0F 52 /r             [CYRIX,MMX])]546 code3
[2(PMAGW)0(, specific to the Cyrix MMX extensions, treats both its operands as vectors of four signed)]529 norm1
[(words. It compares the absolute values of the words in corresponding positions, and sets each word)]518 norm0
[(of the destination \(first\) operand to whichever of the two words in that position had the larger)]507 norm0
[(absolute value.)]496 norm2
[{/section-B.4.233 xa}2(PMAXSW)0(: Packed Signed Integer Word Maximum)](B.4.233)478 subh3
[2(PMAXSW mm1,mm2/m64            ; 0F EE /r        [KATMAI,MMX] )]461 code1
[2(PMAXSW xmm1,xmm2/m128         ; 66 0F EE /r     [WILLAMETTE,SSE2])]450 code2
[2(PMAXSW)0( compares each pair of words in the two source operands, and for each pair it stores the)]433 norm1
[(maximum value in the destination register.)]422 norm2
[{/section-B.4.234 xa}2(PMAXUB)0(: Packed Unsigned Integer Byte Maximum)](B.4.234)404 subh3
[2(PMAXUB mm1,mm2/m64            ; 0F DE /r        [KATMAI,MMX] )]387 code1
[2(PMAXUB xmm1,xmm2/m128         ; 66 0F DE /r     [WILLAMETTE,SSE2])]376 code2
[2(PMAXUB)0( compares each pair of bytes in the two source operands, and for each pair it stores the)]359 norm1
[(maximum value in the destination register.)]348 norm2
[{/section-B.4.235 xa}2(PMINSW)0(: Packed Signed Integer Word Minimum)](B.4.235)330 subh3
[2(PMINSW mm1,mm2/m64            ; 0F EA /r        [KATMAI,MMX] )]313 code1
[2(PMINSW xmm1,xmm2/m128         ; 66 0F EA /r     [WILLAMETTE,SSE2])]302 code2
[2(PMINSW)0( compares each pair of words in the two source operands, and for each pair it stores the)]285 norm1
[(minimum value in the destination register.)]274 norm2
[{/section-B.4.236 xa}2(PMINUB)0(: Packed Unsigned Integer Byte Minimum)](B.4.236)256 subh3
[2(PMINUB mm1,mm2/m64            ; 0F DA /r        [KATMAI,MMX] )]239 code1
[2(PMINUB xmm1,xmm2/m128         ; 66 0F DA /r     [WILLAMETTE,SSE2])]228 code2
[2(PMINUB)0( compares each pair of bytes in the two source operands, and for each pair it stores the)]211 norm1
[(minimum value in the destination register.)]200 norm2
[{/section-B.4.237 xa}2(PMOVMSKB)0(: Move Byte Mask To Integer)](B.4.237)182 subh3
[2(PMOVMSKB reg32,mm             ; 0F D7 /r        [KATMAI,MMX] )]165 code1
[2(PMOVMSKB reg32,xmm            ; 66 0F D7 /r     [WILLAMETTE,SSE2])]154 code2
[2(PMOVMSKB)0( returns an 8-bit or 16-bit mask formed of the most significant bits of each byte of)]137 norm1
[(source operand \(8-bits for an )2(MMX)0( register, 16-bits for an )2(XMM)0( register\).)]126 norm2
(172)pageeven
restore showpage
%%Page: 173 173
%%BeginPageSetup
save
%%EndPageSetup
/173 pa
[{/section-B.4.238 xa}2(PMULHRWC)0(, )2(PMULHRIW)0(: Multiply Packed 16-bit Integers With Rounding, and Store)](B.4.238)680 subh1
[(High Word)]668 subh2
[2(PMULHRWC mm1,mm2/m64         ; 0F 59 /r              [CYRIX,MMX] )]651 code1
[2(PMULHRIW mm1,mm2/m64         ; 0F 5D /r              [CYRIX,MMX])]640 code2
[(These instructions take two packed 16-bit integer inputs, multiply the values in the inputs, round on)]623 norm1
[(bit 15 of each result, then store bits 15-30 of each result to the corresponding position of the)]612 norm0
[(destination register.)]601 norm2
[(For )2(PMULHRWC)0(, the destination is the first source operand.)]584 bull3
[(For )2(PMULHRIW)0(, the destination is an implied register \(worked out as described for )2(PADDSIW)]567 bull1
[(\(){/section-B.4.200 xl}(section B.4.200){el}(\)\).)]556 bull2
[(The operation of this instruction is:)]539 norm3
[2(   dst[0-15]  := \(src1[0-15] *src2[0-15]  + 0x00004000\)[15-30] )]522 code1
[2(   dst[16-31] := \(src1[16-31]*src2[16-31] + 0x00004000\)[15-30] )]511 code0
[2(   dst[32-47] := \(src1[32-47]*src2[32-47] + 0x00004000\)[15-30] )]500 code0
[2(   dst[48-63] := \(src1[48-63]*src2[48-63] + 0x00004000\)[15-30])]489 code2
[(See also )2(PMULHRWA)0( \(){/section-B.4.239 xl}(section B.4.239){el}(\) for a 3DNow! version of this instruction.)]472 norm3
[{/section-B.4.239 xa}2(PMULHRWA)0(: Multiply Packed 16-bit Integers With Rounding, and Store High Word)](B.4.239)454 subh3
[2(PMULHRWA mm1,mm2/m64          ; 0F 0F /r B7     [PENT,3DNOW])]437 code3
[2(PMULHRWA)0( takes two packed 16-bit integer inputs, multiplies the values in the inputs, rounds on)]420 norm1
[(bit 16 of each result, then stores bits 16-31 of each result to the corresponding position of the)]409 norm0
[(destination register.)]398 norm2
[(The operation of this instruction is:)]381 norm3
[2(   dst[0-15]  := \(src1[0-15] *src2[0-15]  + 0x00008000\)[16-31]; )]364 code1
[2(   dst[16-31] := \(src1[16-31]*src2[16-31] + 0x00008000\)[16-31]; )]353 code0
[2(   dst[32-47] := \(src1[32-47]*src2[32-47] + 0x00008000\)[16-31]; )]342 code0
[2(   dst[48-63] := \(src1[48-63]*src2[48-63] + 0x00008000\)[16-31].)]331 code2
[(See also )2(PMULHRWC)0( \(){/section-B.4.238 xl}(section B.4.238){el}(\) for a Cyrix version of this instruction.)]314 norm3
[{/section-B.4.240 xa}2(PMULHUW)0(: Multiply Packed 16-bit Integers, and Store High Word)](B.4.240)296 subh3
[2(PMULHUW mm1,mm2/m64           ; 0F E4 /r        [KATMAI,MMX] )]279 code1
[2(PMULHUW xmm1,xmm2/m128        ; 66 0F E4 /r     [WILLAMETTE,SSE2])]268 code2
[2(PMULHUW)0( takes two packed unsigned 16-bit integer inputs, multiplies the values in the inputs, then)]251 norm1
[(stores bits 16-31 of each result to the corresponding position of the destination register.)]240 norm2
[{/section-B.4.241 xa}2(PMULHW)0(, )2(PMULLW)0(: Multiply Packed 16-bit Integers, and Store)](B.4.241)222 subh3
[2(PMULHW mm1,mm2/m64            ; 0F E5 /r             [PENT,MMX] )]205 code1
[2(PMULLW mm1,mm2/m64            ; 0F D5 /r             [PENT,MMX])]194 code2
[2(PMULHW xmm1,xmm2/m128         ; 66 0F E5 /r     [WILLAMETTE,SSE2] )]177 code1
[2(PMULLW xmm1,xmm2/m128         ; 66 0F D5 /r     [WILLAMETTE,SSE2])]166 code2
[2(PMULxW)0( takes two packed unsigned 16-bit integer inputs, and multiplies the values in the inputs,)]149 norm1
[(forming doubleword results.)]138 norm2
[2(PMULHW)0( then stores the top 16 bits of each doubleword in the destination \(first\) operand;)]121 bull3
[2(PMULLW)0( stores the bottom 16 bits of each doubleword in the destination operand.)]104 bull3
(173)pageodd
restore showpage
%%Page: 174 174
%%BeginPageSetup
save
%%EndPageSetup
/174 pa
[{/section-B.4.242 xa}2(PMULUDQ)0(: Multiply Packed Unsigned 32-bit Integers, and Store.)](B.4.242)680 subh3
[2(PMULUDQ mm1,mm2/m64           ; 0F F4 /r        [WILLAMETTE,SSE2] )]663 code1
[2(PMULUDQ xmm1,xmm2/m128        ; 66 0F F4 /r     [WILLAMETTE,SSE2])]652 code2
[2(PMULUDQ)0( takes two packed unsigned 32-bit integer inputs, and multiplies the values in the inputs,)]635 norm1
[(forming quadword results. The source is either an unsigned doubleword in the low doubleword of a)]624 norm0
[(64-bit operand, or it's two unsigned doublewords in the first and third doublewords of a 128-bit)]613 norm0
[(operand. This produces either one or two 64-bit results, which are stored in the respective)]602 norm0
[(quadword locations of the destination register.)]591 norm2
[(The operation is:)]574 norm3
[2(   dst[0-63]   := dst[0-31]  * src[0-31]; )]557 code1
[2(   dst[64-127] := dst[64-95] * src[64-95].)]546 code2
[{/section-B.4.243 xa}2(PMVccZB)0(: MMX Packed Conditional Move)](B.4.243)528 subh3
[2(PMVZB mmxreg,mem64            ; 0F 58 /r             [CYRIX,MMX] )]511 code1
[2(PMVNZB mmxreg,mem64           ; 0F 5A /r             [CYRIX,MMX] )]500 code0
[2(PMVLZB mmxreg,mem64           ; 0F 5B /r             [CYRIX,MMX] )]489 code0
[2(PMVGEZB mmxreg,mem64          ; 0F 5C /r             [CYRIX,MMX])]478 code2
[(These instructions, specific to the Cyrix MMX extensions, perform parallel conditional moves. The)]461 norm1
[(two input operands are treated as vectors of eight bytes. Each byte of the destination \(first\) operand)]450 norm0
[(is either written from the corresponding byte of the source \(second\) operand, or left alone,)]439 norm0
[(depending on the value of the byte in the )1(implied)0( operand \(specified in the same way as )2(PADDSIW)0(,)]428 norm0
[(in ){/section-B.4.200 xl}(section B.4.200){el}(\).)]417 norm2
[2(PMVZB)0( performs each move if the corresponding byte in the implied operand is zero;)]400 bull3
[2(PMVNZB)0( moves if the byte is non-zero;)]383 bull3
[2(PMVLZB)0( moves if the byte is less than zero;)]366 bull3
[2(PMVGEZB)0( moves if the byte is greater than or equal to zero.)]349 bull3
[(Note that these instructions cannot take a register as their second source operand.)]332 norm3
[{/section-B.4.244 xa}2(POP)0(: Pop Data from Stack)](B.4.244)314 subh3
[2(POP reg16                     ; o16 58+r             [8086] )]297 code1
[2(POP reg32                     ; o32 58+r             [386])]286 code2
[2(POP r/m16                     ; o16 8F /0            [8086] )]269 code1
[2(POP r/m32                     ; o32 8F /0            [386])]258 code2
[2(POP CS                        ; 0F                   [8086,UNDOC] )]241 code1
[2(POP DS                        ; 1F                   [8086] )]230 code0
[2(POP ES                        ; 07                   [8086] )]219 code0
[2(POP SS                        ; 17                   [8086] )]208 code0
[2(POP FS                        ; 0F A1                [386] )]197 code0
[2(POP GS                        ; 0F A9                [386])]186 code2
[2(POP)0( loads a value from the stack \(from )2([SS:SP])0( or )2([SS:ESP])0(\) and then increments the stack)]169 norm1
[(pointer.)]158 norm2
[(The address-size attribute of the instruction determines whether )2(SP)0( or )2(ESP)0( is used as the stack)]141 norm1
[(pointer: to deliberately override the default given by the )2(BITS)0( setting, you can use an )2(a16)0( or )2(a32)]130 norm0
[(prefix.)]119 norm2
(174)pageeven
restore showpage
%%Page: 175 175
%%BeginPageSetup
save
%%EndPageSetup
/175 pa
[(The operand-size attribute of the instruction determines whether the stack pointer is incremented by)]681 norm1
[(2 or 4: this means that segment register pops in )2(BITS 32)0( mode will pop 4 bytes off the stack and)]670 norm0
[(discard the upper two of them. If you need to override that, you can use an )2(o16)0( or )2(o32)0( prefix.)]659 norm2
[(The above opcode listings give two forms for general-purpose register pop instructions: for)]642 norm1
[(example, )2(POP BX)0( has the two forms )2(5B)0( and )2(8F C3)0(. NASM will always generate the shorter form)]631 norm0
[(when given )2(POP BX)0(. NDISASM will disassemble both.)]620 norm2
[2(POP CS)0( is not a documented instruction, and is not supported on any processor above the 8086)]603 norm1
[(\(since they use )2(0Fh)0( as an opcode prefix for instruction set extensions\). However, at least some)]592 norm0
[(8086 processors do support it, and so NASM generates it for completeness.)]581 norm2
[{/section-B.4.245 xa}2(POPAx)0(: Pop All General-Purpose Registers)](B.4.245)563 subh3
[2(POPA                          ; 61                   [186] )]546 code1
[2(POPAW                         ; o16 61               [186] )]535 code0
[2(POPAD                         ; o32 61               [386])]524 code2
[2(POPAW)0( pops a word from the stack into each of, successively, )2(DI)0(, )2(SI)0(, )2(BP)0(, nothing \(it discards a)]507 bull1
[(word from the stack which was a placeholder for )2(SP)0(\), )2(BX)0(, )2(DX)0(, )2(CX)0( and )2(AX)0(. It is intended to)]496 bull0
[(reverse the operation of )2(PUSHAW)0( \(see ){/section-B.4.264 xl}(section B.4.264){el}(\), but it ignores the value for )2(SP)0( that was)]485 bull0
[(pushed on the stack by )2(PUSHAW)0(.)]474 bull2
[2(POPAD)0( pops twice as much data, and places the results in )2(EDI)0(, )2(ESI)0(, )2(EBP)0(, nothing \(placeholder)]457 bull1
[(for )2(ESP)0(\), )2(EBX)0(, )2(EDX)0(, )2(ECX)0( and )2(EAX)0(. It reverses the operation of )2(PUSHAD)0(.)]446 bull2
[2(POPA)0( is an alias mnemonic for either )2(POPAW)0( or )2(POPAD)0(, depending on the current )2(BITS)0( setting.)]429 norm3
[(Note that the registers are popped in reverse order of their numeric values in opcodes \(see ){/section-B.2.1 xl}(section){el}]412 norm1
[{/section-B.2.1 xl}(B.2.1){el}(\).)]401 norm2
[{/section-B.4.246 xa}2(POPFx)0(: Pop Flags Register)](B.4.246)383 subh3
[2(POPF                          ; 9D                   [8086] )]366 code1
[2(POPFW                         ; o16 9D               [8086] )]355 code0
[2(POPFD                         ; o32 9D               [386])]344 code2
[2(POPFW)0( pops a word from the stack and stores it in the bottom 16 bits of the flags register \(or the)]327 bull1
[(whole flags register, on processors below a 386\).)]316 bull2
[2(POPFD)0( pops a doubleword and stores it in the entire flags register.)]299 bull3
[2(POPF)0( is an alias mnemonic for either )2(POPFW)0( or )2(POPFD)0(, depending on the current )2(BITS)0( setting.)]282 norm3
[(See also )2(PUSHF)0( \(){/section-B.4.265 xl}(section B.4.265){el}(\).)]265 norm3
[{/section-B.4.247 xa}2(POR)0(: MMX Bitwise OR)](B.4.247)247 subh3
[2(POR mm1,mm2/m64               ; 0F EB /r             [PENT,MMX] )]230 code1
[2(POR xmm1,xmm2/m128            ; 66 0F EB /r     [WILLAMETTE,SSE2])]219 code2
[2(POR)0( performs a bitwise OR operation between its two operands \(i.e. each bit of the result is 1 if and)]202 norm1
[(only if at least one of the corresponding bits of the two inputs was 1\), and stores the result in the)]191 norm0
[(destination \(first\) operand.)]180 norm2
[{/section-B.4.248 xa}2(PREFETCH)0(: Prefetch Data Into Caches)](B.4.248)162 subh3
[2(PREFETCH mem8                 ; 0F 0D /0             [PENT,3DNOW] )]145 code1
[2(PREFETCHW mem8                ; 0F 0D /1             [PENT,3DNOW])]134 code2
[2(PREFETCH)0( and )2(PREFETCHW)0( fetch the line of data from memory that contains the specified byte.)]117 norm1
[2(PREFETCHW)0( performs differently on the Athlon to earlier processors.)]106 norm2
(175)pageodd
restore showpage
%%Page: 176 176
%%BeginPageSetup
save
%%EndPageSetup
/176 pa
[(For more details, see the 3DNow! Technology Manual.)]681 norm3
[{/section-B.4.249 xa}2(PREFETCHh)0(: Prefetch Data Into Caches )( )( )( )](B.4.249)663 subh3
[2(PREFETCHNTA m8                ; 0F 18 /0        [KATMAI] )]646 code1
[2(PREFETCHT0 m8                 ; 0F 18 /1        [KATMAI] )]635 code0
[2(PREFETCHT1 m8                 ; 0F 18 /2        [KATMAI] )]624 code0
[2(PREFETCHT2 m8                 ; 0F 18 /3        [KATMAI])]613 code2
[(The )2(PREFETCHh)0( instructions fetch the line of data from memory that contains the specified byte. It)]596 norm1
[(is placed in the cache according to rules specified by locality hints )2(h)0(:)]585 norm2
[(The hints are:)]568 norm3
[2(T0)0( \(temporal data\) \226 prefetch data into all levels of the cache hierarchy.)]551 bull3
[2(T1)0( \(temporal data with respect to first level cache\) \226 prefetch data into level 2 cache and higher.)]534 bull3
[2(T2)0( \(temporal data with respect to second level cache\) \226 prefetch data into level 2 cache and)]517 bull1
[(higher.)]506 bull2
[2(NTA)0( \(non-temporal data with respect to all cache levels\) \226 prefetch data into non-temporal)]489 bull1
[(cache structure and into a location close to the processor, minimizing cache pollution.)]478 bull2
[(Note that this group of instructions doesn't provide a guarantee that the data will be in the cache)]461 norm1
[(when it is needed. For more details, see the Intel IA32 Software Developer Manual, Volume 2.)]450 norm2
[{/section-B.4.250 xa}2(PSADBW)0(: Packed Sum of Absolute Differences)](B.4.250)432 subh3
[2(PSADBW mm1,mm2/m64            ; 0F F6 /r        [KATMAI,MMX] )]415 code1
[2(PSADBW xmm1,xmm2/m128         ; 66 0F F6 /r     [WILLAMETTE,SSE2])]404 code2
[2(PSADBW)0( The PSADBW instruction computes the absolute value of the difference of the packed)]387 norm1
[(unsigned bytes in the two source operands. These differences are then summed to produce a word)]376 norm0
[(result in the lower 16-bit field of the destination register; the rest of the register is cleared. The)]365 norm0
[(destination operand is an )2(MMX)0( or an )2(XMM)0( register. The source operand can either be a register or a)]354 norm0
[(memory operand.)]343 norm2
[{/section-B.4.251 xa}2(PSHUFD)0(: Shuffle Packed Doublewords)](B.4.251)325 subh3
[2(PSHUFD xmm1,xmm2/m128,imm8    ; 66 0F 70 /r ib  [WILLAMETTE,SSE2])]308 code3
[2(PSHUFD)0( shuffles the doublewords in the source \(second\) operand according to the encoding)]291 norm1
[(specified by imm8, and stores the result in the destination \(first\) operand.)]280 norm2
[(Bits 0 and 1 of imm8 encode the source position of the doubleword to be copied to position 0 in the)]263 norm1
[(destination operand. Bits 2 and 3 encode for position 1, bits 4 and 5 encode for position 2, and bits 6)]252 norm0
[(and 7 encode for position 3. For example, an encoding of 10 in bits 0 and 1 of imm8 indicates that)]241 norm0
[(the doubleword at bits 64-95 of the source operand will be copied to bits 0-31 of the destination.)]230 norm2
[{/section-B.4.252 xa}2(PSHUFHW)0(: Shuffle Packed High Words)](B.4.252)212 subh3
[2(PSHUFHW xmm1,xmm2/m128,imm8   ; F3 0F 70 /r ib  [WILLAMETTE,SSE2])]195 code3
[2(PSHUFW)0( shuffles the words in the high quadword of the source \(second\) operand according to the)]178 norm1
[(encoding specified by imm8, and stores the result in the high quadword of the destination \(first\))]167 norm0
[(operand.)]156 norm2
[(The operation of this instruction is similar to the )2(PSHUFW)0( instruction, except that the source and)]139 norm1
[(destination are the top quadword of a 128-bit operand, instead of being 64-bit operands. The low)]128 norm0
[(quadword is copied from the source to the destination without any changes.)]117 norm2
(176)pageeven
restore showpage
%%Page: 177 177
%%BeginPageSetup
save
%%EndPageSetup
/177 pa
[{/section-B.4.253 xa}2(PSHUFLW)0(: Shuffle Packed Low Words)](B.4.253)680 subh3
[2(PSHUFLW xmm1,xmm2/m128,imm8   ; F2 0F 70 /r ib  [WILLAMETTE,SSE2])]663 code3
[2(PSHUFLW)0( shuffles the words in the low quadword of the source \(second\) operand according to the)]646 norm1
[(encoding specified by imm8, and stores the result in the low quadword of the destination \(first\))]635 norm0
[(operand.)]624 norm2
[(The operation of this instruction is similar to the )2(PSHUFW)0( instruction, except that the source and)]607 norm1
[(destination are the low quadword of a 128-bit operand, instead of being 64-bit operands. The high)]596 norm0
[(quadword is copied from the source to the destination without any changes.)]585 norm2
[{/section-B.4.254 xa}2(PSHUFW)0(: Shuffle Packed Words)](B.4.254)567 subh3
[2(PSHUFW mm1,mm2/m64,imm8       ; 0F 70 /r ib     [KATMAI,MMX])]550 code3
[2(PSHUFW)0( shuffles the words in the source \(second\) operand according to the encoding specified by)]533 norm1
[(imm8, and stores the result in the destination \(first\) operand.)]522 norm2
[(Bits 0 and 1 of imm8 encode the source position of the word to be copied to position 0 in the)]505 norm1
[(destination operand. Bits 2 and 3 encode for position 1, bits 4 and 5 encode for position 2, and bits 6)]494 norm0
[(and 7 encode for position 3. For example, an encoding of 10 in bits 0 and 1 of imm8 indicates that)]483 norm0
[(the word at bits 32-47 of the source operand will be copied to bits 0-15 of the destination.)]472 norm2
[{/section-B.4.255 xa}2(PSLLx)0(: Packed Data Bit Shift Left Logical)](B.4.255)454 subh3
[2(PSLLW mm1,mm2/m64             ; 0F F1 /r             [PENT,MMX] )]437 code1
[2(PSLLW mm,imm8                 ; 0F 71 /6 ib          [PENT,MMX])]426 code2
[2(PSLLW xmm1,xmm2/m128          ; 66 0F F1 /r     [WILLAMETTE,SSE2] )]409 code1
[2(PSLLW xmm,imm8                ; 66 0F 71 /6 ib  [WILLAMETTE,SSE2])]398 code2
[2(PSLLD mm1,mm2/m64             ; 0F F2 /r             [PENT,MMX] )]381 code1
[2(PSLLD mm,imm8                 ; 0F 72 /6 ib          [PENT,MMX])]370 code2
[2(PSLLD xmm1,xmm2/m128          ; 66 0F F2 /r     [WILLAMETTE,SSE2] )]353 code1
[2(PSLLD xmm,imm8                ; 66 0F 72 /6 ib  [WILLAMETTE,SSE2])]342 code2
[2(PSLLQ mm1,mm2/m64             ; 0F F3 /r             [PENT,MMX] )]325 code1
[2(PSLLQ mm,imm8                 ; 0F 73 /6 ib          [PENT,MMX])]314 code2
[2(PSLLQ xmm1,xmm2/m128          ; 66 0F F3 /r     [WILLAMETTE,SSE2] )]297 code1
[2(PSLLQ xmm,imm8                ; 66 0F 73 /6 ib  [WILLAMETTE,SSE2])]286 code2
[2(PSLLDQ xmm1,imm8              ; 66 0F 73 /7 ib  [WILLAMETTE,SSE2])]269 code3
[2(PSLLx)0( performs logical left shifts of the data elements in the destination \(first\) operand, moving)]252 norm1
[(each bit in the separate elements left by the number of bits specified in the source \(second\) operand,)]241 norm0
[(clearing the low-order bits as they are vacated. )2(PSLLDQ)0( shifts bytes, not bits.)]230 norm2
[2(PSLLW)0( shifts word sized elements.)]213 bull3
[2(PSLLD)0( shifts doubleword sized elements.)]196 bull3
[2(PSLLQ)0( shifts quadword sized elements.)]179 bull3
[2(PSLLDQ)0( shifts double quadword sized elements.)]162 bull3
[{/section-B.4.256 xa}2(PSRAx)0(: Packed Data Bit Shift Right Arithmetic)](B.4.256)144 subh3
[2(PSRAW mm1,mm2/m64             ; 0F E1 /r             [PENT,MMX] )]127 code1
[2(PSRAW mm,imm8                 ; 0F 71 /4 ib          [PENT,MMX])]116 code2
(177)pageodd
restore showpage
%%Page: 178 178
%%BeginPageSetup
save
%%EndPageSetup
/178 pa
[2(PSRAW xmm1,xmm2/m128          ; 66 0F E1 /r     [WILLAMETTE,SSE2] )]681 code1
[2(PSRAW xmm,imm8                ; 66 0F 71 /4 ib  [WILLAMETTE,SSE2])]670 code2
[2(PSRAD mm1,mm2/m64             ; 0F E2 /r             [PENT,MMX] )]653 code1
[2(PSRAD mm,imm8                 ; 0F 72 /4 ib          [PENT,MMX])]642 code2
[2(PSRAD xmm1,xmm2/m128          ; 66 0F E2 /r     [WILLAMETTE,SSE2] )]625 code1
[2(PSRAD xmm,imm8                ; 66 0F 72 /4 ib  [WILLAMETTE,SSE2])]614 code2
[2(PSRAx)0( performs arithmetic right shifts of the data elements in the destination \(first\) operand,)]597 norm1
[(moving each bit in the separate elements right by the number of bits specified in the source \(second\))]586 norm0
[(operand, setting the high-order bits to the value of the original sign bit.)]575 norm2
[2(PSRAW)0( shifts word sized elements.)]558 bull3
[2(PSRAD)0( shifts doubleword sized elements.)]541 bull3
[{/section-B.4.257 xa}2(PSRLx)0(: Packed Data Bit Shift Right Logical)](B.4.257)523 subh3
[2(PSRLW mm1,mm2/m64             ; 0F D1 /r             [PENT,MMX] )]506 code1
[2(PSRLW mm,imm8                 ; 0F 71 /2 ib          [PENT,MMX])]495 code2
[2(PSRLW xmm1,xmm2/m128          ; 66 0F D1 /r     [WILLAMETTE,SSE2] )]478 code1
[2(PSRLW xmm,imm8                ; 66 0F 71 /2 ib  [WILLAMETTE,SSE2])]467 code2
[2(PSRLD mm1,mm2/m64             ; 0F D2 /r             [PENT,MMX] )]450 code1
[2(PSRLD mm,imm8                 ; 0F 72 /2 ib          [PENT,MMX])]439 code2
[2(PSRLD xmm1,xmm2/m128          ; 66 0F D2 /r     [WILLAMETTE,SSE2] )]422 code1
[2(PSRLD xmm,imm8                ; 66 0F 72 /2 ib  [WILLAMETTE,SSE2])]411 code2
[2(PSRLQ mm1,mm2/m64             ; 0F D3 /r             [PENT,MMX] )]394 code1
[2(PSRLQ mm,imm8                 ; 0F 73 /2 ib          [PENT,MMX])]383 code2
[2(PSRLQ xmm1,xmm2/m128          ; 66 0F D3 /r     [WILLAMETTE,SSE2] )]366 code1
[2(PSRLQ xmm,imm8                ; 66 0F 73 /2 ib  [WILLAMETTE,SSE2])]355 code2
[2(PSRLDQ xmm1,imm8              ; 66 0F 73 /3 ib  [WILLAMETTE,SSE2])]338 code3
[2(PSRLx)0( performs logical right shifts of the data elements in the destination \(first\) operand, moving)]321 norm1
[(each bit in the separate elements right by the number of bits specified in the source \(second\))]310 norm0
[(operand, clearing the high-order bits as they are vacated. )2(PSRLDQ)0( shifts bytes, not bits.)]299 norm2
[2(PSRLW)0( shifts word sized elements.)]282 bull3
[2(PSRLD)0( shifts doubleword sized elements.)]265 bull3
[2(PSRLQ)0( shifts quadword sized elements.)]248 bull3
[2(PSRLDQ)0( shifts double quadword sized elements.)]231 bull3
[{/section-B.4.258 xa}2(PSUBx)0(: Subtract Packed Integers)](B.4.258)213 subh3
[2(PSUBB mm1,mm2/m64             ; 0F F8 /r             [PENT,MMX] )]196 code1
[2(PSUBW mm1,mm2/m64             ; 0F F9 /r             [PENT,MMX] )]185 code0
[2(PSUBD mm1,mm2/m64             ; 0F FA /r             [PENT,MMX] )]174 code0
[2(PSUBQ mm1,mm2/m64             ; 0F FB /r        [WILLAMETTE,SSE2])]163 code2
[2(PSUBB xmm1,xmm2/m128          ; 66 0F F8 /r     [WILLAMETTE,SSE2] )]146 code1
[2(PSUBW xmm1,xmm2/m128          ; 66 0F F9 /r     [WILLAMETTE,SSE2] )]135 code0
[2(PSUBD xmm1,xmm2/m128          ; 66 0F FA /r     [WILLAMETTE,SSE2] )]124 code0
[2(PSUBQ xmm1,xmm2/m128          ; 66 0F FB /r     [WILLAMETTE,SSE2])]113 code2
(178)pageeven
restore showpage
%%Page: 179 179
%%BeginPageSetup
save
%%EndPageSetup
/179 pa
[2(PSUBx)0( subtracts packed integers in the source operand from those in the destination operand. It)]681 norm1
[(doesn't differentiate between signed and unsigned integers, and doesn't set any of the flags.)]670 norm2
[2(PSUBB)0( operates on byte sized elements.)]653 bull3
[2(PSUBW)0( operates on word sized elements.)]636 bull3
[2(PSUBD)0( operates on doubleword sized elements.)]619 bull3
[2(PSUBQ)0( operates on quadword sized elements.)]602 bull3
[{/section-B.4.259 xa}2(PSUBSxx)0(, )2(PSUBUSx)0(: Subtract Packed Integers With Saturation)](B.4.259)584 subh3
[2(PSUBSB mm1,mm2/m64            ; 0F E8 /r             [PENT,MMX] )]567 code1
[2(PSUBSW mm1,mm2/m64            ; 0F E9 /r             [PENT,MMX])]556 code2
[2(PSUBSB xmm1,xmm2/m128         ; 66 0F E8 /r     [WILLAMETTE,SSE2] )]539 code1
[2(PSUBSW xmm1,xmm2/m128         ; 66 0F E9 /r     [WILLAMETTE,SSE2])]528 code2
[2(PSUBUSB mm1,mm2/m64           ; 0F D8 /r             [PENT,MMX] )]511 code1
[2(PSUBUSW mm1,mm2/m64           ; 0F D9 /r             [PENT,MMX])]500 code2
[2(PSUBUSB xmm1,xmm2/m128        ; 66 0F D8 /r     [WILLAMETTE,SSE2] )]483 code1
[2(PSUBUSW xmm1,xmm2/m128        ; 66 0F D9 /r     [WILLAMETTE,SSE2])]472 code2
[2(PSUBSx)0( and )2(PSUBUSx)0( subtracts packed integers in the source operand from those in the)]455 norm1
[(destination operand, and use saturation for results that are outside the range supported by the)]444 norm0
[(destination operand.)]433 norm2
[2(PSUBSB)0( operates on signed bytes, and uses signed saturation on the results.)]416 bull3
[2(PSUBSW)0( operates on signed words, and uses signed saturation on the results.)]399 bull3
[2(PSUBUSB)0( operates on unsigned bytes, and uses signed saturation on the results.)]382 bull3
[2(PSUBUSW)0( operates on unsigned words, and uses signed saturation on the results.)]365 bull3
[{/section-B.4.260 xa}2(PSUBSIW)0(: MMX Packed Subtract with Saturation to Implied Destination)](B.4.260)347 subh3
[2(PSUBSIW mm1,mm2/m64           ; 0F 55 /r             [CYRIX,MMX])]330 code3
[2(PSUBSIW)0(, specific to the Cyrix extensions to the MMX instruction set, performs the same function)]313 norm1
[(as )2(PSUBSW)0(, except that the result is not placed in the register specified by the first operand, but)]302 norm0
[(instead in the implied destination register, specified as for )2(PADDSIW)0( \(){/section-B.4.200 xl}(section B.4.200){el}(\).)]291 norm2
[{/section-B.4.261 xa}2(PSWAPD)0(: Swap Packed Data )](B.4.261)273 subh3
[2(PSWAPD mm1,mm2/m64            ; 0F 0F /r BB     [PENT,3DNOW])]256 code3
[2(PSWAPD)0( swaps the packed doublewords in the source operand, and stores the result in the)]239 norm1
[(destination operand.)]228 norm2
[(In the )2(K6-2)0( and )2(K6-III)0( processors, this opcode uses the mnemonic )2(PSWAPW)0(, and it swaps the)]211 norm1
[(order of words when copying from the source to the destination.)]200 norm2
[(The operation in the )2(K6-2)0( and )2(K6-III)0( processors is)]183 norm3
[2(   dst[0-15]  = src[48-63]; )]166 code1
[2(   dst[16-31] = src[32-47]; )]155 code0
[2(   dst[32-47] = src[16-31]; )]144 code0
[2(   dst[48-63] = src[0-15].)]133 code2
[(The operation in the )2(K6-x+)0(, )2(ATHLON)0( and later processors is:)]116 norm3
(179)pageodd
restore showpage
%%Page: 180 180
%%BeginPageSetup
save
%%EndPageSetup
/180 pa
[2(   dst[0-31]  = src[32-63]; )]681 code1
[2(   dst[32-63] = src[0-31].)]670 code2
[{/section-B.4.262 xa}2(PUNPCKxxx)0(: Unpack and Interleave Data)](B.4.262)652 subh3
[2(PUNPCKHBW mm1,mm2/m64         ; 0F 68 /r             [PENT,MMX] )]635 code1
[2(PUNPCKHWD mm1,mm2/m64         ; 0F 69 /r             [PENT,MMX] )]624 code0
[2(PUNPCKHDQ mm1,mm2/m64         ; 0F 6A /r             [PENT,MMX])]613 code2
[2(PUNPCKHBW xmm1,xmm2/m128      ; 66 0F 68 /r     [WILLAMETTE,SSE2] )]596 code1
[2(PUNPCKHWD xmm1,xmm2/m128      ; 66 0F 69 /r     [WILLAMETTE,SSE2] )]585 code0
[2(PUNPCKHDQ xmm1,xmm2/m128      ; 66 0F 6A /r     [WILLAMETTE,SSE2] )]574 code0
[2(PUNPCKHQDQ xmm1,xmm2/m128     ; 66 0F 6D /r     [WILLAMETTE,SSE2])]563 code2
[2(PUNPCKLBW mm1,mm2/m32         ; 0F 60 /r             [PENT,MMX] )]546 code1
[2(PUNPCKLWD mm1,mm2/m32         ; 0F 61 /r             [PENT,MMX] )]535 code0
[2(PUNPCKLDQ mm1,mm2/m32         ; 0F 62 /r             [PENT,MMX])]524 code2
[2(PUNPCKLBW xmm1,xmm2/m128      ; 66 0F 60 /r     [WILLAMETTE,SSE2] )]507 code1
[2(PUNPCKLWD xmm1,xmm2/m128      ; 66 0F 61 /r     [WILLAMETTE,SSE2] )]496 code0
[2(PUNPCKLDQ xmm1,xmm2/m128      ; 66 0F 62 /r     [WILLAMETTE,SSE2] )]485 code0
[2(PUNPCKLQDQ xmm1,xmm2/m128     ; 66 0F 6C /r     [WILLAMETTE,SSE2])]474 code2
[2(PUNPCKxx)0( all treat their operands as vectors, and produce a new vector generated by interleaving)]457 norm1
[(elements from the two inputs. The )2(PUNPCKHxx)0( instructions start by throwing away the bottom half)]446 norm0
[(of each input operand, and the )2(PUNPCKLxx)0( instructions throw away the top half.)]435 norm2
[(The remaining elements, are then interleaved into the destination, alternating elements from the)]418 norm1
[(second \(source\) operand and the first \(destination\) operand: so the leftmost part of each element in)]407 norm0
[(the result always comes from the second operand, and the rightmost from the destination.)]396 norm2
[2(PUNPCKxBW)0( works a byte at a time, producing word sized output elements.)]379 bull3
[2(PUNPCKxWD)0( works a word at a time, producing doubleword sized output elements.)]362 bull3
[2(PUNPCKxDQ)0( works a doubleword at a time, producing quadword sized output elements.)]345 bull3
[2(PUNPCKxQDQ)0( works a quadword at a time, producing double quadword sized output elements.)]328 bull3
[(So, for example, for )2(MMX)0( operands, if the first operand held )2(0x7A6A5A4A3A2A1A0A)0( and the)]311 norm1
[(second held )2(0x7B6B5B4B3B2B1B0B)0(, then:)]300 norm2
[2(PUNPCKHBW)0( would return )2(0x7B7A6B6A5B5A4B4A)0(.)]283 bull3
[2(PUNPCKHWD)0( would return )2(0x7B6B7A6A5B4B5A4A)0(.)]266 bull3
[2(PUNPCKHDQ)0( would return )2(0x7B6B5B4B7A6A5A4A)0(.)]249 bull3
[2(PUNPCKLBW)0( would return )2(0x3B3A2B2A1B1A0B0A)0(.)]232 bull3
[2(PUNPCKLWD)0( would return )2(0x3B2B3A2A1B0B1A0A)0(.)]215 bull3
[2(PUNPCKLDQ)0( would return )2(0x3B2B1B0B3A2A1A0A)0(.)]198 bull3
[{/section-B.4.263 xa}2(PUSH)0(: Push Data on Stack)](B.4.263)180 subh3
[2(PUSH reg16                    ; o16 50+r             [8086] )]163 code1
[2(PUSH reg32                    ; o32 50+r             [386])]152 code2
[2(PUSH r/m16                    ; o16 FF /6            [8086] )]135 code1
[2(PUSH r/m32                    ; o32 FF /6            [386])]124 code2
(180)pageeven
restore showpage
%%Page: 181 181
%%BeginPageSetup
save
%%EndPageSetup
/181 pa
[2(PUSH CS                       ; 0E                   [8086] )]681 code1
[2(PUSH DS                       ; 1E                   [8086] )]670 code0
[2(PUSH ES                       ; 06                   [8086] )]659 code0
[2(PUSH SS                       ; 16                   [8086] )]648 code0
[2(PUSH FS                       ; 0F A0                [386] )]637 code0
[2(PUSH GS                       ; 0F A8                [386])]626 code2
[2(PUSH imm8                     ; 6A ib                [186] )]609 code1
[2(PUSH imm16                    ; o16 68 iw            [186] )]598 code0
[2(PUSH imm32                    ; o32 68 id            [386])]587 code2
[2(PUSH)0( decrements the stack pointer \()2(SP)0( or )2(ESP)0(\) by 2 or 4, and then stores the given value at)]570 norm1
[2([SS:SP])0( or )2([SS:ESP])0(.)]559 norm2
[(The address-size attribute of the instruction determines whether )2(SP)0( or )2(ESP)0( is used as the stack)]542 norm1
[(pointer: to deliberately override the default given by the )2(BITS)0( setting, you can use an )2(a16)0( or )2(a32)]531 norm0
[(prefix.)]520 norm2
[(The operand-size attribute of the instruction determines whether the stack pointer is decremented)]503 norm1
[(by 2 or 4: this means that segment register pushes in )2(BITS 32)0( mode will push 4 bytes on the stack,)]492 norm0
[(of which the upper two are undefined. If you need to override that, you can use an )2(o16)0( or )2(o32)]481 norm0
[(prefix.)]470 norm2
[(The above opcode listings give two forms for general-purpose )(register push instructions: for)]453 norm1
[(example, )2(PUSH BX)0( has the two forms )2(53)0( and )2(FF F3)0(. NASM will always generate the shorter)]442 norm0
[(form when given )2(PUSH BX)0(. NDISASM will disassemble both.)]431 norm2
[(Unlike the undocumented and barely supported )2(POP CS)0(, )2(PUSH CS)0( is a perfectly valid and)]414 norm1
[(sensible instruction, supported on all processors.)]403 norm2
[(The instruction )2(PUSH SP)0( may be used to distinguish an 8086 from later processors: on an 8086,)]386 norm1
[(the value of )2(SP)0( stored is the value it has )1(after)0( the push instruction, whereas on later processors it is)]375 norm0
[(the value )1(before)0( the push instruction.)]364 norm2
[{/section-B.4.264 xa}2(PUSHAx)0(: Push All General-Purpose Registers)](B.4.264)346 subh3
[2(PUSHA                         ; 60                   [186] )]329 code1
[2(PUSHAD                        ; o32 60               [386] )]318 code0
[2(PUSHAW                        ; o16 60               [186])]307 code2
[2(PUSHAW)0( pushes, in succession, )2(AX)0(, )2(CX)0(, )2(DX)0(, )2(BX)0(, )2(SP)0(, )2(BP)0(, )2(SI)0( and )2(DI)0( on the stack, decrementing the)]290 norm1
[(stack pointer by a total of 16.)]279 norm2
[2(PUSHAD)0( pushes, in succession, )2(EAX)0(, )2(ECX)0(, )2(EDX)0(, )2(EBX)0(, )2(ESP)0(, )2(EBP)0(, )2(ESI)0( and )2(EDI)0( on the stack,)]262 norm1
[(decrementing the stack pointer by a total of 32.)]251 norm2
[(In both cases, the value of )2(SP)0( or )2(ESP)0( pushed is its )1(original)0( value, as it had before the instruction)]234 norm1
[(was executed.)]223 norm2
[2(PUSHA)0( is an alias mnemonic for either )2(PUSHAW)0( or )2(PUSHAD)0(, depending on the current )2(BITS)]206 norm1
[(setting.)]195 norm2
[(Note that the registers are pushed in order of their numeric values in opcodes \(see ){/section-B.2.1 xl}(section B.2.1){el}(\).)]178 norm3
[(See also )2(POPA)0( \(){/section-B.4.245 xl}(section B.4.245){el}(\).)]161 norm3
[{/section-B.4.265 xa}2(PUSHFx)0(: Push Flags Register)](B.4.265)143 subh3
[2(PUSHF                         ; 9C                   [8086] )]126 code1
[2(PUSHFD                        ; o32 9C               [386] )]115 code0
[2(PUSHFW                        ; o16 9C               [8086])]104 code2
(181)pageodd
restore showpage
%%Page: 182 182
%%BeginPageSetup
save
%%EndPageSetup
/182 pa
[2(PUSHFW)0( pushes the bottom 16 bits of the flags register \(or the whole flags register, on processors)]681 bull1
[(below a 386\) onto the stack.)]670 bull2
[2(PUSHFD)0( pushes the entire flags register onto the stack.)]653 bull3
[2(PUSHF)0( is an alias mnemonic for either )2(PUSHFW)0( or )2(PUSHFD)0(, depending on the current )2(BITS)]636 norm1
[(setting.)]625 norm2
[(See also )2(POPF)0( \(){/section-B.4.246 xl}(section B.4.246){el}(\).)]608 norm3
[{/section-B.4.266 xa}2(PXOR)0(: MMX Bitwise XOR)](B.4.266)590 subh3
[2(PXOR mm1,mm2/m64              ; 0F EF /r             [PENT,MMX] )]573 code1
[2(PXOR xmm1,xmm2/m128           ; 66 0F EF /r     [WILLAMETTE,SSE2])]562 code2
[2(PXOR)0( performs a bitwise XOR operation between its two operands \(i.e. each bit of the result is 1 if)]545 norm1
[(and only if exactly one of the corresponding bits of the two inputs was 1\), and stores the result in)]534 norm0
[(the destination \(first\) operand.)]523 norm2
[{/section-B.4.267 xa}2(RCL)0(, )2(RCR)0(: Bitwise Rotate through Carry Bit)](B.4.267)505 subh3
[2(RCL r/m8,1                    ; D0 /2                [8086] )]488 code1
[2(RCL r/m8,CL                   ; D2 /2                [8086] )]477 code0
[2(RCL r/m8,imm8                 ; C0 /2 ib             [186] )]466 code0
[2(RCL r/m16,1                   ; o16 D1 /2            [8086] )]455 code0
[2(RCL r/m16,CL                  ; o16 D3 /2            [8086] )]444 code0
[2(RCL r/m16,imm8                ; o16 C1 /2 ib         [186] )]433 code0
[2(RCL r/m32,1                   ; o32 D1 /2            [386] )]422 code0
[2(RCL r/m32,CL                  ; o32 D3 /2            [386] )]411 code0
[2(RCL r/m32,imm8                ; o32 C1 /2 ib         [386])]400 code2
[2(RCR r/m8,1                    ; D0 /3                [8086] )]383 code1
[2(RCR r/m8,CL                   ; D2 /3                [8086] )]372 code0
[2(RCR r/m8,imm8                 ; C0 /3 ib             [186] )]361 code0
[2(RCR r/m16,1                   ; o16 D1 /3            [8086] )]350 code0
[2(RCR r/m16,CL                  ; o16 D3 /3            [8086] )]339 code0
[2(RCR r/m16,imm8                ; o16 C1 /3 ib         [186] )]328 code0
[2(RCR r/m32,1                   ; o32 D1 /3            [386] )]317 code0
[2(RCR r/m32,CL                  ; o32 D3 /3            [386] )]306 code0
[2(RCR r/m32,imm8                ; o32 C1 /3 ib         [386])]295 code2
[2(RCL)0( and )2(RCR)0( perform a 9-bit, 17-bit or 33-bit bitwise rotation operation, involving the given)]278 norm1
[(source/destination \(first\) operand and the carry bit. Thus, for example, in the operation )2(RCL AL,1)0(,)]267 norm0
[(a 9-bit rotation is performed in which )2(AL)0( is shifted left by 1, the top bit of )2(AL)0( moves into the carry)]256 norm0
[(flag, and the original value of the carry flag is placed in the low bit of )2(AL)0(.)]245 norm2
[(The number of bits to rotate by is given by the second operand. Only the bottom five bits of the)]228 norm1
[(rotation count are considered by processors above the 8086.)]217 norm2
[(You can force the longer \(286 and upwards, beginning with a )2(C1)0( byte\) form of )2(RCL foo,1)0( by)]200 norm1
[(using a )2(BYTE)0( prefix: )2(RCL foo,BYTE 1)0(. Similarly with )2(RCR)0(.)]189 norm2
[{/section-B.4.268 xa}2(RCPPS)0(: Packed Single-Precision FP Reciprocal)](B.4.268)171 subh3
[2(RCPPS xmm1,xmm2/m128          ; 0F 53 /r        [KATMAI,SSE])]154 code3
[2(RCPPS)0( returns an approximation of the reciprocal of the packed single-precision FP values from)]137 norm1
[(xmm2/m128. The maximum error for this approximation is: |Error| <= 1.5 x 2^-12)]126 norm2
(182)pageeven
restore showpage
%%Page: 183 183
%%BeginPageSetup
save
%%EndPageSetup
/183 pa
[{/section-B.4.269 xa}2(RCPSS)0(: Scalar Single-Precision FP Reciprocal)](B.4.269)680 subh3
[2(RCPSS xmm1,xmm2/m128          ; F3 0F 53 /r     [KATMAI,SSE])]663 code3
[2(RCPSS)0( returns an approximation of the reciprocal of the lower single-precision FP value from)]646 norm1
[(xmm2/m32; the upper three fields are passed through from xmm1. The maximum error for this)]635 norm0
[(approximation is: |Error| <= 1.5 x 2^-12)]624 norm2
[{/section-B.4.270 xa}2(RDMSR)0(: Read Model-Specific Registers)](B.4.270)606 subh3
[2(RDMSR                         ; 0F 32                [PENT,PRIV])]589 code3
[2(RDMSR)0( reads the processor Model-Specific Register \(MSR\) whose index is stored in )2(ECX)0(, and)]572 norm1
[(stores the result in )2(EDX:EAX)0(. See also )2(WRMSR)0( \(){/section-B.4.329 xl}(section B.4.329){el}(\).)]561 norm2
[{/section-B.4.271 xa}2(RDPMC)0(: Read Performance-Monitoring Counters)](B.4.271)543 subh3
[2(RDPMC                         ; 0F 33                [P6])]526 code3
[2(RDPMC)0( reads the processor performance-monitoring counter whose index is stored in )2(ECX)0(, and)]509 norm1
[(stores the result in )2(EDX:EAX)0(.)]498 norm2
[(This instruction is available on P6 and later processors and on MMX class processors.)]481 norm3
[{/section-B.4.272 xa}2(RDSHR)0(: Read SMM Header Pointer Register)](B.4.272)463 subh3
[2(RDSHR r/m32                   ; 0F 36 /0        [386,CYRIX,SMM])]446 code3
[2(RDSHR)0( reads the contents of the SMM header pointer register and saves it to the destination)]429 norm1
[(operand, which can be either a 32 bit memory location or a 32 bit register.)]418 norm2
[(See also )2(WRSHR)0( \(){/section-B.4.330 xl}(section B.4.330){el}(\).)]401 norm3
[{/section-B.4.273 xa}2(RDTSC)0(: Read Time-Stamp Counter)](B.4.273)383 subh3
[2(RDTSC                         ; 0F 31                [PENT])]366 code3
[2(RDTSC)0( reads the processor's time-stamp counter into )2(EDX:EAX)0(.)]349 norm3
[{/section-B.4.274 xa}2(RET)0(, )2(RETF)0(, )2(RETN)0(: Return from Procedure Call)](B.4.274)331 subh3
[2(RET                           ; C3                   [8086] )]314 code1
[2(RET imm16                     ; C2 iw                [8086])]303 code2
[2(RETF                          ; CB                   [8086] )]286 code1
[2(RETF imm16                    ; CA iw                [8086])]275 code2
[2(RETN                          ; C3                   [8086] )]258 code1
[2(RETN imm16                    ; C2 iw                [8086])]247 code2
[2(RET)0(, and its exact synonym )2(RETN)0(, pop )2(IP)0( or )2(EIP)0( from the stack and transfer control to the new)]230 bull1
[(address. Optionally, if a numeric second operand is provided, they increment the stack pointer by)]219 bull0
[(a further )2(imm16)0( bytes after popping the return address.)]208 bull2
[2(RETF)0( executes a far return: after popping )2(IP)0(/)2(EIP)0(, it then pops )2(CS)0(, and )1(then)0( increments the)]191 bull1
[(stack pointer by the optional argument if present.)]180 bull2
[{/section-B.4.275 xa}2(ROL)0(, )2(ROR)0(: Bitwise Rotate)](B.4.275)162 subh3
[2(ROL r/m8,1                    ; D0 /0                [8086] )]145 code1
[2(ROL r/m8,CL                   ; D2 /0                [8086] )]134 code0
[2(ROL r/m8,imm8                 ; C0 /0 ib             [186] )]123 code0
[2(ROL r/m16,1                   ; o16 D1 /0            [8086] )]112 code0
[2(ROL r/m16,CL                  ; o16 D3 /0            [8086] )]101 code0
(183)pageodd
restore showpage
%%Page: 184 184
%%BeginPageSetup
save
%%EndPageSetup
/184 pa
[2(ROL r/m16,imm8                ; o16 C1 /0 ib         [186] )]681 code0
[2(ROL r/m32,1                   ; o32 D1 /0            [386] )]670 code0
[2(ROL r/m32,CL                  ; o32 D3 /0            [386] )]659 code0
[2(ROL r/m32,imm8                ; o32 C1 /0 ib         [386])]648 code2
[2(ROR r/m8,1                    ; D0 /1                [8086] )]631 code1
[2(ROR r/m8,CL                   ; D2 /1                [8086] )]620 code0
[2(ROR r/m8,imm8                 ; C0 /1 ib             [186] )]609 code0
[2(ROR r/m16,1                   ; o16 D1 /1            [8086] )]598 code0
[2(ROR r/m16,CL                  ; o16 D3 /1            [8086] )]587 code0
[2(ROR r/m16,imm8                ; o16 C1 /1 ib         [186] )]576 code0
[2(ROR r/m32,1                   ; o32 D1 /1            [386] )]565 code0
[2(ROR r/m32,CL                  ; o32 D3 /1            [386] )]554 code0
[2(ROR r/m32,imm8                ; o32 C1 /1 ib         [386])]543 code2
[2(ROL)0( and )2(ROR)0( perform a bitwise rotation operation on the given source/destination \(first\) operand.)]526 norm1
[(Thus, for example, in the operation )2(ROL AL,1)0(, an 8-bit rotation is performed in which )2(AL)0( is)]515 norm0
[(shifted left by 1 and the original top bit of )2(AL)0( moves round into the low bit.)]504 norm2
[(The number of bits to rotate by is given by the second operand. Only the bottom five bits of the)]487 norm1
[(rotation count are considered by processors above the 8086.)]476 norm2
[(You can force the longer \(286 and upwards, beginning with a )2(C1)0( byte\) form of )2(ROL foo,1)0( by)]459 norm1
[(using a )2(BYTE)0( prefix: )2(ROL foo,BYTE 1)0(. Similarly with )2(ROR)0(.)]448 norm2
[{/section-B.4.276 xa}2(RSDC)0(: Restore Segment Register and Descriptor)](B.4.276)430 subh3
[2(RSDC segreg,m80               ; 0F 79 /r        [486,CYRIX,SMM])]413 code3
[2(RSDC)0( restores a segment register \(DS, ES, FS, GS, or SS\) from mem80, and sets up its descriptor.)]396 norm3
[{/section-B.4.277 xa}2(RSLDT)0(: Restore Segment Register and Descriptor)](B.4.277)378 subh3
[2(RSLDT m80                     ; 0F 7B /0        [486,CYRIX,SMM])]361 code3
[2(RSLDT)0( restores the Local Descriptor Table \(LDTR\) from mem80.)]344 norm3
[{/section-B.4.278 xa}2(RSM)0(: Resume from System-Management Mode)](B.4.278)326 subh3
[2(RSM                           ; 0F AA                [PENT])]309 code3
[2(RSM)0( returns the processor to its normal operating mode when it was in System-Management Mode.)]292 norm3
[{/section-B.4.279 xa}2(RSQRTPS)0(: Packed Single-Precision FP Square Root Reciprocal)](B.4.279)274 subh3
[2(RSQRTPS xmm1,xmm2/m128        ; 0F 52 /r        [KATMAI,SSE])]257 code3
[2(RSQRTPS)0( computes the approximate reciprocals of the square roots of the packed single-precision)]240 norm1
[(floating-point values in the source and stores the results in xmm1. The maximum error for this)]229 norm0
[(approximation is: |Error| <= 1.5 x 2^-12)]218 norm2
[{/section-B.4.280 xa}2(RSQRTSS)0(: Scalar Single-Precision FP Square Root Reciprocal)](B.4.280)200 subh3
[2(RSQRTSS xmm1,xmm2/m128        ; F3 0F 52 /r     [KATMAI,SSE])]183 code3
[2(RSQRTSS)0( returns an approximation of the reciprocal of the square root of the lowest order)]166 norm1
[(single-precision FP value from the source, and stores it in the low doubleword of the destination)]155 norm0
[(register. The upper three fields of xmm1 are preserved. The maximum error for this approximation)]144 norm0
[(is: |Error| <= 1.5 x 2^-12)]133 norm2
(184)pageeven
restore showpage
%%Page: 185 185
%%BeginPageSetup
save
%%EndPageSetup
/185 pa
[{/section-B.4.281 xa}2(RSTS)0(: Restore TSR and Descriptor)](B.4.281)680 subh3
[2(RSTS m80                      ; 0F 7D /0        [486,CYRIX,SMM])]663 code3
[2(RSTS)0( restores Task State Register \(TSR\) from mem80.)]646 norm3
[{/section-B.4.282 xa}2(SAHF)0(: Store AH to Flags)](B.4.282)628 subh3
[2(SAHF                          ; 9E                   [8086])]611 code3
[2(SAHF)0( sets the low byte of the flags word according to the contents of the )2(AH)0( register.)]594 norm3
[(The operation of )2(SAHF)0( is:)]577 norm3
[2( AH --> SF:ZF:0:AF:0:PF:1:CF)]560 code3
[(See also )2(LAHF)0( \(){/section-B.4.131 xl}(section B.4.131){el}(\).)]543 norm3
[{/section-B.4.283 xa}2(SAL)0(, )2(SAR)0(: Bitwise Arithmetic Shifts)](B.4.283)525 subh3
[2(SAL r/m8,1                    ; D0 /4                [8086] )]508 code1
[2(SAL r/m8,CL                   ; D2 /4                [8086] )]497 code0
[2(SAL r/m8,imm8                 ; C0 /4 ib             [186] )]486 code0
[2(SAL r/m16,1                   ; o16 D1 /4            [8086] )]475 code0
[2(SAL r/m16,CL                  ; o16 D3 /4            [8086] )]464 code0
[2(SAL r/m16,imm8                ; o16 C1 /4 ib         [186] )]453 code0
[2(SAL r/m32,1                   ; o32 D1 /4            [386] )]442 code0
[2(SAL r/m32,CL                  ; o32 D3 /4            [386] )]431 code0
[2(SAL r/m32,imm8                ; o32 C1 /4 ib         [386])]420 code2
[2(SAR r/m8,1                    ; D0 /7                [8086] )]403 code1
[2(SAR r/m8,CL                   ; D2 /7                [8086] )]392 code0
[2(SAR r/m8,imm8                 ; C0 /7 ib             [186] )]381 code0
[2(SAR r/m16,1                   ; o16 D1 /7            [8086] )]370 code0
[2(SAR r/m16,CL                  ; o16 D3 /7            [8086] )]359 code0
[2(SAR r/m16,imm8                ; o16 C1 /7 ib         [186] )]348 code0
[2(SAR r/m32,1                   ; o32 D1 /7            [386] )]337 code0
[2(SAR r/m32,CL                  ; o32 D3 /7            [386] )]326 code0
[2(SAR r/m32,imm8                ; o32 C1 /7 ib         [386])]315 code2
[2(SAL)0( and )2(SAR)0( perform an arithmetic shift operation on the given source/destination \(first\) operand.)]298 norm1
[(The vacated bits are filled with zero for )2(SAL)0(, and with copies of the original high bit of the source)]287 norm0
[(operand for )2(SAR)0(.)]276 norm2
[2(SAL)0( is a synonym for )2(SHL)0( \(see ){/section-B.4.290 xl}(section B.4.290){el}(\). NASM will assemble either one to the same code,)]259 norm1
[(but NDISASM will always disassemble that code as )2(SHL)0(.)]248 norm2
[(The number of bits to shift by is given by the second operand. Only the bottom five bits of the shift)]231 norm1
[(count are considered by processors above the 8086.)]220 norm2
[(You can force the longer \(286 and upwards, beginning with a )2(C1)0( byte\) form of )2(SAL foo,1)0( by)]203 norm1
[(using a )2(BYTE)0( prefix: )2(SAL foo,BYTE 1)0(. Similarly with )2(SAR)0(.)]192 norm2
[{/section-B.4.284 xa}2(SALC)0(: Set AL from Carry Flag)](B.4.284)174 subh3
[2(SALC                          ; D6                  [8086,UNDOC])]157 code3
[2(SALC)0( is an early undocumented instruction similar in concept to )2(SETcc)0( \(){/section-B.4.287 xl}(section B.4.287){el}(\). Its)]140 norm1
[(function is to set )2(AL)0( to zero if the carry flag is clear, or to )2(0xFF)0( if it is set.)]129 norm2
(185)pageodd
restore showpage
%%Page: 186 186
%%BeginPageSetup
save
%%EndPageSetup
/186 pa
[{/section-B.4.285 xa}2(SBB)0(: Subtract with Borrow)](B.4.285)680 subh3
[2(SBB r/m8,reg8                 ; 18 /r                [8086] )]663 code1
[2(SBB r/m16,reg16               ; o16 19 /r            [8086] )]652 code0
[2(SBB r/m32,reg32               ; o32 19 /r            [386])]641 code2
[2(SBB reg8,r/m8                 ; 1A /r                [8086] )]624 code1
[2(SBB reg16,r/m16               ; o16 1B /r            [8086] )]613 code0
[2(SBB reg32,r/m32               ; o32 1B /r            [386])]602 code2
[2(SBB r/m8,imm8                 ; 80 /3 ib             [8086] )]585 code1
[2(SBB r/m16,imm16               ; o16 81 /3 iw         [8086] )]574 code0
[2(SBB r/m32,imm32               ; o32 81 /3 id         [386])]563 code2
[2(SBB r/m16,imm8                ; o16 83 /3 ib         [8086] )]546 code1
[2(SBB r/m32,imm8                ; o32 83 /3 ib         [386])]535 code2
[2(SBB AL,imm8                   ; 1C ib                [8086] )]518 code1
[2(SBB AX,imm16                  ; o16 1D iw            [8086] )]507 code0
[2(SBB EAX,imm32                 ; o32 1D id            [386])]496 code2
[2(SBB)0( performs integer subtraction: it subtracts its second operand, plus the value of the carry flag,)]479 norm1
[(from its first, and leaves the result in its destination \(first\) operand. The flags are set according to)]468 norm0
[(the result of the operation: in particular, the carry flag is affected and can be used by a subsequent)]457 norm0
[2(SBB)0( instruction.)]446 norm2
[(In the forms with an 8-bit immediate second operand and a longer first operand, the second operand)]429 norm1
[(is considered to be signed, and is sign-extended to the length of the first operand. In these cases, the)]418 norm0
[2(BYTE)0( qualifier is necessary to force NASM to generate this form of the instruction.)]407 norm2
[(To subtract one number from another without also subtracting the contents of the carry flag, use)]390 norm1
[2(SUB)0( \(){/section-B.4.305 xl}(section B.4.305){el}(\).)]379 norm2
[{/section-B.4.286 xa}2(SCASB)0(, )2(SCASW)0(, )2(SCASD)0(: Scan String)](B.4.286)361 subh3
[2(SCASB                         ; AE                   [8086] )]344 code1
[2(SCASW                         ; o16 AF               [8086] )]333 code0
[2(SCASD                         ; o32 AF               [386])]322 code2
[2(SCASB)0( compares the byte in )2(AL)0( with the byte at )2([ES:DI])0( or )2([ES:EDI])0(, and sets the flags)]305 norm1
[(accordingly. It then increments or decrements \(depending on the direction flag: increments if the)]294 norm0
[(flag is clear, decrements if it is set\) )2(DI)0( \(or )2(EDI)0(\).)]283 norm2
[(The register used is )2(DI)0( if the address size is 16 bits, and )2(EDI)0( if it is 32 bits. If you need to use an)]266 norm1
[(address size not equal to the current )2(BITS)0( setting, you can use an explicit )2(a16)0( or )2(a32)0( prefix.)]255 norm2
[(Segment override prefixes have no effect for this instruction: the use of )2(ES)0( for the load from )2([DI])]238 norm1
[(or )2([EDI])0( cannot be overridden.)]227 norm2
[2(SCASW)0( and )2(SCASD)0( work in the same way, but they compare a word to )2(AX)0( or a doubleword to )2(EAX)]210 norm1
[(instead of a byte to )2(AL)0(, and increment or decrement the addressing registers by 2 or 4 instead of 1.)]199 norm2
[(The )2(REPE)0( and )2(REPNE)0( prefixes \(equivalently, )2(REPZ)0( and )2(REPNZ)0(\) may be used to repeat the)]182 norm1
[(instruction up to )2(CX)0( \(or )2(ECX)0( \226 again, the address size chooses which\) times until the first unequal or)]171 norm0
[(equal byte is found.)]160 norm2
[{/section-B.4.287 xa}2(SETcc)0(: Set Register from Condition)](B.4.287)142 subh3
[2(SETcc r/m8                    ; 0F 90+cc /2          [386])]125 code3
[2(SETcc)0( sets the given 8-bit operand to zero if its condition is not satisfied, and to 1 if it is.)]108 norm3
(186)pageeven
restore showpage
%%Page: 187 187
%%BeginPageSetup
save
%%EndPageSetup
/187 pa
[{/section-B.4.288 xa}2(SFENCE)0(: Store Fence)](B.4.288)680 subh3
[2(SFENCE                 ; 0F AE /7               [KATMAI])]663 code3
[2(SFENCE)0( performs a serialising operation on all writes to memory that were issued before the)]646 norm1
[2(SFENCE)0( instruction. This guarantees that all memory writes before the )2(SFENCE)0( instruction are)]635 norm0
[(visible before any writes after the )2(SFENCE)0( instruction.)]624 norm2
[2(SFENCE)0( is ordered respective to other )2(SFENCE)0( instruction, )2(MFENCE)0(, any memory write and any)]607 norm1
[(other serialising instruction \(such as )2(CPUID)0(\).)]596 norm2
[(Weakly ordered memory types can be used to achieve higher processor performance through such)]579 norm1
[(techniques as out-of-order issue, write-combining, and write-collapsing. The degree to which a)]568 norm0
[(consumer of data recognizes or knows that the data is weakly ordered varies among applications)]557 norm0
[(and may be unknown to the producer of this data. The )2(SFENCE)0( instruction provides a)]546 norm0
[(performance-efficient way of insuring store ordering between routines that produce)]535 norm0
[(weakly-ordered results and routines that consume this data.)]524 norm2
[2(SFENCE)0( uses the following ModRM encoding:)]507 norm3
[2(          Mod \(7:6\)        = 11B )]490 code1
[2(          Reg/Opcode \(5:3\) = 111B )]479 code0
[2(          R/M \(2:0\)        = 000B)]468 code2
[(All other ModRM encodings are defined to be reserved, and use of these encodings risks)]451 norm1
[(incompatibility with future processors.)]440 norm2
[(See also )2(LFENCE)0( \(){/section-B.4.137 xl}(section B.4.137){el}(\) and )2(MFENCE)0( \(){/section-B.4.151 xl}(section B.4.151){el}(\).)]423 norm3
[{/section-B.4.289 xa}2(SGDT)0(, )2(SIDT)0(, )2(SLDT)0(: Store Descriptor Table Pointers)](B.4.289)405 subh3
[2(SGDT mem                      ; 0F 01 /0             [286,PRIV] )]388 code1
[2(SIDT mem                      ; 0F 01 /1             [286,PRIV] )]377 code0
[2(SLDT r/m16                    ; 0F 00 /0             [286,PRIV])]366 code2
[2(SGDT)0( and )2(SIDT)0( both take a 6-byte memory area as an operand: they store the contents of the)]349 norm1
[(GDTR \(global descriptor table register\) or IDTR \(interrupt descriptor table register\) into that area as)]338 norm0
[(a 32-bit linear address and a 16-bit size limit from that area \(in that order\). These are the only)]327 norm0
[(instructions which directly use )1(linear)0( addresses, rather than segment/offset pairs.)]316 norm2
[2(SLDT)0( stores the segment selector corresponding to the LDT \(local descriptor table\) into the given)]299 norm1
[(operand.)]288 norm2
[(See also )2(LGDT)0(, )2(LIDT)0( and )2(LLDT)0( \(){/section-B.4.138 xl}(section B.4.138){el}(\).)]271 norm3
[{/section-B.4.290 xa}2(SHL)0(, )2(SHR)0(: Bitwise Logical Shifts)](B.4.290)253 subh3
[2(SHL r/m8,1                    ; D0 /4                [8086] )]236 code1
[2(SHL r/m8,CL                   ; D2 /4                [8086] )]225 code0
[2(SHL r/m8,imm8                 ; C0 /4 ib             [186] )]214 code0
[2(SHL r/m16,1                   ; o16 D1 /4            [8086] )]203 code0
[2(SHL r/m16,CL                  ; o16 D3 /4            [8086] )]192 code0
[2(SHL r/m16,imm8                ; o16 C1 /4 ib         [186] )]181 code0
[2(SHL r/m32,1                   ; o32 D1 /4            [386] )]170 code0
[2(SHL r/m32,CL                  ; o32 D3 /4            [386] )]159 code0
[2(SHL r/m32,imm8                ; o32 C1 /4 ib         [386])]148 code2
[2(SHR r/m8,1                    ; D0 /5                [8086] )]131 code1
[2(SHR r/m8,CL                   ; D2 /5                [8086] )]120 code0
[2(SHR r/m8,imm8                 ; C0 /5 ib             [186] )]109 code0
(187)pageodd
restore showpage
%%Page: 188 188
%%BeginPageSetup
save
%%EndPageSetup
/188 pa
[2(SHR r/m16,1                   ; o16 D1 /5            [8086] )]681 code0
[2(SHR r/m16,CL                  ; o16 D3 /5            [8086] )]670 code0
[2(SHR r/m16,imm8                ; o16 C1 /5 ib         [186] )]659 code0
[2(SHR r/m32,1                   ; o32 D1 /5            [386] )]648 code0
[2(SHR r/m32,CL                  ; o32 D3 /5            [386] )]637 code0
[2(SHR r/m32,imm8                ; o32 C1 /5 ib         [386])]626 code2
[2(SHL)0( and )2(SHR)0( perform a logical shift operation on the given source/destination \(first\) operand. The)]609 norm1
[(vacated bits are filled with zero.)]598 norm2
[(A synonym for )2(SHL)0( is )2(SAL)0( \(see ){/section-B.4.283 xl}(section B.4.283){el}(\). NASM will assemble either one to the same)]581 norm1
[(code, but NDISASM will always disassemble that code as )2(SHL)0(.)]570 norm2
[(The number of bits to shift by is given by the second operand. Only the bottom five bits of the shift)]553 norm1
[(count are considered by processors above the 8086.)]542 norm2
[(You can force the longer \(286 and upwards, beginning with a )2(C1)0( byte\) form of )2(SHL foo,1)0( by)]525 norm1
[(using a )2(BYTE)0( prefix: )2(SHL foo,BYTE 1)0(. Similarly with )2(SHR)0(.)]514 norm2
[{/section-B.4.291 xa}2(SHLD)0(, )2(SHRD)0(: Bitwise Double-Precision Shifts)](B.4.291)496 subh3
[2(SHLD r/m16,reg16,imm8         ; o16 0F A4 /r ib      [386] )]479 code1
[2(SHLD r/m16,reg32,imm8         ; o32 0F A4 /r ib      [386] )]468 code0
[2(SHLD r/m16,reg16,CL           ; o16 0F A5 /r         [386] )]457 code0
[2(SHLD r/m16,reg32,CL           ; o32 0F A5 /r         [386])]446 code2
[2(SHRD r/m16,reg16,imm8         ; o16 0F AC /r ib      [386] )]429 code1
[2(SHRD r/m32,reg32,imm8         ; o32 0F AC /r ib      [386] )]418 code0
[2(SHRD r/m16,reg16,CL           ; o16 0F AD /r         [386] )]407 code0
[2(SHRD r/m32,reg32,CL           ; o32 0F AD /r         [386])]396 code2
[2(SHLD)0( performs a double-precision left shift. It notionally places its second operand to the right)]379 bull1
[(of its first, then shifts the entire bit string thus generated to the left by a number of bits specified)]368 bull0
[(in the third operand. It then updates only the )1(first)0( operand according to the result of this. The)]357 bull0
[(second operand is not modified.)]346 bull2
[2(SHRD)0( performs the corresponding right shift: it notionally places the second operand to the )1(left)0( of)]329 bull1
[(the first, shifts the whole bit string right, and updates only the first operand.)]318 bull2
[(For example, if )2(EAX)0( holds )2(0x01234567)0( and )2(EBX)0( holds )2(0x89ABCDEF)0(, then the instruction)]301 norm1
[2(SHLD EAX,EBX,4)0( would update )2(EAX)0( to hold )2(0x12345678)0(. Under the same conditions,)]290 norm0
[2(SHRD EAX,EBX,4)0( would update )2(EAX)0( to hold )2(0xF0123456)0(.)]279 norm2
[(The number of bits to shift by is given by the third operand. Only the bottom five bits of the shift)]262 norm1
[(count are considered.)]251 norm2
[{/section-B.4.292 xa}2(SHUFPD)0(: Shuffle Packed Double-Precision FP Values)](B.4.292)233 subh3
[2(SHUFPD xmm1,xmm2/m128,imm8    ; 66 0F C6 /r ib  [WILLAMETTE,SSE2])]216 code3
[2(SHUFPD)0( moves one of the packed double-precision FP values from the destination operand into)]199 norm1
[(the low quadword of the destination operand; the upper quadword is generated by moving one of)]188 norm0
[(the double-precision FP values from the source operand into the destination. The select \(third\))]177 norm0
[(operand selects which of the values are moved to the destination register.)]166 norm2
[(The select operand is an 8-bit immediate: bit 0 selects which value is moved from the destination)]149 norm1
[(operand to the result \(where 0 selects the low quadword and 1 selects the high quadword\) and bit 1)]138 norm0
[(selects which value is moved from the source operand to the result. Bits 2 through 7 of the shuffle)]127 norm0
[(operand are reserved.)]116 norm2
(188)pageeven
restore showpage
%%Page: 189 189
%%BeginPageSetup
save
%%EndPageSetup
/189 pa
[{/section-B.4.293 xa}2(SHUFPS)0(: Shuffle Packed Single-Precision FP Values)](B.4.293)680 subh3
[2(SHUFPS xmm1,xmm2/m128,imm8    ; 0F C6 /r ib     [KATMAI,SSE])]663 code3
[2(SHUFPS)0( moves two of the packed single-precision FP values from the destination operand into the)]646 norm1
[(low quadword of the destination operand; the upper quadword is generated by moving two of the)]635 norm0
[(single-precision FP values from the source operand into the destination. The select \(third\) operand)]624 norm0
[(selects which of the values are moved to the destination register.)]613 norm2
[(The select operand is an 8-bit immediate: bits 0 and 1 select the value to be moved from the)]596 norm1
[(destination operand the low doubleword of the result, bits 2 and 3 select the value to be moved from)]585 norm0
[(the destination operand the second doubleword of the result, bits 4 and 5 select the value to be)]574 norm0
[(moved from the source operand the third doubleword of the result, and bits 6 and 7 select the value)]563 norm0
[(to be moved from the source operand to the high doubleword of the result.)]552 norm2
[{/section-B.4.294 xa}2(SMI)0(: System Management Interrupt)](B.4.294)534 subh3
[2(SMI                           ; F1                   [386,UNDOC])]517 code3
[2(SMI)0( puts some AMD processors into SMM mode. It is available on some 386 and 486 processors,)]500 norm1
[(and is only available when DR7 bit 12 is set, otherwise it generates an Int 1.)]489 norm2
[{/section-B.4.295 xa}2(SMINT)0(, )2(SMINTOLD)0(: Software SMM Entry \(CYRIX\))](B.4.295)471 subh3
[2(SMINT                         ; 0F 38                [PENT,CYRIX] )]454 code1
[2(SMINTOLD                      ; 0F 7E                [486,CYRIX])]443 code2
[2(SMINT)0( puts the processor into SMM mode. The CPU state information is saved in the SMM)]426 norm1
[(memory header, and then execution begins at the SMM base address.)]415 norm2
[2(SMINTOLD)0( is the same as )2(SMINT)0(, but was the opcode used on the 486.)]398 norm3
[(This pair of opcodes are specific to the Cyrix and compatible range of processors \(Cyrix, IBM, Via\).)]381 norm3
[{/section-B.4.296 xa}2(SMSW)0(: Store Machine Status Word)](B.4.296)363 subh3
[2(SMSW r/m16                    ; 0F 01 /4             [286,PRIV])]346 code3
[2(SMSW)0( stores the bottom half of the )2(CR0)0( control register \(or the Machine Status Word, on 286)]329 norm1
[(processors\) into the destination operand. See also )2(LMSW)0( \(){/section-B.4.139 xl}(section B.4.139){el}(\).)]318 norm2
[(For 32-bit code, this would store all of )2(CR0)0( in the specified register \(or the bottom 16 bits if the)]301 norm1
[(destination is a memory location\), without needing an operand size override byte.)]290 norm2
[{/section-B.4.297 xa}2(SQRTPD)0(: Packed Double-Precision FP Square Root)](B.4.297)272 subh3
[2(SQRTPD xmm1,xmm2/m128         ; 66 0F 51 /r     [WILLAMETTE,SSE2])]255 code3
[2(SQRTPD)0( calculates the square root of the packed double-precision FP value from the source)]238 norm1
[(operand, and stores the double-precision results in the destination register.)]227 norm2
[{/section-B.4.298 xa}2(SQRTPS)0(: Packed Single-Precision FP Square Root)](B.4.298)209 subh3
[2(SQRTPS xmm1,xmm2/m128         ; 0F 51 /r        [KATMAI,SSE])]192 code3
[2(SQRTPS)0( calculates the square root of the packed single-precision FP value from the source)]175 norm1
[(operand, and stores the single-precision results in the destination register.)]164 norm2
[{/section-B.4.299 xa}2(SQRTSD)0(: Scalar Double-Precision FP Square Root)](B.4.299)146 subh3
[2(SQRTSD xmm1,xmm2/m128         ; F2 0F 51 /r     [WILLAMETTE,SSE2])]129 code3
(189)pageodd
restore showpage
%%Page: 190 190
%%BeginPageSetup
save
%%EndPageSetup
/190 pa
[2(SQRTSD)0( calculates the square root of the low-order double-precision FP value from the source)]681 norm1
[(operand, and stores the double-precision result in the destination register. The high-quadword)]670 norm0
[(remains unchanged.)]659 norm2
[{/section-B.4.300 xa}2(SQRTSS)0(: Scalar Single-Precision FP Square Root)](B.4.300)641 subh3
[2(SQRTSS xmm1,xmm2/m128         ; F3 0F 51 /r     [KATMAI,SSE])]624 code3
[2(SQRTSS)0( calculates the square root of the low-order single-precision FP value from the source)]607 norm1
[(operand, and stores the single-precision result in the destination register. The three high)]596 norm0
[(doublewords remain unchanged.)]585 norm2
[{/section-B.4.301 xa}2(STC)0(, )2(STD)0(, )2(STI)0(: Set Flags)](B.4.301)567 subh3
[2(STC                           ; F9                   [8086] )]550 code1
[2(STD                           ; FD                   [8086] )]539 code0
[2(STI                           ; FB                   [8086])]528 code2
[(These instructions set various flags. )2(STC)0( sets the carry flag; )2(STD)0( sets the direction flag; and )2(STI)]511 norm1
[(sets the interrupt flag \(thus enabling interrupts\).)]500 norm2
[(To clear the carry, direction, or interrupt flags, use the )2(CLC)0(, )2(CLD)0( and )2(CLI)0( instructions \(){/section-B.4.20 xl}(section){el}]483 norm1
[{/section-B.4.20 xl}(B.4.20){el}(\). To invert the carry flag, use )2(CMC)0( \(){/section-B.4.22 xl}(section B.4.22){el}(\).)]472 norm2
[{/section-B.4.302 xa}2(STMXCSR)0(: Store Streaming SIMD Extension Control/Status)](B.4.302)454 subh3
[2(STMXCSR m32                   ; 0F AE /3        [KATMAI,SSE])]437 code3
[2(STMXCSR)0( stores the contents of the )2(MXCSR)0( control/status register to the specified memory location.)]420 norm1
[2(MXCSR)0( is used to enable masked/unmasked exception handling, to set rounding modes, to set)]409 norm0
[(flush-to-zero mode, and to view exception status flags. The reserved bits in the )2(MXCSR)0( register are)]398 norm0
[(stored as 0s.)]387 norm2
[(For details of the )2(MXCSR)0( register, see the Intel processor docs.)]370 norm3
[(See also )2(LDMXCSR)0( \(){/section-B.4.133 xl}(section B.4.133){el}(\).)]353 norm3
[{/section-B.4.303 xa}2(STOSB)0(, )2(STOSW)0(, )2(STOSD)0(: Store Byte to String)](B.4.303)335 subh3
[2(STOSB                         ; AA                   [8086] )]318 code1
[2(STOSW                         ; o16 AB               [8086] )]307 code0
[2(STOSD                         ; o32 AB               [386])]296 code2
[2(STOSB)0( stores the byte in )2(AL)0( at )2([ES:DI])0( or )2([ES:EDI])0(, and sets the flags accordingly. It then)]279 norm1
[(increments or decrements \(depending on the direction flag: increments if the flag is clear,)]268 norm0
[(decrements if it is set\) )2(DI)0( \(or )2(EDI)0(\).)]257 norm2
[(The register used is )2(DI)0( if the address size is 16 bits, and )2(EDI)0( if it is 32 bits. If you need to use an)]240 norm1
[(address size not equal to the current )2(BITS)0( setting, you can use an explicit )2(a16)0( or )2(a32)0( prefix.)]229 norm2
[(Segment override prefixes have no effect for this instruction: the use of )2(ES)0( for the store to )2([DI])0( or)]212 norm1
[2([EDI])0( cannot be overridden.)]201 norm2
[2(STOSW)0( and )2(STOSD)0( work in the same way, but they store the word in )2(AX)0( or the doubleword in )2(EAX)]184 norm1
[(instead of the byte in )2(AL)0(, and increment or decrement the addressing registers by 2 or 4 instead of 1.)]173 norm2
[(The )2(REP)0( prefix may be used to repeat the instruction )2(CX)0( \(or )2(ECX)0( \226 again, the address size chooses)]156 norm1
[(which\) times.)]145 norm2
[{/section-B.4.304 xa}2(STR)0(: Store Task Register)](B.4.304)127 subh3
[2(STR r/m16                     ; 0F 00 /1             [286,PRIV])]110 code3
(190)pageeven
restore showpage
%%Page: 191 191
%%BeginPageSetup
save
%%EndPageSetup
/191 pa
[2(STR)0( stores the segment selector corresponding to the contents of the Task Register into its operand.)]681 norm1
[(When the operand size is 32 bit and the destination is a register, the upper 16-bits are cleared to 0s.)]670 norm0
[(When the destination operand is a memory location, 16 bits are written regardless of the operand)]659 norm0
[(size.)]648 norm2
[{/section-B.4.305 xa}2(SUB)0(: Subtract Integers)](B.4.305)630 subh3
[2(SUB r/m8,reg8                 ; 28 /r                [8086] )]613 code1
[2(SUB r/m16,reg16               ; o16 29 /r            [8086] )]602 code0
[2(SUB r/m32,reg32               ; o32 29 /r            [386])]591 code2
[2(SUB reg8,r/m8                 ; 2A /r                [8086] )]574 code1
[2(SUB reg16,r/m16               ; o16 2B /r            [8086] )]563 code0
[2(SUB reg32,r/m32               ; o32 2B /r            [386])]552 code2
[2(SUB r/m8,imm8                 ; 80 /5 ib             [8086] )]535 code1
[2(SUB r/m16,imm16               ; o16 81 /5 iw         [8086] )]524 code0
[2(SUB r/m32,imm32               ; o32 81 /5 id         [386])]513 code2
[2(SUB r/m16,imm8                ; o16 83 /5 ib         [8086] )]496 code1
[2(SUB r/m32,imm8                ; o32 83 /5 ib         [386])]485 code2
[2(SUB AL,imm8                   ; 2C ib                [8086] )]468 code1
[2(SUB AX,imm16                  ; o16 2D iw            [8086] )]457 code0
[2(SUB EAX,imm32                 ; o32 2D id            [386])]446 code2
[2(SUB)0( performs integer subtraction: it subtracts its second operand from its first, and leaves the result)]429 norm1
[(in its destination \(first\) operand. The flags are set according to the result of the operation: in)]418 norm0
[(particular, the carry flag is affected and can be used by a subsequent )2(SBB)0( instruction \(){/section-B.4.285 xl}(section){el}]407 norm0
[{/section-B.4.285 xl}(B.4.285){el}(\).)]396 norm2
[(In the forms with an 8-bit immediate second operand and a longer first operand, the second operand)]379 norm1
[(is considered to be signed, and is sign-extended to the length of the first operand. In these cases, the)]368 norm0
[2(BYTE)0( qualifier is necessary to force NASM to generate this form of the instruction.)]357 norm2
[{/section-B.4.306 xa}2(SUBPD)0(: Packed Double-Precision FP Subtract)](B.4.306)339 subh3
[2(SUBPD xmm1,xmm2/m128          ; 66 0F 5C /r     [WILLAMETTE,SSE2])]322 code3
[2(SUBPD)0( subtracts the packed double-precision FP values of the source operand from those of the)]305 norm1
[(destination operand, and stores the result in the destination operation.)]294 norm2
[{/section-B.4.307 xa}2(SUBPS)0(: Packed Single-Precision FP Subtract)](B.4.307)276 subh3
[2(SUBPS xmm1,xmm2/m128          ; 0F 5C /r        [KATMAI,SSE])]259 code3
[2(SUBPS)0( subtracts the packed single-precision FP values of the source operand from those of the)]242 norm1
[(destination operand, and stores the result in the destination operation.)]231 norm2
[{/section-B.4.308 xa}2(SUBSD)0(: Scalar Single-FP Subtract)](B.4.308)213 subh3
[2(SUBSD xmm1,xmm2/m128          ; F2 0F 5C /r     [WILLAMETTE,SSE2])]196 code3
[2(SUBSD)0( subtracts the low-order double-precision FP value of the source operand from that of the)]179 norm1
[(destination operand, and stores the result in the destination operation. The high quadword is)]168 norm0
[(unchanged.)]157 norm2
[{/section-B.4.309 xa}2(SUBSS)0(: Scalar Single-FP Subtract)](B.4.309)139 subh3
[2(SUBSS xmm1,xmm2/m128          ; F3 0F 5C /r     [KATMAI,SSE])]122 code3
(191)pageodd
restore showpage
%%Page: 192 192
%%BeginPageSetup
save
%%EndPageSetup
/192 pa
[2(SUBSS)0( subtracts the low-order single-precision FP value of the source operand from that of the)]681 norm1
[(destination operand, and stores the result in the destination operation. The three high doublewords)]670 norm0
[(are unchanged.)]659 norm2
[{/section-B.4.310 xa}2(SVDC)0(: Save Segment Register and Descriptor)](B.4.310)641 subh3
[2(SVDC m80,segreg               ; 0F 78 /r        [486,CYRIX,SMM])]624 code3
[2(SVDC)0( saves a segment register \(DS, ES, FS, GS, or SS\) and its descriptor to mem80.)]607 norm3
[{/section-B.4.311 xa}2(SVLDT)0(: Save LDTR and Descriptor)](B.4.311)589 subh3
[2(SVLDT m80                     ; 0F 7A /0        [486,CYRIX,SMM])]572 code3
[2(SVLDT)0( saves the Local Descriptor Table \(LDTR\) to mem80.)]555 norm3
[{/section-B.4.312 xa}2(SVTS)0(: Save TSR and Descriptor)](B.4.312)537 subh3
[2(SVTS m80                      ; 0F 7C /0        [486,CYRIX,SMM])]520 code3
[2(SVTS)0( saves the Task State Register \(TSR\) to mem80.)]503 norm3
[{/section-B.4.313 xa}2(SYSCALL)0(: Call Operating System)](B.4.313)485 subh3
[2(SYSCALL                       ; 0F 05                [P6,AMD])]468 code3
[2(SYSCALL)0( provides a fast method of transferring control to a fixed entry point in an operating)]451 norm1
[(system.)]440 norm2
[(The )2(EIP)0( register is copied into the )2(ECX)0( register.)]423 bull3
[(Bits [31-0] of the 64-bit SYSCALL/SYSRET Target Address Register \()2(STAR)0(\) are copied into)]406 bull1
[(the )2(EIP)0( register.)]395 bull2
[(Bits [47-32] of the )2(STAR)0( register specify the selector that is copied into the )2(CS)0( register.)]378 bull3
[(Bits [47-32]+1000b of the )2(STAR)0( register specify the selector that is copied into the SS register.)]361 bull3
[(The )2(CS)0( and )2(SS)0( registers should not be modified by the operating system between the execution of)]344 norm1
[(the )2(SYSCALL)0( instruction and its corresponding )2(SYSRET)0( instruction.)]333 norm2
[(For more information, see the )2(SYSCALL and SYSRET Instruction Specification)]316 norm1
[(\(AMD document number 21086.pdf\).)]305 norm2
[{/section-B.4.314 xa}2(SYSENTER)0(: Fast System Call)](B.4.314)287 subh3
[2(SYSENTER                      ; 0F 34                [P6])]270 code3
[2(SYSENTER)0( executes a fast call to a level 0 system procedure or routine. Before using this)]253 norm1
[(instruction, various MSRs need to be set up:)]242 norm2
[2(SYSENTER_CS_MSR)0( contains the 32-bit segment selector for the privilege level 0 code)]225 bull1
[(segment. \(This value is also used to compute the segment selector of the privilege level 0 stack)]214 bull0
[(segment.\))]203 bull2
[2(SYSENTER_EIP_MSR)0( contains the 32-bit offset into the privilege level 0 code segment to the)]186 bull1
[(first instruction of the selected operating procedure or routine.)]175 bull2
[2(SYSENTER_ESP_MSR)0( contains the 32-bit stack pointer for the privilege level 0 stack.)]158 bull3
[2(SYSENTER)0( performs the following sequence of operations:)]141 norm3
[(Loads the segment selector from the )2(SYSENTER_CS_MSR)0( into the )2(CS)0( register.)]124 bull3
[(Loads the instruction pointer from the )2(SYSENTER_EIP_MSR)0( into the )2(EIP)0( register.)]107 bull3
(192)pageeven
restore showpage
%%Page: 193 193
%%BeginPageSetup
save
%%EndPageSetup
/193 pa
[(Adds 8 to the value in )2(SYSENTER_CS_MSR)0( and loads it into the )2(SS)0( register.)]681 bull3
[(Loads the stack pointer from the )2(SYSENTER_ESP_MSR)0( into the )2(ESP)0( register.)]664 bull3
[(Switches to privilege level 0.)]647 bull3
[(Clears the )2(VM)0( flag in the )2(EFLAGS)0( register, if the flag is set.)]630 bull3
[(Begins executing the selected system procedure.)]613 bull3
[(In particular, note that this instruction des not save the values of )2(CS)0( or )2(\(E\)IP)0(. If you need to return)]596 norm1
[(to the calling code, you need to write your code to cater for this.)]585 norm2
[(For more information, see the Intel Architecture Software Developer's Manual, Volume 2.)]568 norm3
[{/section-B.4.315 xa}2(SYSEXIT)0(: Fast Return From System Call)](B.4.315)550 subh3
[2(SYSEXIT                       ; 0F 35                [P6,PRIV])]533 code3
[2(SYSEXIT)0( executes a fast return to privilege level 3 user code. This instruction is a companion)]516 norm1
[(instruction to the )2(SYSENTER)0( instruction, and can only be executed by privilege level 0 code.)]505 norm0
[(Various registers need to be set up before calling this instruction:)]494 norm2
[2(SYSENTER_CS_MSR)0( contains the 32-bit segment selector for the privilege level 0 code)]477 bull1
[(segment in which the processor is currently executing. \(This value is used to compute the)]466 bull0
[(segment selectors for the privilege level 3 code and stack segments.\))]455 bull2
[2(EDX)0( contains the 32-bit offset into the privilege level 3 code segment to the first instruction to be)]438 bull1
[(executed in the user code.)]427 bull2
[2(ECX)0( contains the 32-bit stack pointer for the privilege level 3 stack.)]410 bull3
[2(SYSEXIT)0( performs the following sequence of operations:)]393 norm3
[(Adds 16 to the value in )2(SYSENTER_CS_MSR)0( and loads the sum into the )2(CS)0( selector register.)]376 bull3
[(Loads the instruction pointer from the )2(EDX)0( register into the )2(EIP)0( register.)]359 bull3
[(Adds 24 to the value in )2(SYSENTER_CS_MSR)0( and loads the sum into the )2(SS)0( selector register.)]342 bull3
[(Loads the stack pointer from the )2(ECX)0( register into the )2(ESP)0( register.)]325 bull3
[(Switches to privilege level 3.)]308 bull3
[(Begins executing the user code at the )2(EIP)0( address.)]291 bull3
[(For more information on the use of the )2(SYSENTER)0( and )2(SYSEXIT)0( instructions, see the Intel)]274 norm1
[(Architecture Software Developer's Manual, Volume 2.)]263 norm2
[{/section-B.4.316 xa}2(SYSRET)0(: Return From Operating System)](B.4.316)245 subh3
[2(SYSRET                        ; 0F 07                [P6,AMD,PRIV])]228 code3
[2(SYSRET)0( is the return instruction used in conjunction with the )2(SYSCALL)0( instruction to provide fast)]211 norm1
[(entry/exit to an operating system.)]200 norm2
[(The )2(ECX)0( register, which points to the next sequential instruction after the corresponding)]183 bull1
[2(SYSCALL)0( instruction, is copied into the )2(EIP)0( register.)]172 bull2
[(Bits [63-48] of the )2(STAR)0( register specify the selector that is copied into the )2(CS)0( register.)]155 bull3
[(Bits [63-48]+1000b of the )2(STAR)0( register specify the selector that is copied into the )2(SS)0( register.)]138 bull3
[(Bits [1-0] of the )2(SS)0( register are set to 11b \(RPL of 3\) regardless of the value of bits [49-48] of)]121 bull1
[(the )2(STAR)0( register.)]110 bull2
(193)pageodd
restore showpage
%%Page: 194 194
%%BeginPageSetup
save
%%EndPageSetup
/194 pa
[(The )2(CS)0( and )2(SS)0( registers should not be modified by the operating system between the execution of)]681 norm1
[(the )2(SYSCALL)0( instruction and its corresponding )2(SYSRET)0( instruction.)]670 norm2
[(For more information, see the )2(SYSCALL and SYSRET Instruction Specification)]653 norm1
[(\(AMD document number 21086.pdf\).)]642 norm2
[{/section-B.4.317 xa}2(TEST)0(: Test Bits \(notional bitwise AND\))](B.4.317)624 subh3
[2(TEST r/m8,reg8                ; 84 /r                [8086] )]607 code1
[2(TEST r/m16,reg16              ; o16 85 /r            [8086] )]596 code0
[2(TEST r/m32,reg32              ; o32 85 /r            [386])]585 code2
[2(TEST r/m8,imm8                ; F6 /0 ib             [8086] )]568 code1
[2(TEST r/m16,imm16              ; o16 F7 /0 iw         [8086] )]557 code0
[2(TEST r/m32,imm32              ; o32 F7 /0 id         [386])]546 code2
[2(TEST AL,imm8                  ; A8 ib                [8086] )]529 code1
[2(TEST AX,imm16                 ; o16 A9 iw            [8086] )]518 code0
[2(TEST EAX,imm32                ; o32 A9 id            [386])]507 code2
[2(TEST)0( performs a `mental' bitwise AND of its two operands, and affects the flags as if the operation)]490 norm1
[(had taken place, but does not store the result of the operation anywhere.)]479 norm2
[{/section-B.4.318 xa}2(UCOMISD)0(: Unordered Scalar Double-Precision FP compare and set EFLAGS)](B.4.318)461 subh3
[2(UCOMISD xmm1,xmm2/m128        ; 66 0F 2E /r     [WILLAMETTE,SSE2])]444 code3
[2(UCOMISD)0( compares the low-order double-precision FP numbers in the two operands, and sets the)]427 norm1
[2(ZF)0(, )2(PF)0( and )2(CF)0( bits in the )2(EFLAGS)0( register. In addition, the )2(OF)0(, )2(SF)0( and )2(AF)0( bits in the )2(EFLAGS)]416 norm0
[(register are zeroed out. The unordered predicate \()2(ZF)0(, )2(PF)0( and )2(CF)0( all set\) is returned if either source)]405 norm0
[(operand is a )2(NaN)0( \()2(qNaN)0( or )2(sNaN)0(\).)]394 norm2
[{/section-B.4.319 xa}2(UCOMISS)0(: Unordered Scalar Single-Precision FP compare and set EFLAGS)](B.4.319)376 subh3
[2(UCOMISS xmm1,xmm2/m128        ; 0F 2E /r        [KATMAI,SSE])]359 code3
[2(UCOMISS)0( compares the low-order single-precision FP numbers in the two operands, and sets the)]342 norm1
[2(ZF)0(, )2(PF)0( and )2(CF)0( bits in the )2(EFLAGS)0( register. In addition, the )2(OF)0(, )2(SF)0( and )2(AF)0( bits in the )2(EFLAGS)]331 norm0
[(register are zeroed out. The unordered predicate \()2(ZF)0(, )2(PF)0( and )2(CF)0( all set\) is returned if either source)]320 norm0
[(operand is a )2(NaN)0( \()2(qNaN)0( or )2(sNaN)0(\).)]309 norm2
[{/section-B.4.320 xa}2(UD0)0(, )2(UD1)0(, )2(UD2)0(: Undefined Instruction)](B.4.320)291 subh3
[2(UD0                           ; 0F FF                [186,UNDOC] )]274 code1
[2(UD1                           ; 0F B9                [186,UNDOC] )]263 code0
[2(UD2                           ; 0F 0B                [186])]252 code2
[2(UDx)0( can be used to generate an invalid opcode exception, for testing purposes.)]235 norm3
[2(UD0)0( is specifically documented by AMD as being reserved for this purpose.)]218 norm3
[2(UD1)0( is documented by Intel as being available for this purpose.)]201 norm3
[2(UD2)0( is specifically documented by Intel as being reserved for this purpose. Intel document this as)]184 norm1
[(the preferred method of generating an invalid opcode exception.)]173 norm2
[(All these opcodes can be used to generate invalid opcode exceptions on all currently available)]156 norm1
[(processors.)]145 norm2
(194)pageeven
restore showpage
%%Page: 195 195
%%BeginPageSetup
save
%%EndPageSetup
/195 pa
[{/section-B.4.321 xa}2(UMOV)0(: User Move Data)](B.4.321)680 subh3
[2(UMOV r/m8,reg8                ; 0F 10 /r             [386,UNDOC] )]663 code1
[2(UMOV r/m16,reg16              ; o16 0F 11 /r         [386,UNDOC] )]652 code0
[2(UMOV r/m32,reg32              ; o32 0F 11 /r         [386,UNDOC])]641 code2
[2(UMOV reg8,r/m8                ; 0F 12 /r             [386,UNDOC] )]624 code1
[2(UMOV reg16,r/m16              ; o16 0F 13 /r         [386,UNDOC] )]613 code0
[2(UMOV reg32,r/m32              ; o32 0F 13 /r         [386,UNDOC])]602 code2
[(This undocumented instruction is used by in-circuit emulators to access user memory \(as opposed)]585 norm1
[(to host memory\). It is used just like an ordinary memory/register or register/register )2(MOV)]574 norm0
[(instruction, but accesses user space.)]563 norm2
[(This instruction is only available on some AMD and IBM 386 and 486 processors.)]546 norm3
[{/section-B.4.322 xa}2(UNPCKHPD)0(: Unpack and Interleave High Packed Double-Precision FP Values)](B.4.322)528 subh3
[2(UNPCKHPD xmm1,xmm2/m128       ; 66 0F 15 /r     [WILLAMETTE,SSE2])]511 code3
[2(UNPCKHPD)0( performs an interleaved unpack of the high-order data elements of the source and)]494 norm1
[(destination operands, saving the result in )2(xmm1)0(. It ignores the lower half of the sources.)]483 norm2
[(The operation of this instruction is:)]466 norm3
[2(   dst[63-0]   := dst[127-64]; )]449 code1
[2(   dst[127-64] := src[127-64].)]438 code2
[{/section-B.4.323 xa}2(UNPCKHPS)0(: Unpack and Interleave High Packed Single-Precision FP Values)](B.4.323)420 subh3
[2(UNPCKHPS xmm1,xmm2/m128       ; 0F 15 /r        [KATMAI,SSE])]403 code3
[2(UNPCKHPS)0( performs an interleaved unpack of the high-order data elements of the source and)]386 norm1
[(destination operands, saving the result in )2(xmm1)0(. It ignores the lower half of the sources.)]375 norm2
[(The operation of this instruction is:)]358 norm3
[2(   dst[31-0]   := dst[95-64]; )]341 code1
[2(   dst[63-32]  := src[95-64]; )]330 code0
[2(   dst[95-64]  := dst[127-96]; )]319 code0
[2(   dst[127-96] := src[127-96].)]308 code2
[{/section-B.4.324 xa}2(UNPCKLPD)0(: Unpack and Interleave Low Packed Double-Precision FP Data)](B.4.324)290 subh3
[2(UNPCKLPD xmm1,xmm2/m128       ; 66 0F 14 /r     [WILLAMETTE,SSE2])]273 code3
[2(UNPCKLPD)0( performs an interleaved unpack of the low-order data elements of the source and)]256 norm1
[(destination operands, saving the result in )2(xmm1)0(. It ignores the lower half of the sources.)]245 norm2
[(The operation of this instruction is:)]228 norm3
[2(   dst[63-0]   := dst[63-0]; )]211 code1
[2(   dst[127-64] := src[63-0].)]200 code2
[{/section-B.4.325 xa}2(UNPCKLPS)0(: Unpack and Interleave Low Packed Single-Precision FP Data)](B.4.325)182 subh3
[2(UNPCKLPS xmm1,xmm2/m128       ; 0F 14 /r        [KATMAI,SSE])]165 code3
[2(UNPCKLPS)0( performs an interleaved unpack of the low-order data elements of the source and)]148 norm1
[(destination operands, saving the result in )2(xmm1)0(. It ignores the lower half of the sources.)]137 norm2
[(The operation of this instruction is:)]120 norm3
(195)pageodd
restore showpage
%%Page: 196 196
%%BeginPageSetup
save
%%EndPageSetup
/196 pa
[2(   dst[31-0]   := dst[31-0]; )]681 code1
[2(   dst[63-32]  := src[31-0]; )]670 code0
[2(   dst[95-64]  := dst[63-32]; )]659 code0
[2(   dst[127-96] := src[63-32].)]648 code2
[{/section-B.4.326 xa}2(VERR)0(, )2(VERW)0(: Verify Segment Readability/Writability)](B.4.326)630 subh3
[2(VERR r/m16                    ; 0F 00 /4             [286,PRIV])]613 code3
[2(VERW r/m16                    ; 0F 00 /5             [286,PRIV])]596 code3
[2(VERR)0( sets the zero flag if the segment specified by the selector in its operand can be read from at)]579 bull1
[(the current privilege level. Otherwise it is cleared.)]568 bull2
[2(VERW)0( sets the zero flag if the segment can be written.)]551 bull3
[{/section-B.4.327 xa}2(WAIT)0(: Wait for Floating-Point Processor)](B.4.327)533 subh3
[2(WAIT                          ; 9B                   [8086] )]516 code1
[2(FWAIT                         ; 9B                   [8086])]505 code2
[2(WAIT)0(, on 8086 systems with a separate 8087 FPU, waits for the FPU to have finished any operation)]488 norm1
[(it is engaged in before continuing main processor operations, so that \(for example\) an FPU store to)]477 norm0
[(main memory can be guaranteed to have completed before the CPU tries to read the result back out.)]466 norm2
[(On higher processors, )2(WAIT)0( is unnecessary for this purpose, and it has the alternative purpose of)]449 norm1
[(ensuring that any pending unmasked FPU exceptions have happened before execution continues.)]438 norm2
[{/section-B.4.328 xa}2(WBINVD)0(: Write Back and Invalidate Cache)](B.4.328)420 subh3
[2(WBINVD                        ; 0F 09                [486])]403 code3
[2(WBINVD)0( invalidates and empties the processor's internal caches, and causes the processor to)]386 norm1
[(instruct external caches to do the same. It writes the contents of the caches back to memory first, so)]375 norm0
[(no data is lost. To flush the caches quickly without bothering to write the data back first, use )2(INVD)]364 norm0
[(\(){/section-B.4.125 xl}(section B.4.125){el}(\).)]353 norm2
[{/section-B.4.329 xa}2(WRMSR)0(: Write Model-Specific Registers)](B.4.329)335 subh3
[2(WRMSR                         ; 0F 30                [PENT])]318 code3
[2(WRMSR)0( writes the value in )2(EDX:EAX)0( to the processor Model-Specific Register \(MSR\) whose)]301 norm1
[(index is stored in )2(ECX)0(. See also )2(RDMSR)0( \(){/section-B.4.270 xl}(section B.4.270){el}(\).)]290 norm2
[{/section-B.4.330 xa}2(WRSHR)0(: Write SMM Header Pointer Register)](B.4.330)272 subh3
[2(WRSHR r/m32                   ; 0F 37 /0        [386,CYRIX,SMM])]255 code3
[2(WRSHR)0( loads the contents of either a 32-bit memory location or a 32-bit register into the SMM)]238 norm1
[(header pointer register.)]227 norm2
[(See also )2(RDSHR)0( \(){/section-B.4.272 xl}(section B.4.272){el}(\).)]210 norm3
[{/section-B.4.331 xa}2(XADD)0(: Exchange and Add)](B.4.331)192 subh3
[2(XADD r/m8,reg8                ; 0F C0 /r             [486] )]175 code1
[2(XADD r/m16,reg16              ; o16 0F C1 /r         [486] )]164 code0
[2(XADD r/m32,reg32              ; o32 0F C1 /r         [486])]153 code2
[2(XADD)0( exchanges the values in its two operands, and then adds them together and writes the result)]136 norm1
[(into the destination \(first\) operand. This instruction can be used with a )2(LOCK)0( prefix for)]125 norm0
[(multi-processor synchronisation purposes.)]114 norm2
(196)pageeven
restore showpage
%%Page: 197 197
%%BeginPageSetup
save
%%EndPageSetup
/197 pa
[{/section-B.4.332 xa}2(XBTS)0(: Extract Bit String)](B.4.332)680 subh3
[2(XBTS reg16,r/m16              ; o16 0F A6 /r         [386,UNDOC] )]663 code1
[2(XBTS reg32,r/m32              ; o32 0F A6 /r         [386,UNDOC])]652 code2
[(The implied operation of this instruction is:)]635 norm3
[2(XBTS r/m16,reg16,AX,CL )]618 code1
[2(XBTS r/m32,reg32,EAX,CL)]607 code2
[(Writes a bit string from the source operand to the destination. )2(CL)0( indicates the number of bits to be)]590 norm1
[(copied, and )2(\(E\)AX)0( indicates the low order bit offset in the source. The bits are written to the low)]579 norm0
[(order bits of the destination register. For example, if )2(CL)0( is set to 4 and )2(AX)0( \(for 16-bit code\) is set to)]568 norm0
[(5, bits 5-8 of )2(src)0( will be copied to bits 0-3 of )2(dst)0(. This instruction is very poorly documented,)]557 norm0
[(and I have been unable to find any official source of documentation on it.)]546 norm2
[2(XBTS)0( is supported only on the early Intel 386s, and conflicts with the opcodes for )2(CMPXCHG486)]529 norm1
[(\(on early Intel 486s\). NASM supports it only for completeness. Its counterpart is )2(IBTS)0( \(see ){/section-B.4.116 xl}(section){el}]518 norm0
[{/section-B.4.116 xl}(B.4.116){el}(\).)]507 norm2
[{/section-B.4.333 xa}2(XCHG)0(: Exchange)](B.4.333)489 subh3
[2(XCHG reg8,r/m8                ; 86 /r                [8086] )]472 code1
[2(XCHG reg16,r/m8               ; o16 87 /r            [8086] )]461 code0
[2(XCHG reg32,r/m32              ; o32 87 /r            [386])]450 code2
[2(XCHG r/m8,reg8                ; 86 /r                [8086] )]433 code1
[2(XCHG r/m16,reg16              ; o16 87 /r            [8086] )]422 code0
[2(XCHG r/m32,reg32              ; o32 87 /r            [386])]411 code2
[2(XCHG AX,reg16                 ; o16 90+r             [8086] )]394 code1
[2(XCHG EAX,reg32                ; o32 90+r             [386] )]383 code0
[2(XCHG reg16,AX                 ; o16 90+r             [8086] )]372 code0
[2(XCHG reg32,EAX                ; o32 90+r             [386])]361 code2
[2(XCHG)0( exchanges the values in its two operands. It can be used with a )2(LOCK)0( prefix for purposes of)]344 norm1
[(multi-processor synchronisation.)]333 norm2
[2(XCHG AX,AX)0( or )2(XCHG EAX,EAX)0( \(depending on the )2(BITS)0( setting\) generates the opcode )2(90h)0(,)]316 norm1
[(and so is a synonym for )2(NOP)0( \(){/section-B.4.190 xl}(section B.4.190){el}(\).)]305 norm2
[{/section-B.4.334 xa}2(XLATB)0(: Translate Byte in Lookup Table)](B.4.334)287 subh3
[2(XLAT                          ; D7                   [8086] )]270 code1
[2(XLATB                         ; D7                   [8086])]259 code2
[2(XLATB)0( adds the value in )2(AL)0(, treated as an unsigned byte, to )2(BX)0( or )2(EBX)0(, and loads the byte from the)]242 norm1
[(resulting address \(in the segment specified by )2(DS)0(\) back into )2(AL)0(.)]231 norm2
[(The base register used is )2(BX)0( if the address size is 16 bits, and )2(EBX)0( if it is 32 bits. If you need to use)]214 norm1
[(an address size not equal to the current )2(BITS)0( setting, you can use an explicit )2(a16)0( or )2(a32)0( prefix.)]203 norm2
[(The segment register used to load from )2([BX+AL])0( or )2([EBX+AL])0( can be overridden by using a)]186 norm1
[(segment register name as a prefix \(for example, )2(es xlatb)0(\).)]175 norm2
[{/section-B.4.335 xa}2(XOR)0(: Bitwise Exclusive OR)](B.4.335)157 subh3
[2(XOR r/m8,reg8                 ; 30 /r                [8086] )]140 code1
[2(XOR r/m16,reg16               ; o16 31 /r            [8086] )]129 code0
[2(XOR r/m32,reg32               ; o32 31 /r            [386])]118 code2
(197)pageodd
restore showpage
%%Page: 198 198
%%BeginPageSetup
save
%%EndPageSetup
/198 pa
[2(XOR reg8,r/m8                 ; 32 /r                [8086] )]681 code1
[2(XOR reg16,r/m16               ; o16 33 /r            [8086] )]670 code0
[2(XOR reg32,r/m32               ; o32 33 /r            [386])]659 code2
[2(XOR r/m8,imm8                 ; 80 /6 ib             [8086] )]642 code1
[2(XOR r/m16,imm16               ; o16 81 /6 iw         [8086] )]631 code0
[2(XOR r/m32,imm32               ; o32 81 /6 id         [386])]620 code2
[2(XOR r/m16,imm8                ; o16 83 /6 ib         [8086] )]603 code1
[2(XOR r/m32,imm8                ; o32 83 /6 ib         [386])]592 code2
[2(XOR AL,imm8                   ; 34 ib                [8086] )]575 code1
[2(XOR AX,imm16                  ; o16 35 iw            [8086] )]564 code0
[2(XOR EAX,imm32                 ; o32 35 id            [386])]553 code2
[2(XOR)0( performs a bitwise XOR operation between its two operands \(i.e. each bit of the result is 1 if)]536 norm1
[(and only if exactly one of the corresponding bits of the two inputs was 1\), and stores the result in)]525 norm0
[(the destination \(first\) operand.)]514 norm2
[(In the forms with an 8-bit immediate second operand and a longer first operand, the second operand)]497 norm1
[(is considered to be signed, and is sign-extended to the length of the first operand. In these cases, the)]486 norm0
[2(BYTE)0( qualifier is necessary to force NASM to generate this form of the instruction.)]475 norm2
[(The )2(MMX)0( instruction )2(PXOR)0( \(see ){/section-B.4.266 xl}(section B.4.266){el}(\) performs the same operation on the 64-bit )2(MMX)]458 norm1
[(registers.)]447 norm2
[{/section-B.4.336 xa}2(XORPD)0(: Bitwise Logical XOR of Double-Precision FP Values)](B.4.336)429 subh3
[2(XORPD xmm1,xmm2/m128          ; 66 0F 57 /r     [WILLAMETTE,SSE2])]412 code3
[2(XORPD)0( returns a bit-wise logical XOR between the source and destination operands, storing the)]395 norm1
[(result in the destination operand.)]384 norm2
[{/section-B.4.337 xa}2(XORPS)0(: Bitwise Logical XOR of Single-Precision FP Values)](B.4.337)366 subh3
[2(XORPS xmm1,xmm2/m128          ; 0F 57 /r        [KATMAI,SSE])]349 code3
[2(XORPS)0( returns a bit-wise logical XOR between the source and destination operands, storing the)]332 norm1
[(result in the destination operand.)]321 norm2
(198)pageeven
restore showpage
%%Page: 199 199
%%BeginPageSetup
save
%%EndPageSetup
/199 pa
[{/index xa}(Index)]644 chap3
[2(!=)0( operator)][{/52 pl}(52){el}]609 0 idx03
[2($$)0( token)][{/36 pl}(36,){el}( ){/78 pl}(78){el}]598 0 idx03
[2($)][]587 0 idx03
[(Here token)][{/36 pl}(36){el}]576 0 idx13
[(prefix)][{/31 pl}(31,){el}( ){/34 pl}(34,){el}( ){/80 pl}(80){el}]565 0 idx13
[2(%)0( operator)][{/36 pl}(36){el}]554 0 idx03
[2(%!)][{/63 pl}(63){el}]543 0 idx03
[2(%$)0( and )2(%$$)0( prefixes)][{/55 pl}(55,){el}( ){/56 pl}(56){el}]532 0 idx03
[2(%%)0( operator)][{/36 pl}(36,){el}( ){/46 pl}(46){el}]521 0 idx03
[2(%+)][{/43 pl}(43){el}]510 0 idx03
[2(%+1)0( and )2(%-1)0( syntax)][{/50 pl}(50){el}]499 0 idx03
[2(%0)0( parameter count)][{/47 pl}(47,){el}( ){/48 pl}(48){el}]488 0 idx03
[2(&)0( operator)][{/36 pl}(36){el}]477 0 idx03
[2(&&)0( operator)][{/52 pl}(52){el}]466 0 idx03
[2(*)0( operator)][{/36 pl}(36){el}]455 0 idx03
[2(+)0( modifier)][{/47 pl}(47){el}]444 0 idx03
[2(+)0( operator)][]433 0 idx03
[(binary)][{/36 pl}(36){el}]422 0 idx13
[(unary)][{/36 pl}(36){el}]411 0 idx13
[2(-)0( operator)][]400 0 idx03
[(binary)][{/36 pl}(36){el}]389 0 idx13
[(unary)][{/36 pl}(36){el}]378 0 idx13
[2(..@)0( symbol prefix)][{/39 pl}(39,){el}( ){/46 pl}(46){el}]367 0 idx03
[2(/)0( operator)][{/36 pl}(36){el}]356 0 idx03
[2(//)0( operator)][{/36 pl}(36){el}]345 0 idx03
[2(<)0( operator)][{/52 pl}(52){el}]334 0 idx03
[2(<<)0( operator)][{/36 pl}(36){el}]323 0 idx03
[2(<=)0( operator)][{/52 pl}(52){el}]312 0 idx03
[2(<>)0( operator)][{/52 pl}(52){el}]301 0 idx03
[2(=)0( operator)][{/52 pl}(52){el}]290 0 idx03
[2(==)0( operator)][{/52 pl}(52){el}]279 0 idx03
[2(>)0( operator)][{/52 pl}(52){el}]268 0 idx03
[2(>=)0( operator)][{/52 pl}(52){el}]257 0 idx03
[2(>>)0( operator)][{/36 pl}(36){el}]246 0 idx03
[2(?)0( MASM syntax)][{/32 pl}(32){el}]235 0 idx03
[2(^)0( operator)][{/36 pl}(36){el}]224 0 idx03
[2(^^)0( operator)][{/52 pl}(52){el}]213 0 idx03
[2(|)0( operator)][{/36 pl}(36){el}]202 0 idx03
[2(||)0( operator)][{/52 pl}(52){el}]191 0 idx03
[2(~)0( operator)][{/36 pl}(36){el}]180 0 idx03
[2(-a)0( option)][{/27 pl}(27,){el}( ){/108 pl}(108){el}]169 0 idx03
[2(a16)][{/102 pl}(102,){el}( ){/125 pl}(125,){el}( ){/148 pl}(148,){el}( ){/153 pl}(153,){el}( ){/160 pl}(160,){el}( ){/163 pl}(163,){el}( ){/174 pl}(174,){el}]158 0 idx01
[][{/181 pl}(181,){el}( ){/186 pl}(186,){el}( ){/190 pl}(190,){el}( ){/197 pl}(197){el}]147 0 idx02
[2(a32)][{/102 pl}(102,){el}( ){/125 pl}(125,){el}( ){/148 pl}(148,){el}( ){/153 pl}(153,){el}( ){/160 pl}(160,){el}( ){/163 pl}(163,){el}( ){/174 pl}(174,){el}]136 0 idx01
[][{/181 pl}(181,){el}( ){/186 pl}(186,){el}( ){/190 pl}(190,){el}( ){/197 pl}(197){el}]125 0 idx02
[2(a86)][{/20 pl}(20,){el}( ){/29 pl}(29,){el}( ){/30 pl}(30){el}]114 0 idx03
[2(AAA)][{/116 pl}(116){el}]103 0 idx03
[2(AAD)][{/116 pl}(116){el}]609 1 idx03
[2(AAM)][{/116 pl}(116){el}]598 1 idx03
[2(AAS)][{/116 pl}(116){el}]587 1 idx03
[2(ABSOLUTE)][{/66 pl}(66,){el}( ){/73 pl}(73){el}]576 1 idx03
[2(ADC)][{/116 pl}(116){el}]565 1 idx03
[2(ADD)][{/117 pl}(117){el}]554 1 idx03
[(addition)][{/36 pl}(36){el}]543 1 idx03
[2(ADDPD)][{/118 pl}(118){el}]532 1 idx03
[2(ADDPS)][{/118 pl}(118){el}]521 1 idx03
[(addressing, mixed-size)][{/101 pl}(101){el}]510 1 idx03
[(address-size prefixes)][{/31 pl}(31){el}]499 1 idx03
[2(ADDSD)][{/118 pl}(118){el}]488 1 idx03
[2(ADDSS)][{/118 pl}(118){el}]477 1 idx03
[(algebra)][{/34 pl}(34){el}]466 1 idx03
[2(ALIGN)][{/60 pl}(60,){el}( ){/70 pl}(70,){el}( ){/72 pl}(72){el}]455 1 idx03
[2(ALIGNB)][{/60 pl}(60){el}]444 1 idx03
[(alignment)][]433 1 idx03
[(in )2(bin)0( sections)][{/71 pl}(71){el}]422 1 idx13
[(in )2(elf)0( sections)][{/77 pl}(77){el}]411 1 idx13
[(in )2(obj)0( sections)][{/72 pl}(72){el}]400 1 idx13
[(in )2(win32)0( sections)][{/76 pl}(76){el}]389 1 idx13
[(of )2(elf)0( common variables)][{/79 pl}(79){el}]378 1 idx13
[2(ALINK)][{/82 pl}(82){el}]367 1 idx03
[2(alink.sourceforge.net)][{/82 pl}(82){el}]356 1 idx03
[2(alloc)][{/77 pl}(77){el}]345 1 idx03
[2(alt.lang.asm)][{/20 pl}(20,){el}( ){/21 pl}(21){el}]334 1 idx03
[(ambiguity)][{/30 pl}(30){el}]323 1 idx03
[2(AND)][{/118 pl}(118){el}]312 1 idx03
[2(ANDNPD)][{/119 pl}(119){el}]301 1 idx03
[2(ANDNPS)][{/119 pl}(119){el}]290 1 idx03
[2(ANDPD)][{/119 pl}(119){el}]279 1 idx03
[2(ANDPS)][{/120 pl}(120){el}]268 1 idx03
[2(a.out)][]257 1 idx03
[(BSD version)][{/79 pl}(79){el}]246 1 idx13
[(Linux version)][{/79 pl}(79){el}]235 1 idx13
[2(aout)][{/23 pl}(23,){el}( ){/79 pl}(79){el}]224 1 idx03
[2(aoutb)][{/79 pl}(79,){el}( ){/97 pl}(97){el}]213 1 idx03
[2(%arg)][{/61 pl}(61){el}]202 1 idx03
[2(arg)][{/90 pl}(90,){el}( ){/96 pl}(96){el}]191 1 idx03
[2(ARPL)][{/120 pl}(120){el}]180 1 idx03
[2(as86)][{/20 pl}(20,){el}( ){/23 pl}(23,){el}( ){/79 pl}(79){el}]169 1 idx03
[(assembler directives)][{/65 pl}(65){el}]158 1 idx03
[(assembly passes)][{/38 pl}(38){el}]147 1 idx03
[(assembly-time options)][{/26 pl}(26){el}]136 1 idx03
[2(%assign)][{/43 pl}(43){el}]125 1 idx03
[2(ASSUME)][{/30 pl}(30){el}]114 1 idx03
[2(AT)][{/60 pl}(60){el}]103 1 idx03
(199)pageodd
restore showpage
%%Page: 200 200
%%BeginPageSetup
save
%%EndPageSetup
/200 pa
[(Autoconf)][{/21 pl}(21){el}]681 0 idx03
[2(autoexec.bat)][{/21 pl}(21){el}]670 0 idx03
[2(auto-sync)][{/108 pl}(108){el}]659 0 idx03
[2(-b)][{/107 pl}(107){el}]648 0 idx03
[(bin)][{/23 pl}(23,){el}( ){/24 pl}(24,){el}( ){/70 pl}(70){el}]637 0 idx03
[(multisection)][{/71 pl}(71){el}]626 0 idx13
[(binary)][{/34 pl}(34){el}]615 0 idx03
[(binary files)][{/32 pl}(32){el}]604 0 idx03
[(16-bit mode, versus 32-bit mode)][{/65 pl}(65){el}]593 0 idx03
[(bit shift)][{/36 pl}(36){el}]582 0 idx03
[2(BITS)][{/65 pl}(65,){el}( ){/70 pl}(70){el}]571 0 idx03
[(bitwise AND)][{/36 pl}(36){el}]560 0 idx03
[(bitwise OR)][{/36 pl}(36){el}]549 0 idx03
[(bitwise XOR)][{/36 pl}(36){el}]538 0 idx03
[(block IFs)][{/56 pl}(56){el}]527 0 idx03
[(boot loader)][{/70 pl}(70){el}]516 0 idx03
[(boot sector)][{/104 pl}(104){el}]505 0 idx03
[(Borland)][]494 0 idx03
[(Pascal)][{/91 pl}(91){el}]483 0 idx13
[(Win32 compilers)][{/71 pl}(71){el}]472 0 idx13
[2(BOUND)][{/120 pl}(120){el}]461 0 idx03
[(braces)][]450 0 idx03
[(after )2(%)0( sign)][{/49 pl}(49){el}]439 0 idx13
[(around macro parameters)][{/45 pl}(45){el}]428 0 idx13
[(BSD)][{/97 pl}(97){el}]417 0 idx03
[2(BSF)][{/120 pl}(120){el}]406 0 idx03
[2(BSR)][{/120 pl}(120){el}]395 0 idx03
[2(.bss)][{/77 pl}(77,){el}( ){/79 pl}(79,){el}( ){/80 pl}(80){el}]384 0 idx03
[2(BSWAP)][{/120 pl}(120){el}]373 0 idx03
[2(BT)][{/121 pl}(121){el}]362 0 idx03
[2(BTC)][{/121 pl}(121){el}]351 0 idx03
[2(BTR)][{/121 pl}(121){el}]340 0 idx03
[2(BTS)][{/121 pl}(121){el}]329 0 idx03
[(bugs)][{/105 pl}(105){el}]318 0 idx03
[2(bugtracker)][{/105 pl}(105){el}]307 0 idx03
[2(BYTE)][{/104 pl}(104){el}]296 0 idx03
[(C calling convention)][{/87 pl}(87,){el}( ){/94 pl}(94){el}]285 0 idx03
[(C symbol names)][{/85 pl}(85){el}]274 0 idx03
[2(CALL)][{/121 pl}(121){el}]263 0 idx03
[2(CALL FAR)][{/37 pl}(37){el}]252 0 idx03
[(case sensitivity)][{/29 pl}(29,){el}( ){/41 pl}(41,){el}( ){/42 pl}(42,){el}( ){/43 pl}(43,){el}( ){/45 pl}(45,){el}( ){/52 pl}(52,){el}( ){/73 pl}(73){el}]241 0 idx03
[2(CBW)][{/122 pl}(122){el}]230 0 idx03
[2(CDQ)][{/122 pl}(122){el}]219 0 idx03
[(changing sections)][{/65 pl}(65){el}]208 0 idx03
[(character constant)][{/32 pl}(32,){el}( ){/35 pl}(35){el}]197 0 idx03
[(circular references)][{/41 pl}(41){el}]186 0 idx03
[2(CLASS)][{/72 pl}(72){el}]175 0 idx03
[2(CLC)][{/122 pl}(122){el}]164 0 idx03
[2(CLD)][{/122 pl}(122){el}]153 0 idx03
[2(%clear)][{/58 pl}(58){el}]142 0 idx03
[2(CLFLUSH)][{/122 pl}(122){el}]131 0 idx03
[2(CLI)][{/122 pl}(122){el}]120 0 idx03
[2(CLTS)][{/122 pl}(122){el}]109 0 idx03
[2(c16.mac)][{/90 pl}(90,){el}( ){/93 pl}(93){el}]681 1 idx03
[2(c32.mac)][{/96 pl}(96){el}]670 1 idx03
[2(CMC)][{/123 pl}(123){el}]659 1 idx03
[2(CMOVcc)][{/123 pl}(123){el}]648 1 idx03
[2(CMP)][{/123 pl}(123){el}]637 1 idx03
[2(CMPccPD)][{/123 pl}(123){el}]626 1 idx03
[2(CMPccPS)][{/124 pl}(124){el}]615 1 idx03
[2(CMPccSD)][{/125 pl}(125){el}]604 1 idx03
[2(CMPccSS)][{/126 pl}(126){el}]593 1 idx03
[2(CMPEQPD)][{/123 pl}(123){el}]582 1 idx03
[2(CMPEQPS)][{/124 pl}(124){el}]571 1 idx03
[2(CMPEQSD)][{/125 pl}(125){el}]560 1 idx03
[2(CMPEQSS)][{/126 pl}(126){el}]549 1 idx03
[2(CMPLEPD)][{/123 pl}(123){el}]538 1 idx03
[2(CMPLEPS)][{/124 pl}(124){el}]527 1 idx03
[2(CMPLESD)][{/125 pl}(125){el}]516 1 idx03
[2(CMPLESS)][{/126 pl}(126){el}]505 1 idx03
[2(CMPLTPD)][{/123 pl}(123){el}]494 1 idx03
[2(CMPLTPS)][{/124 pl}(124){el}]483 1 idx03
[2(CMPLTSD)][{/125 pl}(125){el}]472 1 idx03
[2(CMPLTSS)][{/126 pl}(126){el}]461 1 idx03
[2(CMPNEQPD)][{/123 pl}(123){el}]450 1 idx03
[2(CMPNEQPS)][{/124 pl}(124){el}]439 1 idx03
[2(CMPNEQSD)][{/125 pl}(125){el}]428 1 idx03
[2(CMPNEQSS)][{/126 pl}(126){el}]417 1 idx03
[2(CMPNLEPD)][{/123 pl}(123){el}]406 1 idx03
[2(CMPNLEPS)][{/124 pl}(124){el}]395 1 idx03
[2(CMPNLESD)][{/125 pl}(125){el}]384 1 idx03
[2(CMPNLESS)][{/126 pl}(126){el}]373 1 idx03
[2(CMPNLTPD)][{/123 pl}(123){el}]362 1 idx03
[2(CMPNLTPS)][{/124 pl}(124){el}]351 1 idx03
[2(CMPNLTSD)][{/125 pl}(125){el}]340 1 idx03
[2(CMPNLTSS)][{/126 pl}(126){el}]329 1 idx03
[2(CMPORDPD)][{/123 pl}(123){el}]318 1 idx03
[2(CMPORDPS)][{/124 pl}(124){el}]307 1 idx03
[2(CMPORDSD)][{/125 pl}(125){el}]296 1 idx03
[2(CMPORDSS)][{/126 pl}(126){el}]285 1 idx03
[2(CMPSB)][{/125 pl}(125){el}]274 1 idx03
[2(CMPSD)][{/125 pl}(125){el}]263 1 idx03
[2(CMPSW)][{/125 pl}(125){el}]252 1 idx03
[2(CMPUNORDPD)][{/123 pl}(123){el}]241 1 idx03
[2(CMPUNORDPS)][{/124 pl}(124){el}]230 1 idx03
[2(CMPUNORDSD)][{/125 pl}(125){el}]219 1 idx03
[2(CMPUNORDSS)][{/126 pl}(126){el}]208 1 idx03
[2(CMPXCHG)][{/126 pl}(126){el}]197 1 idx03
[2(CMPXCHG486)][{/126 pl}(126){el}]186 1 idx03
[2(CMPXCHG8B)][{/127 pl}(127){el}]175 1 idx03
[2(coff)][{/23 pl}(23,){el}( ){/77 pl}(77){el}]164 1 idx03
[(colon)][{/31 pl}(31){el}]153 1 idx03
[2(.COM)][{/70 pl}(70,){el}( ){/84 pl}(84){el}]142 1 idx03
[2(COMISD)][{/127 pl}(127){el}]131 1 idx03
[2(COMISS)][{/127 pl}(127){el}]120 1 idx03
[(command-line)][{/23 pl}(23,){el}( ){/70 pl}(70){el}]109 1 idx03
(200)pageeven
restore showpage
%%Page: 201 201
%%BeginPageSetup
save
%%EndPageSetup
/201 pa
[(commas in macro parameters)][{/47 pl}(47){el}]681 0 idx03
[2(COMMON)][{/68 pl}(68,){el}( ){/72 pl}(72){el}]670 0 idx03
[2(elf)0( extensions to)][{/79 pl}(79){el}]659 0 idx13
[2(obj)0( extensions to)][{/75 pl}(75){el}]648 0 idx13
[(Common Object File Format)][{/77 pl}(77){el}]637 0 idx03
[(common variables)][{/68 pl}(68){el}]626 0 idx03
[(alignment in )2(elf)][{/79 pl}(79){el}]615 0 idx13
[(element size)][{/75 pl}(75){el}]604 0 idx13
[2(comp.lang.asm.x86)][{/20 pl}(20,){el}( ){/21 pl}(21){el}]593 0 idx03
[2(comp.os.linux.announce)][{/21 pl}(21){el}]582 0 idx03
[2(comp.os.msdos.programmer)][{/85 pl}(85){el}]571 0 idx03
[(concatenating macro parameters)][{/49 pl}(49){el}]560 0 idx03
[(condition codes)][{/112 pl}(112){el}]549 0 idx03
[(condition codes as macro parameters)][{/50 pl}(50){el}]538 0 idx03
[(condition predicates)][{/124 pl}(124,){el}( ){/125 pl}(125,){el}( ){/126 pl}(126){el}]527 0 idx03
[(conditional assembly)][{/50 pl}(50){el}]516 0 idx03
[(conditional jump)][{/149 pl}(149){el}]505 0 idx03
[(conditional jumps)][{/104 pl}(104){el}]494 0 idx03
[(conditional-return macro)][{/50 pl}(50){el}]483 0 idx03
[2(configure)][{/21 pl}(21){el}]472 0 idx03
[(constants)][{/34 pl}(34){el}]461 0 idx03
[(context stack)][{/55 pl}(55,){el}( ){/56 pl}(56){el}]450 0 idx03
[(context-local labels)][{/55 pl}(55){el}]439 0 idx03
[(context-local single-line macros)][{/56 pl}(56){el}]428 0 idx03
[(control registers)][{/112 pl}(112){el}]417 0 idx03
[(counting macro parameters)][{/48 pl}(48){el}]406 0 idx03
[2(CPU)][{/68 pl}(68){el}]395 0 idx03
[2(CPUID)][{/35 pl}(35,){el}( ){/128 pl}(128){el}]384 0 idx03
[(creating contexts)][{/55 pl}(55){el}]373 0 idx03
[(critical expression)][{/32 pl}(32,){el}( ){/33 pl}(33,){el}( ){/38 pl}(38,){el}( ){/44 pl}(44,){el}( ){/67 pl}(67){el}]362 0 idx03
[2(CVTDQ2PD)][{/128 pl}(128){el}]351 0 idx03
[2(CVTDQ2PS)][{/128 pl}(128){el}]340 0 idx03
[2(CVTPD2DQ)][{/128 pl}(128){el}]329 0 idx03
[2(CVTPD2PI)][{/129 pl}(129){el}]318 0 idx03
[2(CVTPD2PS)][{/129 pl}(129){el}]307 0 idx03
[2(CVTPI2PD)][{/129 pl}(129){el}]296 0 idx03
[2(CVTPI2PS)][{/129 pl}(129){el}]285 0 idx03
[2(CVTPS2DQ)][{/129 pl}(129){el}]274 0 idx03
[2(CVTPS2PD)][{/130 pl}(130){el}]263 0 idx03
[2(CVTPS2PI)][{/130 pl}(130){el}]252 0 idx03
[2(CVTSD2SI)][{/130 pl}(130){el}]241 0 idx03
[2(CVTSD2SS)][{/130 pl}(130){el}]230 0 idx03
[2(CVTSI2SD)][{/130 pl}(130){el}]219 0 idx03
[2(CVTSI2SS)][{/131 pl}(131){el}]208 0 idx03
[2(CVTSS2SD)][{/131 pl}(131){el}]197 0 idx03
[2(CVTSS2SI)][{/131 pl}(131){el}]186 0 idx03
[2(CVTTPD2DQ)][{/131 pl}(131){el}]175 0 idx03
[2(CVTTPD2PI)][{/131 pl}(131){el}]164 0 idx03
[2(CVTTPS2DQ)][{/132 pl}(132){el}]153 0 idx03
[2(CVTTPS2PI)][{/132 pl}(132){el}]142 0 idx03
[2(CVTTSD2SI)][{/132 pl}(132){el}]131 0 idx03
[2(CVTTSS2SI)][{/132 pl}(132){el}]120 0 idx03
[2(CWD)][{/122 pl}(122){el}]109 0 idx03
[2(CWDE)][{/122 pl}(122){el}]681 1 idx03
[2(-D)0( option)][{/26 pl}(26){el}]670 1 idx03
[2(-d)0( option)][{/26 pl}(26){el}]659 1 idx03
[2(DAA)][{/132 pl}(132){el}]648 1 idx03
[2(DAS)][{/132 pl}(132){el}]637 1 idx03
[2(.data)][{/77 pl}(77,){el}( ){/79 pl}(79,){el}( ){/80 pl}(80){el}]626 1 idx03
[2(_DATA)][{/87 pl}(87){el}]615 1 idx03
[2(data)][{/78 pl}(78,){el}( ){/80 pl}(80){el}]604 1 idx03
[(data structure)][{/89 pl}(89,){el}( ){/96 pl}(96){el}]593 1 idx03
[2(DB)][{/32 pl}(32,){el}( ){/35 pl}(35){el}]582 1 idx03
[2(dbg)][{/81 pl}(81){el}]571 1 idx03
[2(DD)][{/32 pl}(32,){el}( ){/35 pl}(35){el}]560 1 idx03
[(debug information)][{/24 pl}(24){el}]549 1 idx03
[(debug information format)][{/24 pl}(24){el}]538 1 idx03
[(debug registers)][{/112 pl}(112){el}]527 1 idx03
[2(DEC)][{/133 pl}(133){el}]516 1 idx03
[(declaring structures)][{/59 pl}(59){el}]505 1 idx03
[(default macro parameters)][{/47 pl}(47){el}]494 1 idx03
[(default name)][{/70 pl}(70){el}]483 1 idx03
[(default-)2(WRT)0( mechanism)][{/75 pl}(75){el}]472 1 idx03
[2(%define)][{/26 pl}(26,){el}( ){/41 pl}(41){el}]461 1 idx03
[(defining sections)][{/65 pl}(65){el}]450 1 idx03
[(design goals)][{/29 pl}(29){el}]439 1 idx03
[(DevPac)][{/32 pl}(32,){el}( ){/39 pl}(39){el}]428 1 idx03
[(disabling listing expansion)][{/50 pl}(50){el}]417 1 idx03
[2(DIV)][{/133 pl}(133){el}]406 1 idx03
[(division)][{/36 pl}(36){el}]395 1 idx03
[2(DIVPD)][{/133 pl}(133){el}]384 1 idx03
[2(DIVPS)][{/134 pl}(134){el}]373 1 idx03
[2(DIVSD)][{/134 pl}(134){el}]362 1 idx03
[2(DIVSS)][{/134 pl}(134){el}]351 1 idx03
[(DJGPP)][{/77 pl}(77,){el}( ){/94 pl}(94){el}]340 1 idx03
[2(djlink)][{/82 pl}(82){el}]329 1 idx03
[(DLL symbols)][]318 1 idx03
[(exporting)][{/74 pl}(74){el}]307 1 idx13
[(importing)][{/74 pl}(74){el}]296 1 idx13
[(DOS)][{/21 pl}(21,){el}( ){/25 pl}(25){el}]285 1 idx03
[(DOS archive)][{/21 pl}(21){el}]274 1 idx03
[(DOS source archive)][{/21 pl}(21){el}]263 1 idx03
[2(DQ)][{/32 pl}(32,){el}( ){/35 pl}(35){el}]252 1 idx03
[2(.drectve)][{/76 pl}(76){el}]241 1 idx03
[2(DT)][{/32 pl}(32,){el}( ){/35 pl}(35){el}]230 1 idx03
[2(DUP)][{/30 pl}(30,){el}( ){/33 pl}(33){el}]219 1 idx03
[2(DW)][{/32 pl}(32,){el}( ){/35 pl}(35){el}]208 1 idx03
[2(DWORD)][{/32 pl}(32){el}]197 1 idx03
[2(-E)0( option)][{/25 pl}(25){el}]186 1 idx03
[2(-e)0( option)][{/26 pl}(26,){el}( ){/109 pl}(109){el}]175 1 idx03
[(effective addresses)][{/31 pl}(31,){el}( ){/33 pl}(33,){el}( ){/38 pl}(38,){el}( ){/114 pl}(114){el}]164 1 idx03
[(element size, in common variables)][{/75 pl}(75){el}]153 1 idx03
[(ELF)][{/23 pl}(23,){el}( ){/77 pl}(77){el}]142 1 idx03
[(shared libraries)][{/77 pl}(77){el}]131 1 idx13
[(16-bit code and)][{/79 pl}(79){el}]120 1 idx13
[2(%elif)][{/50 pl}(50,){el}( ){/52 pl}(52){el}]109 1 idx03
(201)pageodd
restore showpage
%%Page: 202 202
%%BeginPageSetup
save
%%EndPageSetup
/202 pa
[2(%elifctx)][{/51 pl}(51){el}]681 0 idx03
[2(%elifdef)][{/51 pl}(51){el}]670 0 idx03
[2(%elifid)][{/53 pl}(53){el}]659 0 idx03
[2(%elifidn)][{/52 pl}(52){el}]648 0 idx03
[2(%elifidni)][{/52 pl}(52){el}]637 0 idx03
[2(%elifmacro)][{/51 pl}(51){el}]626 0 idx03
[2(%elifnctx)][{/51 pl}(51){el}]615 0 idx03
[2(%elifndef)][{/51 pl}(51){el}]604 0 idx03
[2(%elifnid)][{/53 pl}(53){el}]593 0 idx03
[2(%elifnidn)][{/52 pl}(52){el}]582 0 idx03
[2(%elifnidni)][{/52 pl}(52){el}]571 0 idx03
[2(%elifnmacro)][{/51 pl}(51){el}]560 0 idx03
[2(%elifnnum)][{/53 pl}(53){el}]549 0 idx03
[2(%elifnstr)][{/53 pl}(53){el}]538 0 idx03
[2(%elifnum)][{/53 pl}(53){el}]527 0 idx03
[2(%elifstr)][{/53 pl}(53){el}]516 0 idx03
[2(%else)][{/50 pl}(50){el}]505 0 idx03
[(e-mail)][{/21 pl}(21){el}]494 0 idx03
[2(EMMS)][{/134 pl}(134){el}]483 0 idx03
[2(endproc)][{/90 pl}(90,){el}( ){/96 pl}(96){el}]472 0 idx03
[2(%endrep)][{/54 pl}(54){el}]461 0 idx03
[2(ENDSTRUC)][{/59 pl}(59,){el}( ){/67 pl}(67){el}]450 0 idx03
[2(ENTER)][{/134 pl}(134){el}]439 0 idx03
[(environment)][{/28 pl}(28){el}]428 0 idx03
[2(EQU)][{/32 pl}(32,){el}( ){/33 pl}(33,){el}( ){/38 pl}(38){el}]417 0 idx03
[2(%error)][{/53 pl}(53){el}]406 0 idx03
[(error messages)][{/25 pl}(25){el}]395 0 idx03
[(error reporting format)][{/25 pl}(25){el}]384 0 idx03
[2(EVEN)][{/60 pl}(60){el}]373 0 idx03
[2(.EXE)][{/71 pl}(71,){el}( ){/82 pl}(82){el}]362 0 idx03
[2(EXE_begin)][{/83 pl}(83){el}]351 0 idx03
[2(EXE2BIN)][{/85 pl}(85){el}]340 0 idx03
[2(exebin.mac)][{/83 pl}(83){el}]329 0 idx03
[2(exec)][{/77 pl}(77){el}]318 0 idx03
[(Executable and Linkable Format)][{/77 pl}(77){el}]307 0 idx03
[2(EXE_end)][{/83 pl}(83){el}]296 0 idx03
[2(EXE_stack)][{/83 pl}(83){el}]285 0 idx03
[2(%exitrep)][{/54 pl}(54){el}]274 0 idx03
[2(EXPORT)][{/74 pl}(74){el}]263 0 idx03
[2(export)][{/80 pl}(80){el}]252 0 idx03
[(exporting symbols)][{/68 pl}(68){el}]241 0 idx03
[(expressions)][{/26 pl}(26,){el}( ){/36 pl}(36){el}]230 0 idx03
[(extension)][{/23 pl}(23,){el}( ){/70 pl}(70){el}]219 0 idx03
[2(EXTERN)][{/67 pl}(67){el}]208 0 idx03
[2(obj)0( extensions to)][{/75 pl}(75){el}]197 0 idx13
[2(rdf)0( extensions to)][{/81 pl}(81){el}]186 0 idx13
[2(-F)0( option)][{/24 pl}(24){el}]175 0 idx03
[2(-f)0( option)][{/24 pl}(24,){el}( ){/70 pl}(70){el}]164 0 idx03
[2(FABS)][{/135 pl}(135){el}]153 0 idx03
[2(FADD)][{/135 pl}(135){el}]142 0 idx03
[2(FADDP)][{/135 pl}(135){el}]131 0 idx03
[(far call)][{/30 pl}(30,){el}( ){/122 pl}(122){el}]120 0 idx03
[(far common variables)][{/75 pl}(75){el}]109 0 idx03
[(far jump)][{/150 pl}(150){el}]681 1 idx03
[(far pointer)][{/37 pl}(37){el}]670 1 idx03
[2(FARCODE)][{/90 pl}(90,){el}( ){/93 pl}(93){el}]659 1 idx03
[2(FBLD)][{/135 pl}(135){el}]648 1 idx03
[2(FBSTP)][{/135 pl}(135){el}]637 1 idx03
[2(FCHS)][{/136 pl}(136){el}]626 1 idx03
[2(FCLEX)][{/136 pl}(136){el}]615 1 idx03
[2(FCMOVcc)][{/136 pl}(136){el}]604 1 idx03
[2(FCOM)][{/137 pl}(137){el}]593 1 idx03
[2(FCOMI)][{/137 pl}(137){el}]582 1 idx03
[2(FCOMIP)][{/137 pl}(137){el}]571 1 idx03
[2(FCOMP)][{/137 pl}(137){el}]560 1 idx03
[2(FCOMPP)][{/137 pl}(137){el}]549 1 idx03
[2(FCOS)][{/137 pl}(137){el}]538 1 idx03
[2(FDECSTP)][{/137 pl}(137){el}]527 1 idx03
[2(FDIV)][{/138 pl}(138){el}]516 1 idx03
[2(FDIVP)][{/138 pl}(138){el}]505 1 idx03
[2(FDIVR)][{/138 pl}(138){el}]494 1 idx03
[2(FDIVRP)][{/138 pl}(138){el}]483 1 idx03
[2(FEMMS)][{/138 pl}(138){el}]472 1 idx03
[2(FFREE)][{/138 pl}(138){el}]461 1 idx03
[2(FIADD)][{/139 pl}(139){el}]450 1 idx03
[2(FICOM)][{/139 pl}(139){el}]439 1 idx03
[2(FICOMP)][{/139 pl}(139){el}]428 1 idx03
[2(FIDIV)][{/139 pl}(139){el}]417 1 idx03
[2(FIDIVR)][{/139 pl}(139){el}]406 1 idx03
[2(FILD)][{/139 pl}(139){el}]395 1 idx03
[2(__FILE__)][{/58 pl}(58){el}]384 1 idx03
[2(FIMUL)][{/139 pl}(139){el}]373 1 idx03
[2(FINCSTP)][{/139 pl}(139){el}]362 1 idx03
[2(FINIT)][{/140 pl}(140){el}]351 1 idx03
[2(FIST)][{/139 pl}(139){el}]340 1 idx03
[2(FISTP)][{/139 pl}(139){el}]329 1 idx03
[2(FISUB)][{/140 pl}(140){el}]318 1 idx03
[2(FLAT)][{/73 pl}(73){el}]307 1 idx03
[(flat memory model)][{/94 pl}(94){el}]296 1 idx03
[(flat-form binary)][{/70 pl}(70){el}]285 1 idx03
[2(FLD)][{/140 pl}(140){el}]274 1 idx03
[2(FLDCW)][{/140 pl}(140){el}]263 1 idx03
[2(FLDENV)][{/141 pl}(141){el}]252 1 idx03
[2(FLDxx)][{/140 pl}(140){el}]241 1 idx03
[(floating-point)][{/30 pl}(30,){el}( ){/31 pl}(31,){el}( ){/32 pl}(32,){el}( ){/35 pl}(35){el}]230 1 idx03
[(constants)][{/35 pl}(35){el}]219 1 idx13
[(registers)][{/112 pl}(112){el}]208 1 idx13
[2(FMUL)][{/141 pl}(141){el}]197 1 idx03
[2(FMULP)][{/141 pl}(141){el}]186 1 idx03
[2(FNINIT)][{/140 pl}(140){el}]175 1 idx03
[2(FNOP)][{/141 pl}(141){el}]164 1 idx03
[2(follows=)][{/71 pl}(71){el}]153 1 idx03
[(format-specific directives)][{/65 pl}(65){el}]142 1 idx03
[(forward references)][{/38 pl}(38){el}]131 1 idx03
[2(FPATAN)][{/141 pl}(141){el}]120 1 idx03
[2(FPREM)][{/141 pl}(141){el}]109 1 idx03
(202)pageeven
restore showpage
%%Page: 203 203
%%BeginPageSetup
save
%%EndPageSetup
/203 pa
[2(FPREM1)][{/141 pl}(141){el}]681 0 idx03
[2(FPTAN)][{/141 pl}(141){el}]670 0 idx03
[(frame pointer)][{/87 pl}(87,){el}( ){/91 pl}(91,){el}( ){/94 pl}(94){el}]659 0 idx03
[(FreeBSD)][{/79 pl}(79,){el}( ){/97 pl}(97){el}]648 0 idx03
[(FreeLink)][{/82 pl}(82){el}]637 0 idx03
[2(FRNDINT)][{/142 pl}(142){el}]626 0 idx03
[2(FRSTOR)][{/142 pl}(142){el}]615 0 idx03
[2(FSAVE)][{/142 pl}(142){el}]604 0 idx03
[2(FSCALE)][{/142 pl}(142){el}]593 0 idx03
[2(FSETPM)][{/142 pl}(142){el}]582 0 idx03
[2(FSIN)][{/142 pl}(142){el}]571 0 idx03
[2(FSINCOS)][{/142 pl}(142){el}]560 0 idx03
[2(FSQRT)][{/142 pl}(142){el}]549 0 idx03
[2(FST)][{/143 pl}(143){el}]538 0 idx03
[2(FSTCW)][{/143 pl}(143){el}]527 0 idx03
[2(FSTENV)][{/143 pl}(143){el}]516 0 idx03
[2(FSTP)][{/143 pl}(143){el}]505 0 idx03
[2(FSTSW)][{/143 pl}(143){el}]494 0 idx03
[2(FSUB)][{/143 pl}(143){el}]483 0 idx03
[2(FSUBP)][{/143 pl}(143){el}]472 0 idx03
[2(FSUBR)][{/143 pl}(143){el}]461 0 idx03
[2(FSUBRP)][{/143 pl}(143){el}]450 0 idx03
[2(ftp.kernel.org)][{/21 pl}(21){el}]439 0 idx03
[2(ftp.simtel.net)][{/82 pl}(82){el}]428 0 idx03
[2(FTST)][{/144 pl}(144){el}]417 0 idx03
[2(FUCOMxx)][{/144 pl}(144){el}]406 0 idx03
[2(function)][{/78 pl}(78,){el}( ){/80 pl}(80){el}]395 0 idx03
[(functions)][]384 0 idx03
[(C calling convention)][{/87 pl}(87,){el}( ){/94 pl}(94){el}]373 0 idx13
[(Pascal calling convention)][{/91 pl}(91){el}]362 0 idx13
[2(FXAM)][{/145 pl}(145){el}]351 0 idx03
[2(FXCH)][{/145 pl}(145){el}]340 0 idx03
[2(FxDISI)][{/137 pl}(137){el}]329 0 idx03
[2(FxENI)][{/137 pl}(137){el}]318 0 idx03
[2(F2XM1)][{/135 pl}(135){el}]307 0 idx03
[2(FXRSTOR)][{/145 pl}(145){el}]296 0 idx03
[2(FXSAVE)][{/145 pl}(145){el}]285 0 idx03
[2(FXTRACT)][{/145 pl}(145){el}]274 0 idx03
[2(FYL2X)][{/146 pl}(146){el}]263 0 idx03
[2(FYL2XP1)][{/146 pl}(146){el}]252 0 idx03
[2(-g)0( option)][{/24 pl}(24){el}]241 0 idx03
[2(gas)][{/20 pl}(20){el}]230 0 idx03
[2(gcc)][{/20 pl}(20){el}]219 0 idx03
[(general purpose register)][{/110 pl}(110){el}]208 0 idx03
[2(GLOBAL)][{/68 pl}(68){el}]197 0 idx03
[2(aoutb)0( extensions to)][{/78 pl}(78){el}]186 0 idx13
[2(elf)0( extensions to)][{/78 pl}(78){el}]175 0 idx13
[2(rdf)0( extensions to)][{/80 pl}(80){el}]164 0 idx13
[(global offset table)][{/97 pl}(97){el}]153 0 idx03
[2(_GLOBAL_OFFSET_TABLE_)][{/78 pl}(78){el}]142 0 idx03
[2(gnu-elf-extensions)][{/28 pl}(28){el}]131 0 idx03
[2(..got)][{/78 pl}(78){el}]120 0 idx03
[2(GOT)0( relocations)][{/99 pl}(99){el}]109 0 idx03
[(GOT)][{/78 pl}(78,){el}( ){/97 pl}(97){el}]681 1 idx03
[2(..gotoff)][{/78 pl}(78){el}]670 1 idx03
[2(GOTOFF)0( relocations)][{/98 pl}(98){el}]659 1 idx03
[2(..gotpc)][{/78 pl}(78){el}]648 1 idx03
[2(GOTPC)0( relocations)][{/98 pl}(98){el}]637 1 idx03
[(graphics)][{/32 pl}(32){el}]626 1 idx03
[(greedy macro parameters)][{/46 pl}(46){el}]615 1 idx03
[2(GROUP)][{/73 pl}(73){el}]604 1 idx03
[(groups)][{/37 pl}(37){el}]593 1 idx03
[2(-h)][{/107 pl}(107){el}]582 1 idx03
[(hex)][{/34 pl}(34){el}]571 1 idx03
[2(HLT)][{/146 pl}(146){el}]560 1 idx03
[(hybrid syntaxes)][{/30 pl}(30){el}]549 1 idx03
[2(-I)0( option)][{/25 pl}(25){el}]538 1 idx03
[2(-i)0( option)][{/25 pl}(25,){el}( ){/108 pl}(108){el}]527 1 idx03
[2(%iassign)][{/43 pl}(43){el}]516 1 idx03
[2(ibiblio.org)][{/21 pl}(21){el}]505 1 idx03
[2(IBTS)][{/146 pl}(146){el}]494 1 idx03
[2(ICEBP)][{/148 pl}(148){el}]483 1 idx03
[2(%idefine)][{/41 pl}(41){el}]472 1 idx03
[2(IDIV)][{/146 pl}(146){el}]461 1 idx03
[2(IEND)][{/60 pl}(60){el}]450 1 idx03
[2(%if)][{/50 pl}(50,){el}( ){/52 pl}(52){el}]439 1 idx03
[2(%ifctx)][{/51 pl}(51,){el}( ){/56 pl}(56){el}]428 1 idx03
[2(%ifdef)][{/51 pl}(51){el}]417 1 idx03
[2(%ifid)][{/52 pl}(52){el}]406 1 idx03
[2(%ifidn)][{/52 pl}(52){el}]395 1 idx03
[2(%ifidni)][{/52 pl}(52){el}]384 1 idx03
[2(ifmacro)][{/51 pl}(51){el}]373 1 idx03
[2(%ifnctx)][{/51 pl}(51){el}]362 1 idx03
[2(%ifndef)][{/51 pl}(51){el}]351 1 idx03
[2(%ifnid)][{/53 pl}(53){el}]340 1 idx03
[2(%ifnidn)][{/52 pl}(52){el}]329 1 idx03
[2(%ifnidni)][{/52 pl}(52){el}]318 1 idx03
[2(%ifnmacro)][{/51 pl}(51){el}]307 1 idx03
[2(%ifnnum)][{/53 pl}(53){el}]296 1 idx03
[2(%ifnstr)][{/53 pl}(53){el}]285 1 idx03
[2(%ifnum)][{/52 pl}(52){el}]274 1 idx03
[2(%ifstr)][{/52 pl}(52){el}]263 1 idx03
[2(%imacro)][{/44 pl}(44){el}]252 1 idx03
[(immediate operand)][{/110 pl}(110){el}]241 1 idx03
[2(IMPORT)][{/74 pl}(74){el}]230 1 idx03
[(import library)][{/74 pl}(74){el}]219 1 idx03
[(importing symbols)][{/67 pl}(67){el}]208 1 idx03
[2(IMUL)][{/147 pl}(147){el}]197 1 idx03
[2(IN)][{/147 pl}(147){el}]186 1 idx03
[2(INC)][{/147 pl}(147){el}]175 1 idx03
[2(INCBIN)][{/32 pl}(32,){el}( ){/35 pl}(35){el}]164 1 idx03
[2(incbin)][{/25 pl}(25){el}]153 1 idx03
[2(%include)][{/25 pl}(25,){el}( ){/26 pl}(26,){el}( ){/54 pl}(54){el}]142 1 idx03
[(include search path)][{/26 pl}(26){el}]131 1 idx03
[(including other files)][{/54 pl}(54){el}]120 1 idx03
[(inefficient code)][{/104 pl}(104){el}]109 1 idx03
(203)pageodd
restore showpage
%%Page: 204 204
%%BeginPageSetup
save
%%EndPageSetup
/204 pa
[(infinite loop)][{/36 pl}(36){el}]681 0 idx03
[(informational section)][{/76 pl}(76){el}]670 0 idx03
[2(INSB)][{/148 pl}(148){el}]659 0 idx03
[2(INSD)][{/148 pl}(148){el}]648 0 idx03
[2(INSTALL)][{/22 pl}(22){el}]637 0 idx03
[(installing)][{/21 pl}(21){el}]626 0 idx03
[(instances of structures)][{/60 pl}(60){el}]615 0 idx03
[2(INSW)][{/148 pl}(148){el}]604 0 idx03
[2(INT)][{/148 pl}(148){el}]593 0 idx03
[2(INT01)][{/148 pl}(148){el}]582 0 idx03
[2(INT1)][{/148 pl}(148){el}]571 0 idx03
[2(INT3)][{/148 pl}(148){el}]560 0 idx03
[(integer overflow)][{/36 pl}(36){el}]549 0 idx03
[(Intel number formats)][{/36 pl}(36){el}]538 0 idx03
[2(INTO)][{/149 pl}(149){el}]527 0 idx03
[2(INVD)][{/149 pl}(149){el}]516 0 idx03
[2(INVLPG)][{/149 pl}(149){el}]505 0 idx03
[2(IRET)][{/149 pl}(149){el}]494 0 idx03
[2(IRETD)][{/149 pl}(149){el}]483 0 idx03
[2(IRETW)][{/149 pl}(149){el}]472 0 idx03
[2(ISTRUC)][{/60 pl}(60){el}]461 0 idx03
[(iterating over macro parameters)][{/48 pl}(48){el}]450 0 idx03
[2(Jcc)][{/149 pl}(149){el}]439 0 idx03
[2(Jcc NEAR)][{/104 pl}(104){el}]428 0 idx03
[2(JCXZ)][{/149 pl}(149){el}]417 0 idx03
[2(JECXZ)][{/149 pl}(149){el}]406 0 idx03
[2(JMP)][{/150 pl}(150){el}]395 0 idx03
[2(JMP DWORD)][{/101 pl}(101){el}]384 0 idx03
[(jumps, mixed-size)][{/101 pl}(101){el}]373 0 idx03
[2(-k)][{/109 pl}(109){el}]362 0 idx03
[2(-l)0( option)][{/24 pl}(24){el}]351 0 idx03
[(label prefix)][{/39 pl}(39){el}]340 0 idx03
[2(LAHF)][{/150 pl}(150){el}]329 0 idx03
[2(LAR)][{/150 pl}(150){el}]318 0 idx03
[2(ld86)][{/79 pl}(79){el}]307 0 idx03
[2(LDMXCSR)][{/151 pl}(151){el}]296 0 idx03
[2(LDS)][{/151 pl}(151){el}]285 0 idx03
[2(LEA)][{/151 pl}(151){el}]274 0 idx03
[2(LEAVE)][{/151 pl}(151){el}]263 0 idx03
[2(LES)][{/151 pl}(151){el}]252 0 idx03
[2(LFENCE)][{/152 pl}(152){el}]241 0 idx03
[2(LFS)][{/151 pl}(151){el}]230 0 idx03
[2(LGDT)][{/152 pl}(152){el}]219 0 idx03
[2(LGS)][{/151 pl}(151){el}]208 0 idx03
[2(LIBRARY)][{/80 pl}(80){el}]197 0 idx03
[(licence)][{/20 pl}(20){el}]186 0 idx03
[2(LIDT)][{/152 pl}(152){el}]175 0 idx03
[2(%line)][{/63 pl}(63){el}]164 0 idx03
[2(__LINE__)][{/58 pl}(58){el}]153 0 idx03
[(linker, free)][{/82 pl}(82){el}]142 0 idx03
[(Linux)][]681 1 idx03
[2(a.out)][{/79 pl}(79){el}]670 1 idx13
[2(as86)][{/79 pl}(79){el}]659 1 idx13
[(ELF)][{/77 pl}(77){el}]648 1 idx13
[(listing file)][{/24 pl}(24){el}]637 1 idx03
[(little-endian)][{/35 pl}(35){el}]626 1 idx03
[2(LLDT)][{/152 pl}(152){el}]615 1 idx03
[2(LMSW)][{/152 pl}(152){el}]604 1 idx03
[2(LOADALL)][{/152 pl}(152){el}]593 1 idx03
[2(LOADALL286)][{/152 pl}(152){el}]582 1 idx03
[2(%local)][{/62 pl}(62){el}]571 1 idx03
[(local labels)][{/39 pl}(39){el}]560 1 idx03
[2(LODSB)][{/153 pl}(153){el}]549 1 idx03
[2(LODSD)][{/153 pl}(153){el}]538 1 idx03
[2(LODSW)][{/153 pl}(153){el}]527 1 idx03
[(logical AND)][{/52 pl}(52){el}]516 1 idx03
[(logical OR)][{/52 pl}(52){el}]505 1 idx03
[(logical XOR)][{/52 pl}(52){el}]494 1 idx03
[2(LOOP)][{/153 pl}(153){el}]483 1 idx03
[2(LOOPE)][{/153 pl}(153){el}]472 1 idx03
[2(LOOPNE)][{/153 pl}(153){el}]461 1 idx03
[2(LOOPNZ)][{/153 pl}(153){el}]450 1 idx03
[2(LOOPZ)][{/153 pl}(153){el}]439 1 idx03
[2(LSL)][{/153 pl}(153){el}]428 1 idx03
[2(LSS)][{/151 pl}(151){el}]417 1 idx03
[2(LTR)][{/154 pl}(154){el}]406 1 idx03
[2(-M)0( option)][{/24 pl}(24){el}]395 1 idx03
[2(%macro)][{/44 pl}(44){el}]384 1 idx03
[(macro library)][{/25 pl}(25){el}]373 1 idx03
[(macro processor)][{/41 pl}(41){el}]362 1 idx03
[(macro-local labels)][{/46 pl}(46){el}]351 1 idx03
[2(macro-params)][{/28 pl}(28){el}]340 1 idx03
[(macros)][{/33 pl}(33){el}]329 1 idx03
[2(macro-selfref)][{/28 pl}(28){el}]318 1 idx03
[2(make)][{/21 pl}(21){el}]307 1 idx03
[(makefile dependencies)][{/24 pl}(24){el}]296 1 idx03
[(makefiles)][{/21 pl}(21){el}]285 1 idx03
[2(Makefile.unx)][{/22 pl}(22){el}]274 1 idx03
[(man pages)][{/21 pl}(21){el}]263 1 idx03
[(map files)][{/71 pl}(71){el}]252 1 idx03
[2(MASKMOVDQU)][{/154 pl}(154){el}]241 1 idx03
[2(MASKMOVQ)][{/154 pl}(154){el}]230 1 idx03
[2(MASM)][{/20 pl}(20){el}]219 1 idx03
[(MASM)][{/29 pl}(29,){el}( ){/33 pl}(33,){el}( ){/71 pl}(71){el}]208 1 idx03
[2(MAXPD)][{/154 pl}(154){el}]197 1 idx03
[2(MAXPS)][{/154 pl}(154){el}]186 1 idx03
[2(MAXSD)][{/154 pl}(154){el}]175 1 idx03
[2(MAXSS)][{/154 pl}(154){el}]164 1 idx03
[(memory models)][{/30 pl}(30,){el}( ){/86 pl}(86){el}]153 1 idx03
[(memory operand)][{/32 pl}(32){el}]142 1 idx03
[(memory references)][{/29 pl}(29,){el}( ){/33 pl}(33,){el}( ){/110 pl}(110){el}]131 1 idx03
[2(MFENCE)][{/155 pl}(155){el}]120 1 idx03
[(Microsoft OMF)][{/71 pl}(71){el}]109 1 idx03
(204)pageeven
restore showpage
%%Page: 205 205
%%BeginPageSetup
save
%%EndPageSetup
/205 pa
[(Minix)][{/79 pl}(79){el}]681 0 idx03
[2(MINPD)][{/155 pl}(155){el}]670 0 idx03
[2(MINPS)][{/155 pl}(155){el}]659 0 idx03
[2(MINSD)][{/155 pl}(155){el}]648 0 idx03
[2(MINSS)][{/155 pl}(155){el}]637 0 idx03
[2(misc)0( subdirectory)][{/83 pl}(83,){el}( ){/90 pl}(90,){el}( ){/96 pl}(96){el}]626 0 idx03
[(mixed-language program)][{/85 pl}(85){el}]615 0 idx03
[(mixed-size addressing)][{/101 pl}(101){el}]604 0 idx03
[(mixed-size instruction)][{/101 pl}(101){el}]593 0 idx03
[(MMX registers)][{/112 pl}(112){el}]582 0 idx03
[(ModR/M byte)][{/111 pl}(111,){el}( ){/114 pl}(114){el}]571 0 idx03
[2(MODULE)][{/80 pl}(80){el}]560 0 idx03
[(modulo operators)][{/36 pl}(36){el}]549 0 idx03
[2(MOV)][{/156 pl}(156){el}]538 0 idx03
[2(MOVAPD)][{/156 pl}(156){el}]527 0 idx03
[2(MOVAPS)][{/157 pl}(157){el}]516 0 idx03
[2(MOVD)][{/157 pl}(157){el}]505 0 idx03
[2(MOVDQA)][{/157 pl}(157){el}]494 0 idx03
[2(MOVDQ2Q)][{/157 pl}(157){el}]483 0 idx03
[2(MOVDQU)][{/157 pl}(157){el}]472 0 idx03
[2(MOVHLPS)][{/157 pl}(157){el}]461 0 idx03
[2(MOVHPD)][{/158 pl}(158){el}]450 0 idx03
[2(MOVHPS)][{/158 pl}(158){el}]439 0 idx03
[2(MOVLHPS)][{/158 pl}(158){el}]428 0 idx03
[2(MOVLPD)][{/158 pl}(158){el}]417 0 idx03
[2(MOVLPS)][{/159 pl}(159){el}]406 0 idx03
[2(MOVMSKPD)][{/159 pl}(159){el}]395 0 idx03
[2(MOVMSKPS)][{/159 pl}(159){el}]384 0 idx03
[2(MOVNTDQ)][{/159 pl}(159){el}]373 0 idx03
[2(MOVNTI)][{/159 pl}(159){el}]362 0 idx03
[2(MOVNTPD)][{/159 pl}(159){el}]351 0 idx03
[2(MOVNTPS)][{/160 pl}(160){el}]340 0 idx03
[2(MOVNTQ)][{/160 pl}(160){el}]329 0 idx03
[2(MOVQ)][{/160 pl}(160){el}]318 0 idx03
[2(MOVQ2DQ)][{/160 pl}(160){el}]307 0 idx03
[2(MOVSB)][{/160 pl}(160){el}]296 0 idx03
[2(MOVSD)][{/160 pl}(160){el}]285 0 idx03
[2(MOVSS)][{/161 pl}(161){el}]274 0 idx03
[2(MOVSW)][{/160 pl}(160){el}]263 0 idx03
[2(MOVSX)][{/161 pl}(161){el}]252 0 idx03
[2(MOVUPD)][{/161 pl}(161){el}]241 0 idx03
[2(MOVUPS)][{/161 pl}(161){el}]230 0 idx03
[2(MOVZX)][{/161 pl}(161){el}]219 0 idx03
[(MS-DOS)][{/70 pl}(70){el}]208 0 idx03
[(MS-DOS device drivers)][{/85 pl}(85){el}]197 0 idx03
[2(MUL)][{/161 pl}(161){el}]186 0 idx03
[2(MULPD)][{/162 pl}(162){el}]175 0 idx03
[2(MULPS)][{/162 pl}(162){el}]164 0 idx03
[2(MULSD)][{/162 pl}(162){el}]153 0 idx03
[2(MULSS)][{/162 pl}(162){el}]142 0 idx03
[(multi-line macros)][{/28 pl}(28,){el}( ){/44 pl}(44){el}]131 0 idx03
[(multipass optimization)][{/27 pl}(27){el}]120 0 idx03
[(multiple section names)][{/70 pl}(70){el}]109 0 idx03
[(multiplication)][{/36 pl}(36){el}]681 1 idx03
[2(multipush)0( macro)][{/48 pl}(48){el}]670 1 idx03
[2(Multisection)][{/71 pl}(71){el}]659 1 idx03
[2(nasm.1)][{/21 pl}(21){el}]648 1 idx03
[(NASM version)][{/58 pl}(58){el}]637 1 idx03
[(nasm version id)][{/58 pl}(58){el}]626 1 idx03
[(nasm version string)][{/58 pl}(58){el}]615 1 idx03
[2(__NASMDEFSEG)][{/72 pl}(72){el}]604 1 idx03
[2(nasm-devel)][{/21 pl}(21){el}]593 1 idx03
[2(nasm.exe)][{/21 pl}(21){el}]582 1 idx03
[2(nasm -f <format> -y)][{/24 pl}(24){el}]571 1 idx03
[2(nasm -hf)][{/24 pl}(24){el}]560 1 idx03
[2(__NASM_MAJOR__)][{/58 pl}(58){el}]549 1 idx03
[2(__NASM_MINOR__)][{/58 pl}(58){el}]538 1 idx03
[2(nasm.out)][{/23 pl}(23){el}]527 1 idx03
[2(___NASM_PATCHLEVEL__)][{/58 pl}(58){el}]516 1 idx03
[2(__NASM_SUBMINOR__)][{/58 pl}(58){el}]505 1 idx03
[2(__NASM_VER__)][{/58 pl}(58){el}]494 1 idx03
[2(__NASM_VERSION_ID__)][{/58 pl}(58){el}]483 1 idx03
[2(nasmw.exe)][{/21 pl}(21){el}]472 1 idx03
[2(nasmXXXs.zip)][{/21 pl}(21){el}]461 1 idx03
[2(nasm-X.XX.tar.gz)][{/21 pl}(21){el}]450 1 idx03
[2(nasmXXX.zip)][{/21 pl}(21){el}]439 1 idx03
[2(ndisasm.1)][{/21 pl}(21){el}]428 1 idx03
[(ndisasm)][{/107 pl}(107){el}]417 1 idx03
[2(ndisasm.exe)][{/21 pl}(21){el}]406 1 idx03
[2(ndisasmw.exe)][{/21 pl}(21){el}]395 1 idx03
[(near call)][{/30 pl}(30,){el}( ){/122 pl}(122){el}]384 1 idx03
[(near common variables)][{/75 pl}(75){el}]373 1 idx03
[(near jump)][{/150 pl}(150){el}]362 1 idx03
[2(NEG)][{/162 pl}(162){el}]351 1 idx03
[(NetBSD)][{/79 pl}(79,){el}( ){/97 pl}(97){el}]340 1 idx03
[(new releases)][{/21 pl}(21){el}]329 1 idx03
[2(noalloc)][{/77 pl}(77){el}]318 1 idx03
[2(nobits)][{/71 pl}(71,){el}( ){/77 pl}(77){el}]307 1 idx03
[2(noexec)][{/77 pl}(77){el}]296 1 idx03
[2(.nolist)][{/50 pl}(50){el}]285 1 idx03
[2(NOP)][{/162 pl}(162){el}]274 1 idx03
[2(NOT)][{/162 pl}(162){el}]263 1 idx03
[(`nowait')][{/30 pl}(30){el}]252 1 idx03
[2(nowrite)][{/77 pl}(77){el}]241 1 idx03
[2(number-overflow)][{/28 pl}(28){el}]230 1 idx03
[(numeric constants)][{/32 pl}(32,){el}( ){/34 pl}(34){el}]219 1 idx03
[2(-o)0( option)][{/23 pl}(23,){el}( ){/107 pl}(107){el}]208 1 idx03
[2(o16)][{/103 pl}(103,){el}( ){/175 pl}(175,){el}( ){/181 pl}(181){el}]197 1 idx03
[2(o32)][{/103 pl}(103,){el}( ){/175 pl}(175,){el}( ){/181 pl}(181){el}]186 1 idx03
[2(.OBJ)][{/82 pl}(82){el}]175 1 idx03
[2(obj)][{/23 pl}(23,){el}( ){/71 pl}(71){el}]164 1 idx03
[2(object)][{/78 pl}(78,){el}( ){/80 pl}(80){el}]153 1 idx03
[(octal)][{/34 pl}(34){el}]142 1 idx03
[2(OF_DBG)][{/81 pl}(81){el}]131 1 idx03
[2(OF_DEFAULT)][{/24 pl}(24){el}]120 1 idx03
[2(OFFSET)][{/29 pl}(29){el}]109 1 idx03
(205)pageodd
restore showpage
%%Page: 206 206
%%BeginPageSetup
save
%%EndPageSetup
/206 pa
[(OMF)][{/71 pl}(71){el}]681 0 idx03
[(omitted parameters)][{/47 pl}(47){el}]670 0 idx03
[2(-On)0( option)][{/27 pl}(27){el}]659 0 idx03
[(one's complement)][{/36 pl}(36){el}]648 0 idx03
[(OpenBSD)][{/79 pl}(79,){el}( ){/97 pl}(97){el}]637 0 idx03
[(operands)][{/31 pl}(31){el}]626 0 idx03
[(operand-size prefixes)][{/31 pl}(31){el}]615 0 idx03
[(operating system)][{/70 pl}(70){el}]604 0 idx03
[(writing)][{/101 pl}(101){el}]593 0 idx13
[(operators)][{/36 pl}(36){el}]582 0 idx03
[2(OR)][{/162 pl}(162){el}]571 0 idx03
[2(ORG)][{/70 pl}(70,){el}( ){/84 pl}(84,){el}( ){/85 pl}(85,){el}( ){/104 pl}(104){el}]560 0 idx03
[2(ORPD)][{/163 pl}(163){el}]549 0 idx03
[2(orphan-labels)][{/28 pl}(28,){el}( ){/31 pl}(31){el}]538 0 idx03
[2(ORPS)][{/163 pl}(163){el}]527 0 idx03
[(OS/2)][{/71 pl}(71,){el}( ){/73 pl}(73){el}]516 0 idx03
[(other preprocessor directives)][{/63 pl}(63){el}]505 0 idx03
[2(OUT)][{/163 pl}(163){el}]494 0 idx03
[(out of range, jumps)][{/104 pl}(104){el}]483 0 idx03
[(output file format)][{/24 pl}(24){el}]472 0 idx03
[(output formats)][{/70 pl}(70){el}]461 0 idx03
[2(OUTSB)][{/163 pl}(163){el}]450 0 idx03
[2(OUTSD)][{/163 pl}(163){el}]439 0 idx03
[2(OUTSW)][{/163 pl}(163){el}]428 0 idx03
[(overlapping segments)][{/37 pl}(37){el}]417 0 idx03
[2(OVERLAY)][{/73 pl}(73){el}]406 0 idx03
[(overloading)][]395 0 idx03
[(multi-line macros)][{/45 pl}(45){el}]384 0 idx13
[(single-line macros)][{/42 pl}(42){el}]373 0 idx13
[2(-P)0( option)][{/26 pl}(26){el}]362 0 idx03
[2(-p)0( option)][{/26 pl}(26,){el}( ){/55 pl}(55){el}]351 0 idx03
[2(PACKSSDW)][{/164 pl}(164){el}]340 0 idx03
[2(PACKSSWB)][{/164 pl}(164){el}]329 0 idx03
[2(PACKUSWB)][{/164 pl}(164){el}]318 0 idx03
[2(PADDB)][{/164 pl}(164){el}]307 0 idx03
[2(PADDD)][{/164 pl}(164){el}]296 0 idx03
[2(PADDQ)][{/165 pl}(165){el}]285 0 idx03
[2(PADDSB)][{/165 pl}(165){el}]274 0 idx03
[2(PADDSIW)][{/165 pl}(165){el}]263 0 idx03
[2(PADDSW)][{/165 pl}(165){el}]252 0 idx03
[2(PADDUSB)][{/165 pl}(165){el}]241 0 idx03
[2(PADDUSW)][{/165 pl}(165){el}]230 0 idx03
[2(PADDW)][{/164 pl}(164){el}]219 0 idx03
[2(PAND)][{/165 pl}(165){el}]208 0 idx03
[2(PANDN)][{/165 pl}(165){el}]197 0 idx03
[(paradox)][{/38 pl}(38){el}]186 0 idx03
[2(PASCAL)][{/93 pl}(93){el}]175 0 idx03
[(Pascal calling convention)][{/91 pl}(91){el}]164 0 idx03
[(passes, assembly)][{/38 pl}(38){el}]153 0 idx03
[2(PATH)][{/21 pl}(21){el}]142 0 idx03
[2(PAUSE)][{/166 pl}(166){el}]131 0 idx03
[2(PAVEB)][{/166 pl}(166){el}]120 0 idx03
[2(PAVGB)][{/166 pl}(166){el}]109 0 idx03
[2(PAVGUSB)][{/166 pl}(166){el}]681 1 idx03
[2(PAVGW)][{/166 pl}(166){el}]670 1 idx03
[2(PCMPxx)][{/166 pl}(166){el}]659 1 idx03
[2(PDISTIB)][{/167 pl}(167){el}]648 1 idx03
[(period)][{/39 pl}(39){el}]637 1 idx03
[(Perl)][{/21 pl}(21){el}]626 1 idx03
[(perverse)][{/26 pl}(26){el}]615 1 idx03
[2(PEXTRW)][{/167 pl}(167){el}]604 1 idx03
[2(PFACC)][{/168 pl}(168){el}]593 1 idx03
[2(PFADD)][{/168 pl}(168){el}]582 1 idx03
[2(PFCMPEQ)][{/168 pl}(168){el}]571 1 idx03
[2(PFCMPGE)][{/168 pl}(168){el}]560 1 idx03
[2(PFCMPGT)][{/168 pl}(168){el}]549 1 idx03
[2(PFCMPxx)][{/168 pl}(168){el}]538 1 idx03
[2(PF2ID)][{/168 pl}(168){el}]527 1 idx03
[2(PF2IW)][{/168 pl}(168,){el}( ){/171 pl}(171){el}]516 1 idx03
[2(PFMAX)][{/169 pl}(169){el}]505 1 idx03
[2(PFMIN)][{/169 pl}(169){el}]494 1 idx03
[2(PFMUL)][{/169 pl}(169){el}]483 1 idx03
[2(PFNACC)][{/169 pl}(169){el}]472 1 idx03
[2(PFPNACC)][{/169 pl}(169){el}]461 1 idx03
[2(PFRCP)][{/169 pl}(169){el}]450 1 idx03
[2(PFRCPIT1)][{/170 pl}(170){el}]439 1 idx03
[2(PFRCPIT2)][{/170 pl}(170){el}]428 1 idx03
[2(PFRSQIT1)][{/170 pl}(170){el}]417 1 idx03
[2(PFRSQRT)][{/170 pl}(170){el}]406 1 idx03
[2(PFSUB)][{/170 pl}(170){el}]395 1 idx03
[2(PFSUBR)][{/170 pl}(170){el}]384 1 idx03
[(PharLap)][{/72 pl}(72){el}]373 1 idx03
[(PIC)][{/77 pl}(77,){el}( ){/79 pl}(79,){el}( ){/97 pl}(97){el}]362 1 idx03
[2(PI2FD)][{/171 pl}(171){el}]351 1 idx03
[2(PINSRW)][{/171 pl}(171){el}]340 1 idx03
[2(..plt)][{/78 pl}(78){el}]329 1 idx03
[2(PLT)0( relocations)][{/78 pl}(78,){el}( ){/99 pl}(99,){el}( ){/100 pl}(100){el}]318 1 idx03
[(plt relocations)][{/100 pl}(100){el}]307 1 idx03
[2(PMACHRIW)][{/171 pl}(171){el}]296 1 idx03
[2(PMADDWD)][{/171 pl}(171){el}]285 1 idx03
[2(PMAGW)][{/172 pl}(172){el}]274 1 idx03
[2(PMAXSW)][{/172 pl}(172){el}]263 1 idx03
[2(PMAXUB)][{/172 pl}(172){el}]252 1 idx03
[2(PMINSW)][{/172 pl}(172){el}]241 1 idx03
[2(PMINUB)][{/172 pl}(172){el}]230 1 idx03
[2(PMOVMSKB)][{/172 pl}(172){el}]219 1 idx03
[2(PMULHRIW)][{/173 pl}(173){el}]208 1 idx03
[2(PMULHRWA)][{/173 pl}(173){el}]197 1 idx03
[2(PMULHRWC)][{/173 pl}(173){el}]186 1 idx03
[2(PMULHUW)][{/173 pl}(173){el}]175 1 idx03
[2(PMULHW)][{/173 pl}(173){el}]164 1 idx03
[2(PMULLW)][{/173 pl}(173){el}]153 1 idx03
[2(PMULUDQ)][{/174 pl}(174){el}]142 1 idx03
[2(PMVccZB)][{/174 pl}(174){el}]131 1 idx03
[2(%pop)][{/55 pl}(55){el}]120 1 idx03
[2(POP)][{/174 pl}(174){el}]109 1 idx03
(206)pageeven
restore showpage
%%Page: 207 207
%%BeginPageSetup
save
%%EndPageSetup
/207 pa
[2(POPAx)][{/175 pl}(175){el}]681 0 idx03
[2(POPFx)][{/175 pl}(175){el}]670 0 idx03
[2(POR)][{/175 pl}(175){el}]659 0 idx03
[(position-independent code)][{/77 pl}(77,){el}( ){/79 pl}(79,){el}( ){/97 pl}(97){el}]648 0 idx03
[2(--postfix)][{/28 pl}(28){el}]637 0 idx03
[(precedence)][{/36 pl}(36){el}]626 0 idx03
[(pre-defining macros)][{/26 pl}(26,){el}( ){/42 pl}(42){el}]615 0 idx03
[(preferred)][{/37 pl}(37){el}]604 0 idx03
[2(PREFETCH)][{/175 pl}(175){el}]593 0 idx03
[2(PREFETCHh)][{/176 pl}(176){el}]582 0 idx03
[2(PREFETCHNTA)][{/176 pl}(176){el}]571 0 idx03
[2(PREFETCHT0)][{/176 pl}(176){el}]560 0 idx03
[2(PREFETCHT1)][{/176 pl}(176){el}]549 0 idx03
[2(PREFETCHT2)][{/176 pl}(176){el}]538 0 idx03
[2(--prefix)][{/28 pl}(28){el}]527 0 idx03
[(pre-including files)][{/26 pl}(26){el}]516 0 idx03
[(preprocess-only mode)][{/27 pl}(27){el}]505 0 idx03
[(preprocessor)][{/26 pl}(26,){el}( ){/27 pl}(27,){el}( ){/33 pl}(33,){el}( ){/36 pl}(36,){el}( ){/41 pl}(41){el}]494 0 idx03
[(preprocessor expressions)][{/26 pl}(26){el}]483 0 idx03
[(preprocessor loops)][{/54 pl}(54){el}]472 0 idx03
[(preprocessor variables)][{/43 pl}(43){el}]461 0 idx03
[(primitive directives)][{/65 pl}(65){el}]450 0 idx03
[2(PRIVATE)][{/72 pl}(72){el}]439 0 idx03
[2(proc)][{/80 pl}(80,){el}( ){/90 pl}(90,){el}( ){/96 pl}(96){el}]428 0 idx03
[(procedure linkage table)][{/78 pl}(78,){el}( ){/99 pl}(99,){el}( ){/100 pl}(100){el}]417 0 idx03
[(processor mode)][{/65 pl}(65){el}]406 0 idx03
[2(progbits)][{/71 pl}(71,){el}( ){/77 pl}(77){el}]395 0 idx03
[(program entry point)][{/74 pl}(74,){el}( ){/82 pl}(82){el}]384 0 idx03
[(program origin)][{/70 pl}(70){el}]373 0 idx03
[2(PSADBW)][{/176 pl}(176){el}]362 0 idx03
[(pseudo-instructions)][{/32 pl}(32){el}]351 0 idx03
[2(PSHUFD)][{/176 pl}(176){el}]340 0 idx03
[2(PSHUFHW)][{/176 pl}(176){el}]329 0 idx03
[2(PSHUFLW)][{/177 pl}(177){el}]318 0 idx03
[2(PSHUFW)][{/177 pl}(177){el}]307 0 idx03
[2(PSLLx)][{/177 pl}(177){el}]296 0 idx03
[2(PSRAx)][{/177 pl}(177){el}]285 0 idx03
[2(PSRLx)][{/178 pl}(178){el}]274 0 idx03
[2(PSUBSIW)][{/179 pl}(179){el}]263 0 idx03
[2(PSUBSxx)][{/179 pl}(179){el}]252 0 idx03
[2(PSUBUSx)][{/179 pl}(179){el}]241 0 idx03
[2(PSUBx)][{/178 pl}(178){el}]230 0 idx03
[2(PSWAPD)][{/179 pl}(179){el}]219 0 idx03
[2(PSWAPW)][{/179 pl}(179){el}]208 0 idx03
[2(PUBLIC)][{/68 pl}(68,){el}( ){/72 pl}(72){el}]197 0 idx03
[2(PUNPCKxxx)][{/180 pl}(180){el}]186 0 idx03
[(pure binary)][{/70 pl}(70){el}]175 0 idx03
[2(%push)][{/55 pl}(55){el}]164 0 idx03
[2(PUSH)][{/180 pl}(180){el}]153 0 idx03
[2(PUSHAx)][{/181 pl}(181){el}]142 0 idx03
[2(PUSHFx)][{/181 pl}(181){el}]131 0 idx03
[2(PXOR)][{/182 pl}(182){el}]120 0 idx03
[(quick start)][{/29 pl}(29){el}]109 0 idx03
[2(QWORD)][{/32 pl}(32){el}]681 1 idx03
[2(-r)][{/107 pl}(107){el}]670 1 idx03
[2(RCL)][{/182 pl}(182){el}]659 1 idx03
[2(RCPPS)][{/182 pl}(182){el}]648 1 idx03
[2(RCPSS)][{/183 pl}(183){el}]637 1 idx03
[2(RCR)][{/182 pl}(182){el}]626 1 idx03
[2(rdf)][{/23 pl}(23,){el}( ){/80 pl}(80){el}]615 1 idx03
[2(RDMSR)][{/183 pl}(183){el}]604 1 idx03
[2(rdoff)0( subdirectory)][{/22 pl}(22,){el}( ){/80 pl}(80){el}]593 1 idx03
[2(RDPMC)][{/183 pl}(183){el}]582 1 idx03
[2(RDSHR)][{/183 pl}(183){el}]571 1 idx03
[2(RDTSC)][{/183 pl}(183){el}]560 1 idx03
[(redirecting errors)][{/25 pl}(25){el}]549 1 idx03
[(register push)][{/181 pl}(181){el}]538 1 idx03
[(relational operators)][{/52 pl}(52){el}]527 1 idx03
[(Relocatable Dynamic Object File)][]516 1 idx01
[(Format)][{/80 pl}(80){el}]505 1 idx02
[(relocations, PIC-specific)][{/77 pl}(77){el}]494 1 idx03
[(removing contexts)][{/55 pl}(55){el}]483 1 idx03
[(renaming contexts)][{/56 pl}(56){el}]472 1 idx03
[2(%rep)][{/33 pl}(33,){el}( ){/54 pl}(54){el}]461 1 idx03
[(repeating)][{/33 pl}(33,){el}( ){/54 pl}(54){el}]450 1 idx03
[2(%repl)][{/56 pl}(56){el}]439 1 idx03
[(reporting bugs)][{/105 pl}(105){el}]428 1 idx03
[2(RESB)][{/30 pl}(30,){el}( ){/32 pl}(32,){el}( ){/38 pl}(38){el}]417 1 idx03
[2(RESD)][{/32 pl}(32){el}]406 1 idx03
[2(RESQ)][{/32 pl}(32){el}]395 1 idx03
[2(REST)][{/32 pl}(32){el}]384 1 idx03
[(restricted memory references)][{/110 pl}(110){el}]373 1 idx03
[2(RESW)][{/32 pl}(32){el}]362 1 idx03
[2(RET)][{/183 pl}(183){el}]351 1 idx03
[2(RETF)][{/183 pl}(183){el}]340 1 idx03
[2(RETN)][{/183 pl}(183){el}]329 1 idx03
[2(ROL)][{/183 pl}(183){el}]318 1 idx03
[2(ROR)][{/183 pl}(183){el}]307 1 idx03
[2(%rotate)][{/48 pl}(48){el}]296 1 idx03
[(rotating macro parameters)][{/48 pl}(48){el}]285 1 idx03
[2(RPL)][{/120 pl}(120){el}]274 1 idx03
[2(RSDC)][{/184 pl}(184){el}]263 1 idx03
[2(RSLDT)][{/184 pl}(184){el}]252 1 idx03
[2(RSM)][{/184 pl}(184){el}]241 1 idx03
[2(RSQRTPS)][{/184 pl}(184){el}]230 1 idx03
[2(RSQRTSS)][{/184 pl}(184){el}]219 1 idx03
[2(RSTS)][{/185 pl}(185){el}]208 1 idx03
[2(-s)0( option)][{/25 pl}(25,){el}( ){/108 pl}(108){el}]197 1 idx03
[2(SAHF)][{/185 pl}(185){el}]186 1 idx03
[2(SAL)][{/185 pl}(185){el}]175 1 idx03
[2(SALC)][{/185 pl}(185){el}]164 1 idx03
[2(SAR)][{/185 pl}(185){el}]153 1 idx03
[2(SBB)][{/186 pl}(186){el}]142 1 idx03
[2(SCASB)][{/186 pl}(186){el}]131 1 idx03
[2(SCASD)][{/186 pl}(186){el}]120 1 idx03
[2(SCASW)][{/186 pl}(186){el}]109 1 idx03
(207)pageodd
restore showpage
%%Page: 208 208
%%BeginPageSetup
save
%%EndPageSetup
/208 pa
[(searching for include files)][{/54 pl}(54){el}]681 0 idx03
[2(__SECT__)][{/66 pl}(66,){el}( ){/67 pl}(67){el}]670 0 idx03
[2(SECTION)][{/65 pl}(65){el}]659 0 idx03
[2(elf)0( extensions to)][{/77 pl}(77){el}]648 0 idx13
[2(win32)0( extensions to)][{/76 pl}(76){el}]637 0 idx13
[(section alignment)][]626 0 idx03
[(in )2(bin)][{/71 pl}(71){el}]615 0 idx13
[(in )2(elf)][{/77 pl}(77){el}]604 0 idx13
[(in )2(obj)][{/72 pl}(72){el}]593 0 idx13
[(in )2(win32)][{/76 pl}(76){el}]582 0 idx13
[(section, bin extensions to)][{/70 pl}(70){el}]571 0 idx03
[2(SEG)][{/36 pl}(36,){el}( ){/37 pl}(37,){el}( ){/72 pl}(72){el}]560 0 idx03
[2(SEGMENT)][{/65 pl}(65){el}]549 0 idx03
[2(elf)0( extensions to)][{/72 pl}(72){el}]538 0 idx13
[(segment address)][{/36 pl}(36,){el}( ){/37 pl}(37){el}]527 0 idx03
[(segment alignment)][]516 0 idx03
[(in )2(bin)][{/71 pl}(71){el}]505 0 idx13
[(in )2(obj)][{/72 pl}(72){el}]494 0 idx13
[(segment names, Borland Pascal)][{/92 pl}(92){el}]483 0 idx03
[(segment override)][{/30 pl}(30,){el}( ){/31 pl}(31){el}]472 0 idx03
[(segment registers)][{/112 pl}(112){el}]461 0 idx03
[(segments)][{/37 pl}(37){el}]450 0 idx03
[(groups of)][{/73 pl}(73){el}]439 0 idx13
[(separator character)][{/29 pl}(29){el}]428 0 idx03
[2(SETcc)][{/186 pl}(186){el}]417 0 idx03
[2(SFENCE)][{/187 pl}(187){el}]406 0 idx03
[2(SGDT)][{/187 pl}(187){el}]395 0 idx03
[(shared libraries)][{/79 pl}(79,){el}( ){/97 pl}(97){el}]384 0 idx03
[(shared library)][{/78 pl}(78){el}]373 0 idx03
[2(shift)0( command)][{/48 pl}(48){el}]362 0 idx03
[2(SHL)][{/187 pl}(187){el}]351 0 idx03
[2(SHLD)][{/188 pl}(188){el}]340 0 idx03
[2(SHR)][{/187 pl}(187){el}]329 0 idx03
[2(SHRD)][{/188 pl}(188){el}]318 0 idx03
[2(SHUFPD)][{/188 pl}(188){el}]307 0 idx03
[2(SHUFPS)][{/189 pl}(189){el}]296 0 idx03
[(SIB byte)][{/111 pl}(111,){el}( ){/114 pl}(114){el}]285 0 idx03
[2(SIDT)][{/187 pl}(187){el}]274 0 idx03
[(signed division)][{/36 pl}(36){el}]263 0 idx03
[(signed modulo)][{/36 pl}(36){el}]252 0 idx03
[(single-line macros)][{/41 pl}(41){el}]241 0 idx03
[(size, of symbols)][{/78 pl}(78){el}]230 0 idx03
[2(SLDT)][{/187 pl}(187){el}]219 0 idx03
[2(SMI)][{/189 pl}(189){el}]208 0 idx03
[2(SMINT)][{/189 pl}(189){el}]197 0 idx03
[2(SMINTOLD)][{/189 pl}(189){el}]186 0 idx03
[2(SMSW)][{/189 pl}(189){el}]175 0 idx03
[(Solaris x86)][{/77 pl}(77){el}]164 0 idx03
[2(-soname)][{/100 pl}(100){el}]153 0 idx03
[(sound)][{/32 pl}(32){el}]142 0 idx03
[(source code)][{/21 pl}(21){el}]131 0 idx03
[(source-listing file)][{/24 pl}(24){el}]120 0 idx03
[2(SQRTPD)][{/189 pl}(189){el}]109 0 idx03
[2(SQRTPS)][{/189 pl}(189){el}]681 1 idx03
[2(SQRTSD)][{/189 pl}(189){el}]670 1 idx03
[2(SQRTSS)][{/190 pl}(190){el}]659 1 idx03
[(square brackets)][{/29 pl}(29,){el}( ){/33 pl}(33){el}]648 1 idx03
[(sse condition predicates)][{/112 pl}(112){el}]637 1 idx03
[2(STACK)][{/72 pl}(72){el}]626 1 idx03
[2(stack frame)][{/134 pl}(134){el}]615 1 idx03
[2(%stacksize)][{/62 pl}(62){el}]604 1 idx03
[(standard macros)][{/58 pl}(58){el}]593 1 idx03
[(standardised section names)][{/66 pl}(66,){el}( ){/76 pl}(76,){el}( ){/77 pl}(77,){el}( ){/79 pl}(79,){el}]582 1 idx01
[][{/80 pl}(80){el}]571 1 idx02
[2(..start)][{/74 pl}(74,){el}( ){/82 pl}(82){el}]560 1 idx03
[2(start=)][{/71 pl}(71){el}]549 1 idx03
[(status flags)][{/113 pl}(113){el}]538 1 idx03
[2(STC)][{/190 pl}(190){el}]527 1 idx03
[2(STD)][{/190 pl}(190){el}]516 1 idx03
[2(stderr)][{/25 pl}(25){el}]505 1 idx03
[2(stdout)][{/25 pl}(25){el}]494 1 idx03
[2(STI)][{/190 pl}(190){el}]483 1 idx03
[2(STMXCSR)][{/190 pl}(190){el}]472 1 idx03
[2(STOSB)][{/190 pl}(190){el}]461 1 idx03
[2(STOSD)][{/190 pl}(190){el}]450 1 idx03
[2(STOSW)][{/190 pl}(190){el}]439 1 idx03
[2(STR)][{/190 pl}(190){el}]428 1 idx03
[2(STRICT)][{/37 pl}(37){el}]417 1 idx03
[(string constant)][{/32 pl}(32){el}]406 1 idx03
[(string handling in macros)][{/44 pl}(44){el}]395 1 idx03
[(string length)][{/44 pl}(44){el}]384 1 idx03
[2(%strlen)][{/44 pl}(44){el}]373 1 idx03
[2(STRUC)][{/59 pl}(59,){el}( ){/67 pl}(67,){el}( ){/89 pl}(89,){el}( ){/96 pl}(96){el}]362 1 idx03
[(stub preprocessor)][{/27 pl}(27){el}]351 1 idx03
[2(SUB)][{/191 pl}(191){el}]340 1 idx03
[2(SUBPD)][{/191 pl}(191){el}]329 1 idx03
[2(SUBPS)][{/191 pl}(191){el}]318 1 idx03
[2(SUBSD)][{/191 pl}(191){el}]307 1 idx03
[2(SUBSS)][{/191 pl}(191){el}]296 1 idx03
[2(%substr)][{/44 pl}(44){el}]285 1 idx03
[(sub-strings)][{/44 pl}(44){el}]274 1 idx03
[(subtraction)][{/36 pl}(36){el}]263 1 idx03
[(suppressible warning)][{/28 pl}(28){el}]252 1 idx03
[(suppressing preprocessing)][{/27 pl}(27){el}]241 1 idx03
[2(SVDC)][{/192 pl}(192){el}]230 1 idx03
[2(SVLDT)][{/192 pl}(192){el}]219 1 idx03
[2(SVTS)][{/192 pl}(192){el}]208 1 idx03
[(switching between sections)][{/65 pl}(65){el}]197 1 idx03
[2(..sym)][{/78 pl}(78){el}]186 1 idx03
[(symbol sizes, specifying)][{/78 pl}(78){el}]175 1 idx03
[(symbol types, specifying)][{/78 pl}(78){el}]164 1 idx03
[(symbols)][]153 1 idx03
[(exporting from DLLs)][{/74 pl}(74){el}]142 1 idx13
[(importing from DLLs)][{/74 pl}(74){el}]131 1 idx13
[2(synchronisation)][{/108 pl}(108){el}]120 1 idx03
[2(.SYS)][{/70 pl}(70,){el}( ){/85 pl}(85){el}]109 1 idx03
(208)pageeven
restore showpage
%%Page: 209 209
%%BeginPageSetup
save
%%EndPageSetup
/209 pa
[2(SYSCALL)][{/192 pl}(192){el}]681 0 idx03
[2(SYSENTER)][{/192 pl}(192){el}]670 0 idx03
[2(SYSEXIT)][{/193 pl}(193){el}]659 0 idx03
[2(SYSRET)][{/193 pl}(193){el}]648 0 idx03
[2(-t)][{/27 pl}(27){el}]637 0 idx03
[2(TASM)][{/20 pl}(20,){el}( ){/27 pl}(27){el}]626 0 idx03
[(tasm)][{/29 pl}(29,){el}( ){/71 pl}(71){el}]615 0 idx03
[(tasm compatible preprocessor)][]604 0 idx01
[(directives)][{/61 pl}(61){el}]593 0 idx02
[2(TBYTE)][{/30 pl}(30){el}]582 0 idx03
[2(TEST)][{/194 pl}(194){el}]571 0 idx03
[2(test)0( subdirectory)][{/82 pl}(82){el}]560 0 idx03
[(test registers)][{/112 pl}(112){el}]549 0 idx03
[(testing)][]538 0 idx03
[(arbitrary numeric expressions)][{/52 pl}(52){el}]527 0 idx13
[(context stack)][{/51 pl}(51){el}]516 0 idx13
[(exact text identity)][{/52 pl}(52){el}]505 0 idx13
[(multi-line macro existence)][{/51 pl}(51){el}]494 0 idx13
[(single-line macro existence)][{/51 pl}(51){el}]483 0 idx13
[(token types)][{/52 pl}(52){el}]472 0 idx13
[2(.text)][{/77 pl}(77,){el}( ){/79 pl}(79,){el}( ){/80 pl}(80){el}]461 0 idx03
[2(_TEXT)][{/87 pl}(87){el}]450 0 idx03
[2(TIMES)][{/32 pl}(32,){el}( ){/33 pl}(33,){el}( ){/38 pl}(38,){el}( ){/104 pl}(104,){el}( ){/105 pl}(105){el}]439 0 idx03
[2(TLINK)][{/85 pl}(85){el}]428 0 idx03
[(trailing colon)][{/31 pl}(31){el}]417 0 idx03
[(two-pass assembler)][{/38 pl}(38){el}]406 0 idx03
[2(TWORD)][{/30 pl}(30,){el}( ){/32 pl}(32){el}]395 0 idx03
[(type, of symbols)][{/78 pl}(78){el}]384 0 idx03
[2(-U)0( option)][{/26 pl}(26){el}]373 0 idx03
[2(-u)0( option)][{/26 pl}(26,){el}( ){/107 pl}(107){el}]362 0 idx03
[2(UCOMISD)][{/194 pl}(194){el}]351 0 idx03
[2(UCOMISS)][{/194 pl}(194){el}]340 0 idx03
[2(UD0)][{/194 pl}(194){el}]329 0 idx03
[2(UD1)][{/194 pl}(194){el}]318 0 idx03
[2(UD2)][{/194 pl}(194){el}]307 0 idx03
[2(UMOV)][{/195 pl}(195){el}]296 0 idx03
[(unary operators)][{/36 pl}(36){el}]285 0 idx03
[2(%undef)][{/26 pl}(26,){el}( ){/43 pl}(43){el}]274 0 idx03
[(undefining macros)][{/26 pl}(26){el}]263 0 idx03
[(underscore, in C symbols)][{/85 pl}(85){el}]252 0 idx03
[(uninitialised)][{/32 pl}(32){el}]241 0 idx03
[(uninitialised storage)][{/30 pl}(30){el}]230 0 idx03
[(Unix)][{/21 pl}(21){el}]219 0 idx03
[(SCO)][{/77 pl}(77){el}]208 0 idx13
[(source archive)][{/21 pl}(21){el}]197 0 idx13
[(System V)][{/77 pl}(77){el}]186 0 idx13
[(UnixWare)][{/77 pl}(77){el}]175 0 idx03
[2(UNPCKHPD)][{/195 pl}(195){el}]164 0 idx03
[2(UNPCKHPS)][{/195 pl}(195){el}]153 0 idx03
[2(UNPCKLPD)][{/195 pl}(195){el}]142 0 idx03
[2(UNPCKLPS)][{/195 pl}(195){el}]131 0 idx03
[(unrolled loops)][{/33 pl}(33){el}]120 0 idx03
[(unsigned division)][{/36 pl}(36){el}]109 0 idx03
[(unsigned modulo)][{/36 pl}(36){el}]681 1 idx03
[2(UPPERCASE)][{/29 pl}(29,){el}( ){/73 pl}(73){el}]670 1 idx03
[2(USE16)][{/65 pl}(65,){el}( ){/73 pl}(73){el}]659 1 idx03
[2(USE32)][{/65 pl}(65,){el}( ){/73 pl}(73){el}]648 1 idx03
[(user-defined errors)][{/53 pl}(53){el}]637 1 idx03
[(user-level assembler directives)][{/58 pl}(58){el}]626 1 idx03
[(user-level directives)][{/65 pl}(65){el}]615 1 idx03
[2(-v)0( option)][{/28 pl}(28){el}]604 1 idx03
[(VAL)][{/82 pl}(82){el}]593 1 idx03
[(valid characters)][{/31 pl}(31){el}]582 1 idx03
[(variable types)][{/30 pl}(30){el}]571 1 idx03
[2(VERR)][{/196 pl}(196){el}]560 1 idx03
[(version)][{/28 pl}(28){el}]549 1 idx03
[(version number of NASM)][{/58 pl}(58){el}]538 1 idx03
[2(VERW)][{/196 pl}(196){el}]527 1 idx03
[2(vfollows=)][{/71 pl}(71){el}]516 1 idx03
[(Visual C++)][{/76 pl}(76){el}]505 1 idx03
[2(vstart=)][{/71 pl}(71){el}]494 1 idx03
[2(-w)0( option)][{/28 pl}(28){el}]483 1 idx03
[2(WAIT)][{/196 pl}(196){el}]472 1 idx03
[(warnings)][{/28 pl}(28){el}]461 1 idx03
[2([warning +warning-name])][{/28 pl}(28){el}]450 1 idx03
[2([warning -warning-name])][{/28 pl}(28){el}]439 1 idx03
[2(WBINVD)][{/196 pl}(196){el}]428 1 idx03
[(Win32)][{/21 pl}(21,){el}( ){/23 pl}(23,){el}( ){/71 pl}(71,){el}( ){/76 pl}(76,){el}( ){/94 pl}(94){el}]417 1 idx03
[(Windows)][{/82 pl}(82){el}]406 1 idx03
[(Windows 95)][{/21 pl}(21){el}]395 1 idx03
[(Windows NT)][{/21 pl}(21){el}]384 1 idx03
[2(write)][{/77 pl}(77){el}]373 1 idx03
[(writing operating systems)][{/101 pl}(101){el}]362 1 idx03
[2(WRMSR)][{/196 pl}(196){el}]351 1 idx03
[2(WRSHR)][{/196 pl}(196){el}]340 1 idx03
[2(WRT)][{/37 pl}(37,){el}( ){/72 pl}(72,){el}( ){/77 pl}(77,){el}( ){/79 pl}(79){el}]329 1 idx03
[2(WRT ..got)][{/99 pl}(99){el}]318 1 idx03
[2(WRT ..gotoff)][{/98 pl}(98){el}]307 1 idx03
[2(WRT ..gotpc)][{/98 pl}(98){el}]296 1 idx03
[2(WRT ..plt)][{/100 pl}(100){el}]285 1 idx03
[2(WRT ..sym)][{/100 pl}(100){el}]274 1 idx03
[(WWW page)][{/20 pl}(20){el}]263 1 idx03
[2(www.cpan.org)][{/21 pl}(21){el}]252 1 idx03
[2(www.delorie.com)][{/82 pl}(82){el}]241 1 idx03
[2(www.pcorner.com)][{/82 pl}(82){el}]230 1 idx03
[2(-X)0( option)][{/25 pl}(25){el}]219 1 idx03
[2(XADD)][{/196 pl}(196){el}]208 1 idx03
[2(XBTS)][{/197 pl}(197){el}]197 1 idx03
[2(XCHG)][{/197 pl}(197){el}]186 1 idx03
[2(%xdefine)][{/42 pl}(42){el}]175 1 idx03
[2(x2ftp.oulu.fi)][{/82 pl}(82){el}]164 1 idx03
[2(%xidefine)][{/42 pl}(42){el}]153 1 idx03
[2(XLATB)][{/197 pl}(197){el}]142 1 idx03
[2(XOR)][{/197 pl}(197){el}]131 1 idx03
[2(XORPD)][{/198 pl}(198){el}]120 1 idx03
[2(XORPS)][{/198 pl}(198){el}]109 1 idx03
(209)pageodd
restore showpage
%%Page: 210 210
%%BeginPageSetup
save
%%EndPageSetup
/210 pa
[2(-y)0( option)][{/28 pl}(28){el}]681 0 idx03
(210)pageeven
restore showpage
%%EOF
