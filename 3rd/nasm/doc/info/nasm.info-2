This is nasm.info, produced by makeinfo version 4.7 from nasmdoc.texi.

INFO-DIR-SECTION Programming
START-INFO-DIR-ENTRY
* NASM: (nasm).                The Netwide Assembler for x86.
END-INFO-DIR-ENTRY

   This file documents NASM, the Netwide Assembler: an assembler
targetting the Intel x86 series of processors, with portable source.

   Copyright 2003 The NASM Development Team

   All rights reserved. This document is redistributable under the
licence given in the file "COPYING" distributed in the NASM archive.


File: nasm.info,  Node: Section B.2.4,  Next: Section B.2.5,  Prev: Section B.2.3,  Up: Section B.2

B.2.4. Status Flags
-------------------

The status flags provide some information about the result of the
arithmetic instructions. This information can be used by conditional
instructions (such a `Jcc' and `CMOVcc') as well as by some of the
other instructions (such as `ADC' and `INTO').

   There are 6 status flags:

     CF - Carry flag.

   Set if an arithmetic operation generates a carry or a borrow out of
the most-significant bit of the result; cleared otherwise. This flag
indicates an overflow condition for unsigned-integer arithmetic. It is
also used in multiple-precision arithmetic.

     PF - Parity flag.

   Set if the least-significant byte of the result contains an even
number of 1 bits; cleared otherwise.

     AF - Adjust flag.

   Set if an arithmetic operation generates a carry or a borrow out of
bit 3 of the result; cleared otherwise. This flag is used in
binary-coded decimal (BCD) arithmetic.

     ZF - Zero flag.

   Set if the result is zero; cleared otherwise.

     SF - Sign flag.

   Set equal to the most-significant bit of the result, which is the
sign bit of a signed integer. (0 indicates a positive value and 1
indicates a negative value.)

     OF - Overflow flag.

   Set if the integer result is too large a positive number or too
small a negative number (excluding the sign-bit) to fit in the
destination operand; cleared otherwise. This flag indicates an overflow
condition for signed- integer (two's complement) arithmetic.


File: nasm.info,  Node: Section B.2.5,  Next: Section B.3,  Prev: Section B.2.4,  Up: Section B.2

B.2.5. Effective Address Encoding: ModR/M and SIB
-------------------------------------------------

An effective address is encoded in up to three parts: a ModR/M byte, an
optional SIB byte, and an optional byte, word or doubleword displacement
field.

   The ModR/M byte consists of three fields: the `mod' field, ranging
from 0 to 3, in the upper two bits of the byte, the `r/m' field,
ranging from 0 to 7, in the lower three bits, and the spare (register)
field in the middle (bit 3 to bit 5). The spare field is not relevant to
the effective address being encoded, and either contains an extension to
the instruction opcode or the register value of another operand.

   The ModR/M system can be used to encode a direct register reference
rather than a memory access. This is always done by setting the `mod'
field to 3 and the `r/m' field to the register value of the register in
question (it must be a general-purpose register, and the size of the
register must already be implicit in the encoding of the rest of the
instruction). In this case, the SIB byte and displacement field are both
absent.

   In 16-bit addressing mode (either `BITS 16' with no `67' prefix, or
`BITS 32' with a `67' prefix), the SIB byte is never used. The general
rules for `mod' and `r/m' (there is an exception, given below) are:

   * The `mod' field gives the length of the displacement field: 0
     means no displacement, 1 means one byte, and 2 means two bytes.

   * The `r/m' field encodes the combination of registers to be added to
     the displacement to give the accessed address: 0 means `BX+SI', 1
     means `BX+DI', 2 means `BP+SI', 3 means `BP+DI', 4 means `SI'
     only, 5 means `DI' only, 6 means `BP' only, and 7 means `BX' only.

   However, there is a special case:

   * If `mod' is 0 and `r/m' is 6, the effective address encoded is not
     `[BP]' as the above rules would suggest, but instead `[disp16]':
     the displacement field is present and is two bytes long, and no
     registers are added to the displacement.

   Therefore the effective address `[BP]' cannot be encoded as
efficiently as `[BX]'; so if you code `[BP]' in a program, NASM adds a
notional 8-bit zero displacement, and sets `mod' to 1, `r/m' to 6, and
the one-byte displacement field to 0.

   In 32-bit addressing mode (either `BITS 16' with a `67' prefix, or
`BITS 32' with no `67' prefix) the general rules (again, there are
exceptions) for `mod' and `r/m' are:

   * The `mod' field gives the length of the displacement field: 0
     means no displacement, 1 means one byte, and 2 means four bytes.

   * If only one register is to be added to the displacement, and it is
     not `ESP', the `r/m' field gives its register value, and the SIB
     byte is absent. If the `r/m' field is 4 (which would encode `ESP'),
     the SIB byte is present and gives the combination and scaling of
     registers to be added to the displacement.

   If the SIB byte is present, it describes the combination of
registers (an optional base register, and an optional index register
scaled by multiplication by 1, 2, 4 or 8) to be added to the
displacement. The SIB byte is divided into the `scale' field, in the
top two bits, the `index' field in the next three, and the `base' field
in the bottom three. The general rules are:

   * The `base' field encodes the register value of the base register.

   * The `index' field encodes the register value of the index register,
     unless it is 4, in which case no index register is used (so `ESP'
     cannot be used as an index register).

   * The `scale' field encodes the multiplier by which the index
     register is scaled before adding it to the base and displacement:
     0 encodes a multiplier of 1, 1 encodes 2, 2 encodes 4 and 3
     encodes 8.

   The exceptions to the 32-bit encoding rules are:

   * If `mod' is 0 and `r/m' is 5, the effective address encoded is not
     `[EBP]' as the above rules would suggest, but instead `[disp32]':
     the displacement field is present and is four bytes long, and no
     registers are added to the displacement.

   * If `mod' is 0, `r/m' is 4 (meaning the SIB byte is present) and
     `base' is 4, the effective address encoded is not `[EBP+index]' as
     the above rules would suggest, but instead `[disp32+index]': the
     displacement field is present and is four bytes long, and there is
     no base register (but the index register is still processed in the
     normal way).


File: nasm.info,  Node: Section B.3,  Next: Section B.4,  Prev: Section B.2.5,  Up: Appendix B

B.3. Key to Instruction Flags
=============================

Given along with each instruction in this appendix is a set of flags,
denoting the type of the instruction. The types are as follows:

   * `8086', `186', `286', `386', `486', `PENT' and `P6' denote the
     lowest processor type that supports the instruction. Most
     instructions run on all processors above the given type; those
     that do not are documented. The Pentium II contains no additional
     instructions beyond the P6 (Pentium Pro); from the point of view
     of its instruction set, it can be thought of as a P6 with MMX
     capability.

   * `3DNOW' indicates that the instruction is a 3DNow! one, and will
     run on the AMD K6-2 and later processors. ATHLON extensions to the
     3DNow!  instruction set are documented as such.

   * `CYRIX' indicates that the instruction is specific to Cyrix
     processors, for example the extra MMX instructions in the Cyrix
     extended MMX instruction set.

   * `FPU' indicates that the instruction is a floating-point one, and
     will only run on machines with a coprocessor (automatically
     including 486DX, Pentium and above).

   * `KATMAI' indicates that the instruction was introduced as part of
     the Katmai New Instruction set. These instructions are available
     on the Pentium III and later processors. Those which are not
     specifically SSE instructions are also available on the AMD Athlon.

   * `MMX' indicates that the instruction is an MMX one, and will run on
     MMX-capable Pentium processors and the Pentium II.

   * `PRIV' indicates that the instruction is a protected-mode
     management instruction. Many of these may only be used in
     protected mode, or only at privilege level zero.

   * `SSE' and `SSE2' indicate that the instruction is a Streaming SIMD
     Extension instruction. These instructions operate on multiple
     values in a single operation. SSE was introduced with the Pentium
     III and SSE2 was introduced with the Pentium 4.

   * `UNDOC' indicates that the instruction is an undocumented one, and
     not part of the official Intel Architecture; it may or may not be
     supported on any given machine.

   * `WILLAMETTE' indicates that the instruction was introduced as part
     of the new instruction set in the Pentium 4 and Intel Xeon
     processors. These instructions are also known as SSE2 instructions.


File: nasm.info,  Node: Section B.4,  Next: Section B.4.1,  Prev: Section B.3,  Up: Appendix B

B.4. x86 Instruction Set
========================

* Menu:

* Section B.4.1:: `AAA', `AAS', `AAM', `AAD': ASCII Adjustments
* Section B.4.2:: `ADC': Add with Carry
* Section B.4.3:: `ADD': Add Integers
* Section B.4.4:: `ADDPD': ADD Packed Double-Precision FP Values
* Section B.4.5:: `ADDPS': ADD Packed Single-Precision FP Values
* Section B.4.6:: `ADDSD': ADD Scalar Double-Precision FP Values
* Section B.4.7:: `ADDSS': ADD Scalar Single-Precision FP Values
* Section B.4.8:: `AND': Bitwise AND
* Section B.4.9:: `ANDNPD': Bitwise Logical AND NOT of Packed Double-Precision FP Values
* Section B.4.10:: `ANDNPS': Bitwise Logical AND NOT of Packed Single-Precision FP Values
* Section B.4.11:: `ANDPD': Bitwise Logical AND For Single FP
* Section B.4.12:: `ANDPS': Bitwise Logical AND For Single FP
* Section B.4.13:: `ARPL': Adjust RPL Field of Selector
* Section B.4.14:: `BOUND': Check Array Index against Bounds
* Section B.4.15:: `BSF', `BSR': Bit Scan
* Section B.4.16:: `BSWAP': Byte Swap
* Section B.4.17:: `BT', `BTC', `BTR', `BTS': Bit Test
* Section B.4.18:: `CALL': Call Subroutine
* Section B.4.19:: `CBW', `CWD', `CDQ', `CWDE': Sign Extensions
* Section B.4.20:: `CLC', `CLD', `CLI', `CLTS': Clear Flags
* Section B.4.21:: `CLFLUSH': Flush Cache Line
* Section B.4.22:: `CMC': Complement Carry Flag
* Section B.4.23:: `CMOVcc': Conditional Move
* Section B.4.24:: `CMP': Compare Integers
* Section B.4.25:: `CMPccPD': Packed Double-Precision FP Compare
* Section B.4.26:: `CMPccPS': Packed Single-Precision FP Compare
* Section B.4.27:: `CMPSB', `CMPSW', `CMPSD': Compare Strings
* Section B.4.28:: `CMPccSD': Scalar Double-Precision FP Compare
* Section B.4.29:: `CMPccSS': Scalar Single-Precision FP Compare
* Section B.4.30:: `CMPXCHG', `CMPXCHG486': Compare and Exchange
* Section B.4.31:: `CMPXCHG8B': Compare and Exchange Eight Bytes
* Section B.4.32:: `COMISD': Scalar Ordered Double-Precision FP Compare and Set EFLAGS
* Section B.4.33:: `COMISS': Scalar Ordered Single-Precision FP Compare and Set EFLAGS
* Section B.4.34:: `CPUID': Get CPU Identification Code
* Section B.4.35:: `CVTDQ2PD': Packed Signed INT32 to Packed Double-Precision FP Conversion
* Section B.4.36:: `CVTDQ2PS': Packed Signed INT32 to Packed Single-Precision FP Conversion
* Section B.4.37:: `CVTPD2DQ': Packed Double-Precision FP to Packed Signed INT32 Conversion
* Section B.4.38:: `CVTPD2PI': Packed Double-Precision FP to Packed Signed INT32 Conversion
* Section B.4.39:: `CVTPD2PS': Packed Double-Precision FP to Packed Single-Precision FP Conversion
* Section B.4.40:: `CVTPI2PD': Packed Signed INT32 to Packed Double-Precision FP Conversion
* Section B.4.41:: `CVTPI2PS': Packed Signed INT32 to Packed Single-FP Conversion
* Section B.4.42:: `CVTPS2DQ': Packed Single-Precision FP to Packed Signed INT32 Conversion
* Section B.4.43:: `CVTPS2PD': Packed Single-Precision FP to Packed Double-Precision FP Conversion
* Section B.4.44:: `CVTPS2PI': Packed Single-Precision FP to Packed Signed INT32 Conversion
* Section B.4.45:: `CVTSD2SI': Scalar Double-Precision FP to Signed INT32 Conversion
* Section B.4.46:: `CVTSD2SS': Scalar Double-Precision FP to Scalar Single-Precision FP Conversion
* Section B.4.47:: `CVTSI2SD': Signed INT32 to Scalar Double-Precision FP Conversion
* Section B.4.48:: `CVTSI2SS': Signed INT32 to Scalar Single-Precision FP Conversion
* Section B.4.49:: `CVTSS2SD': Scalar Single-Precision FP to Scalar Double-Precision FP Conversion
* Section B.4.50:: `CVTSS2SI': Scalar Single-Precision FP to Signed INT32 Conversion
* Section B.4.51:: `CVTTPD2DQ': Packed Double-Precision FP to Packed Signed INT32 Conversion with Truncation
* Section B.4.52:: `CVTTPD2PI': Packed Double-Precision FP to Packed Signed INT32 Conversion with Truncation
* Section B.4.53:: `CVTTPS2DQ': Packed Single-Precision FP to Packed Signed INT32 Conversion with Truncation
* Section B.4.54:: `CVTTPS2PI': Packed Single-Precision FP to Packed Signed INT32 Conversion with Truncation
* Section B.4.55:: `CVTTSD2SI': Scalar Double-Precision FP to Signed INT32 Conversion with Truncation
* Section B.4.56:: `CVTTSS2SI': Scalar Single-Precision FP to Signed INT32 Conversion with Truncation
* Section B.4.57:: `DAA', `DAS': Decimal Adjustments
* Section B.4.58:: `DEC': Decrement Integer
* Section B.4.59:: `DIV': Unsigned Integer Divide
* Section B.4.60:: `DIVPD': Packed Double-Precision FP Divide
* Section B.4.61:: `DIVPS': Packed Single-Precision FP Divide
* Section B.4.62:: `DIVSD': Scalar Double-Precision FP Divide
* Section B.4.63:: `DIVSS': Scalar Single-Precision FP Divide
* Section B.4.64:: `EMMS': Empty MMX State
* Section B.4.65:: `ENTER': Create Stack Frame
* Section B.4.66:: `F2XM1': Calculate 2**X-1
* Section B.4.67:: `FABS': Floating-Point Absolute Value
* Section B.4.68:: `FADD', `FADDP': Floating-Point Addition
* Section B.4.69:: `FBLD', `FBSTP': BCD Floating-Point Load and Store
* Section B.4.70:: `FCHS': Floating-Point Change Sign
* Section B.4.71:: `FCLEX', `FNCLEX': Clear Floating-Point Exceptions
* Section B.4.72:: `FCMOVcc': Floating-Point Conditional Move
* Section B.4.73:: `FCOM', `FCOMP', `FCOMPP', `FCOMI', `FCOMIP': Floating-Point Compare
* Section B.4.74:: `FCOS': Cosine
* Section B.4.75:: `FDECSTP': Decrement Floating-Point Stack Pointer
* Section B.4.76:: `FxDISI', `FxENI': Disable and Enable Floating-Point Interrupts
* Section B.4.77:: `FDIV', `FDIVP', `FDIVR', `FDIVRP': Floating-Point Division
* Section B.4.78:: `FEMMS': Faster Enter/Exit of the MMX or floating-point state
* Section B.4.79:: `FFREE': Flag Floating-Point Register as Unused
* Section B.4.80:: `FIADD': Floating-Point/Integer Addition
* Section B.4.81:: `FICOM', `FICOMP': Floating-Point/Integer Compare
* Section B.4.82:: `FIDIV', `FIDIVR': Floating-Point/Integer Division
* Section B.4.83:: `FILD', `FIST', `FISTP': Floating-Point/Integer Conversion
* Section B.4.84:: `FIMUL': Floating-Point/Integer Multiplication
* Section B.4.85:: `FINCSTP': Increment Floating-Point Stack Pointer
* Section B.4.86:: `FINIT', `FNINIT': Initialise Floating-Point Unit
* Section B.4.87:: `FISUB': Floating-Point/Integer Subtraction
* Section B.4.88:: `FLD': Floating-Point Load
* Section B.4.89:: `FLDxx': Floating-Point Load Constants
* Section B.4.90:: `FLDCW': Load Floating-Point Control Word
* Section B.4.91:: `FLDENV': Load Floating-Point Environment
* Section B.4.92:: `FMUL', `FMULP': Floating-Point Multiply
* Section B.4.93:: `FNOP': Floating-Point No Operation
* Section B.4.94:: `FPATAN', `FPTAN': Arctangent and Tangent
* Section B.4.95:: `FPREM', `FPREM1': Floating-Point Partial Remainder
* Section B.4.96:: `FRNDINT': Floating-Point Round to Integer
* Section B.4.97:: `FSAVE', `FRSTOR': Save/Restore Floating-Point State
* Section B.4.98:: `FSCALE': Scale Floating-Point Value by Power of Two
* Section B.4.99:: `FSETPM': Set Protected Mode
* Section B.4.100:: `FSIN', `FSINCOS': Sine and Cosine
* Section B.4.101:: `FSQRT': Floating-Point Square Root
* Section B.4.102:: `FST', `FSTP': Floating-Point Store
* Section B.4.103:: `FSTCW': Store Floating-Point Control Word
* Section B.4.104:: `FSTENV': Store Floating-Point Environment
* Section B.4.105:: `FSTSW': Store Floating-Point Status Word
* Section B.4.106:: `FSUB', `FSUBP', `FSUBR', `FSUBRP': Floating-Point Subtract
* Section B.4.107:: `FTST': Test `ST0' Against Zero
* Section B.4.108:: `FUCOMxx': Floating-Point Unordered Compare
* Section B.4.109:: `FXAM': Examine Class of Value in `ST0'
* Section B.4.110:: `FXCH': Floating-Point Exchange
* Section B.4.111:: `FXRSTOR': Restore `FP', `MMX' and `SSE' State
* Section B.4.112:: `FXSAVE': Store `FP', `MMX' and `SSE' State
* Section B.4.113:: `FXTRACT': Extract Exponent and Significand
* Section B.4.114:: `FYL2X', `FYL2XP1': Compute Y times Log2(X) or Log2(X+1)
* Section B.4.115:: `HLT': Halt Processor
* Section B.4.116:: `IBTS': Insert Bit String
* Section B.4.117:: `IDIV': Signed Integer Divide
* Section B.4.118:: `IMUL': Signed Integer Multiply
* Section B.4.119:: `IN': Input from I/O Port
* Section B.4.120:: `INC': Increment Integer
* Section B.4.121:: `INSB', `INSW', `INSD': Input String from I/O Port
* Section B.4.122:: `INT': Software Interrupt
* Section B.4.123:: `INT3', `INT1', `ICEBP', `INT01': Breakpoints
* Section B.4.124:: `INTO': Interrupt if Overflow
* Section B.4.125:: `INVD': Invalidate Internal Caches
* Section B.4.126:: `INVLPG': Invalidate TLB Entry
* Section B.4.127:: `IRET', `IRETW', `IRETD': Return from Interrupt
* Section B.4.128:: `Jcc': Conditional Branch
* Section B.4.129:: `JCXZ', `JECXZ': Jump if CX/ECX Zero
* Section B.4.130:: `JMP': Jump
* Section B.4.131:: `LAHF': Load AH from Flags
* Section B.4.132:: `LAR': Load Access Rights
* Section B.4.133:: `LDMXCSR': Load Streaming SIMD Extension Control/Status
* Section B.4.134:: `LDS', `LES', `LFS', `LGS', `LSS': Load Far Pointer
* Section B.4.135:: `LEA': Load Effective Address
* Section B.4.136:: `LEAVE': Destroy Stack Frame
* Section B.4.137:: `LFENCE': Load Fence
* Section B.4.138:: `LGDT', `LIDT', `LLDT': Load Descriptor Tables
* Section B.4.139:: `LMSW': Load/Store Machine Status Word
* Section B.4.140:: `LOADALL', `LOADALL286': Load Processor State
* Section B.4.141:: `LODSB', `LODSW', `LODSD': Load from String
* Section B.4.142:: `LOOP', `LOOPE', `LOOPZ', `LOOPNE', `LOOPNZ': Loop with Counter
* Section B.4.143:: `LSL': Load Segment Limit
* Section B.4.144:: `LTR': Load Task Register
* Section B.4.145:: `MASKMOVDQU': Byte Mask Write
* Section B.4.146:: `MASKMOVQ': Byte Mask Write
* Section B.4.147:: `MAXPD': Return Packed Double-Precision FP Maximum
* Section B.4.148:: `MAXPS': Return Packed Single-Precision FP Maximum
* Section B.4.149:: `MAXSD': Return Scalar Double-Precision FP Maximum
* Section B.4.150:: `MAXSS': Return Scalar Single-Precision FP Maximum
* Section B.4.151:: `MFENCE': Memory Fence
* Section B.4.152:: `MINPD': Return Packed Double-Precision FP Minimum
* Section B.4.153:: `MINPS': Return Packed Single-Precision FP Minimum
* Section B.4.154:: `MINSD': Return Scalar Double-Precision FP Minimum
* Section B.4.155:: `MINSS': Return Scalar Single-Precision FP Minimum
* Section B.4.156:: `MOV': Move Data
* Section B.4.157:: `MOVAPD': Move Aligned Packed Double-Precision FP Values
* Section B.4.158:: `MOVAPS': Move Aligned Packed Single-Precision FP Values
* Section B.4.159:: `MOVD': Move Doubleword to/from MMX Register
* Section B.4.160:: `MOVDQ2Q': Move Quadword from XMM to MMX register.
* Section B.4.161:: `MOVDQA': Move Aligned Double Quadword
* Section B.4.162:: `MOVDQU': Move Unaligned Double Quadword
* Section B.4.163:: `MOVHLPS': Move Packed Single-Precision FP High to Low
* Section B.4.164:: `MOVHPD': Move High Packed Double-Precision FP
* Section B.4.165:: `MOVHPS': Move High Packed Single-Precision FP
* Section B.4.166:: `MOVLHPS': Move Packed Single-Precision FP Low to High
* Section B.4.167:: `MOVLPD': Move Low Packed Double-Precision FP
* Section B.4.168:: `MOVLPS': Move Low Packed Single-Precision FP
* Section B.4.169:: `MOVMSKPD': Extract Packed Double-Precision FP Sign Mask
* Section B.4.170:: `MOVMSKPS': Extract Packed Single-Precision FP Sign Mask
* Section B.4.171:: `MOVNTDQ': Move Double Quadword Non Temporal
* Section B.4.172:: `MOVNTI': Move Doubleword Non Temporal
* Section B.4.173:: `MOVNTPD': Move Aligned Four Packed Single-Precision FP Values Non Temporal
* Section B.4.174:: `MOVNTPS': Move Aligned Four Packed Single-Precision FP Values Non Temporal
* Section B.4.175:: `MOVNTQ': Move Quadword Non Temporal
* Section B.4.176:: `MOVQ': Move Quadword to/from MMX Register
* Section B.4.177:: `MOVQ2DQ': Move Quadword from MMX to XMM register.
* Section B.4.178:: `MOVSB', `MOVSW', `MOVSD': Move String
* Section B.4.179:: `MOVSD': Move Scalar Double-Precision FP Value
* Section B.4.180:: `MOVSS': Move Scalar Single-Precision FP Value
* Section B.4.181:: `MOVSX', `MOVZX': Move Data with Sign or Zero Extend
* Section B.4.182:: `MOVUPD': Move Unaligned Packed Double-Precision FP Values
* Section B.4.183:: `MOVUPS': Move Unaligned Packed Single-Precision FP Values
* Section B.4.184:: `MUL': Unsigned Integer Multiply
* Section B.4.185:: `MULPD': Packed Single-FP Multiply
* Section B.4.186:: `MULPS': Packed Single-FP Multiply
* Section B.4.187:: `MULSD': Scalar Single-FP Multiply
* Section B.4.188:: `MULSS': Scalar Single-FP Multiply
* Section B.4.189:: `NEG', `NOT': Two's and One's Complement
* Section B.4.190:: `NOP': No Operation
* Section B.4.191:: `OR': Bitwise OR
* Section B.4.192:: `ORPD': Bit-wise Logical OR of Double-Precision FP Data
* Section B.4.193:: `ORPS': Bit-wise Logical OR of Single-Precision FP Data
* Section B.4.194:: `OUT': Output Data to I/O Port
* Section B.4.195:: `OUTSB', `OUTSW', `OUTSD': Output String to I/O Port
* Section B.4.196:: `PACKSSDW', `PACKSSWB', `PACKUSWB': Pack Data
* Section B.4.197:: `PADDB', `PADDW', `PADDD': Add Packed Integers
* Section B.4.198:: `PADDQ': Add Packed Quadword Integers
* Section B.4.199:: `PADDSB', `PADDSW': Add Packed Signed Integers With Saturation
* Section B.4.200:: `PADDSIW': MMX Packed Addition to Implicit Destination
* Section B.4.201:: `PADDUSB', `PADDUSW': Add Packed Unsigned Integers With Saturation
* Section B.4.202:: `PAND', `PANDN': MMX Bitwise AND and AND-NOT
* Section B.4.203:: `PAUSE': Spin Loop Hint
* Section B.4.204:: `PAVEB': MMX Packed Average
* Section B.4.205:: `PAVGB' `PAVGW': Average Packed Integers
* Section B.4.206:: `PAVGUSB': Average of unsigned packed 8-bit values
* Section B.4.207:: `PCMPxx': Compare Packed Integers.
* Section B.4.208:: `PDISTIB': MMX Packed Distance and Accumulate with Implied Register
* Section B.4.209:: `PEXTRW': Extract Word
* Section B.4.210:: `PF2ID': Packed Single-Precision FP to Integer Convert
* Section B.4.211:: `PF2IW': Packed Single-Precision FP to Integer Word Convert
* Section B.4.212:: `PFACC': Packed Single-Precision FP Accumulate
* Section B.4.213:: `PFADD': Packed Single-Precision FP Addition
* Section B.4.214:: `PFCMPxx': Packed Single-Precision FP Compare
* Section B.4.215:: `PFMAX': Packed Single-Precision FP Maximum
* Section B.4.216:: `PFMIN': Packed Single-Precision FP Minimum
* Section B.4.217:: `PFMUL': Packed Single-Precision FP Multiply
* Section B.4.218:: `PFNACC': Packed Single-Precision FP Negative Accumulate
* Section B.4.219:: `PFPNACC': Packed Single-Precision FP Mixed Accumulate
* Section B.4.220:: `PFRCP': Packed Single-Precision FP Reciprocal Approximation
* Section B.4.221:: `PFRCPIT1': Packed Single-Precision FP Reciprocal, First Iteration Step
* Section B.4.222:: `PFRCPIT2': Packed Single-Precision FP Reciprocal/ Reciprocal Square Root, Second Iteration Step
* Section B.4.223:: `PFRSQIT1': Packed Single-Precision FP Reciprocal Square Root, First Iteration Step
* Section B.4.224:: `PFRSQRT': Packed Single-Precision FP Reciprocal Square Root Approximation
* Section B.4.225:: `PFSUB': Packed Single-Precision FP Subtract
* Section B.4.226:: `PFSUBR': Packed Single-Precision FP Reverse Subtract
* Section B.4.227:: `PI2FD': Packed Doubleword Integer to Single-Precision FP Convert
* Section B.4.228:: `PF2IW': Packed Word Integer to Single-Precision FP Convert
* Section B.4.229:: `PINSRW': Insert Word
* Section B.4.230:: `PMACHRIW': Packed Multiply and Accumulate with Rounding
* Section B.4.231:: `PMADDWD': MMX Packed Multiply and Add
* Section B.4.232:: `PMAGW': MMX Packed Magnitude
* Section B.4.233:: `PMAXSW': Packed Signed Integer Word Maximum
* Section B.4.234:: `PMAXUB': Packed Unsigned Integer Byte Maximum
* Section B.4.235:: `PMINSW': Packed Signed Integer Word Minimum
* Section B.4.236:: `PMINUB': Packed Unsigned Integer Byte Minimum
* Section B.4.237:: `PMOVMSKB': Move Byte Mask To Integer
* Section B.4.238:: `PMULHRWC', `PMULHRIW': Multiply Packed 16-bit Integers With Rounding, and Store High Word
* Section B.4.239:: `PMULHRWA': Multiply Packed 16-bit Integers With Rounding, and Store High Word
* Section B.4.240:: `PMULHUW': Multiply Packed 16-bit Integers, and Store High Word
* Section B.4.241:: `PMULHW', `PMULLW': Multiply Packed 16-bit Integers, and Store
* Section B.4.242:: `PMULUDQ': Multiply Packed Unsigned 32-bit Integers, and Store.
* Section B.4.243:: `PMVccZB': MMX Packed Conditional Move
* Section B.4.244:: `POP': Pop Data from Stack
* Section B.4.245:: `POPAx': Pop All General-Purpose Registers
* Section B.4.246:: `POPFx': Pop Flags Register
* Section B.4.247:: `POR': MMX Bitwise OR
* Section B.4.248:: `PREFETCH': Prefetch Data Into Caches
* Section B.4.249:: `PREFETCHh': Prefetch Data Into Caches
* Section B.4.250:: `PSADBW': Packed Sum of Absolute Differences
* Section B.4.251:: `PSHUFD': Shuffle Packed Doublewords
* Section B.4.252:: `PSHUFHW': Shuffle Packed High Words
* Section B.4.253:: `PSHUFLW': Shuffle Packed Low Words
* Section B.4.254:: `PSHUFW': Shuffle Packed Words
* Section B.4.255:: `PSLLx': Packed Data Bit Shift Left Logical
* Section B.4.256:: `PSRAx': Packed Data Bit Shift Right Arithmetic
* Section B.4.257:: `PSRLx': Packed Data Bit Shift Right Logical
* Section B.4.258:: `PSUBx': Subtract Packed Integers
* Section B.4.259:: `PSUBSxx', `PSUBUSx': Subtract Packed Integers With Saturation
* Section B.4.260:: `PSUBSIW': MMX Packed Subtract with Saturation to Implied Destination
* Section B.4.261:: `PSWAPD': Swap Packed Data
* Section B.4.262:: `PUNPCKxxx': Unpack and Interleave Data
* Section B.4.263:: `PUSH': Push Data on Stack
* Section B.4.264:: `PUSHAx': Push All General-Purpose Registers
* Section B.4.265:: `PUSHFx': Push Flags Register
* Section B.4.266:: `PXOR': MMX Bitwise XOR
* Section B.4.267:: `RCL', `RCR': Bitwise Rotate through Carry Bit
* Section B.4.268:: `RCPPS': Packed Single-Precision FP Reciprocal
* Section B.4.269:: `RCPSS': Scalar Single-Precision FP Reciprocal
* Section B.4.270:: `RDMSR': Read Model-Specific Registers
* Section B.4.271:: `RDPMC': Read Performance-Monitoring Counters
* Section B.4.272:: `RDSHR': Read SMM Header Pointer Register
* Section B.4.273:: `RDTSC': Read Time-Stamp Counter
* Section B.4.274:: `RET', `RETF', `RETN': Return from Procedure Call
* Section B.4.275:: `ROL', `ROR': Bitwise Rotate
* Section B.4.276:: `RSDC': Restore Segment Register and Descriptor
* Section B.4.277:: `RSLDT': Restore Segment Register and Descriptor
* Section B.4.278:: `RSM': Resume from System-Management Mode
* Section B.4.279:: `RSQRTPS': Packed Single-Precision FP Square Root Reciprocal
* Section B.4.280:: `RSQRTSS': Scalar Single-Precision FP Square Root Reciprocal
* Section B.4.281:: `RSTS': Restore TSR and Descriptor
* Section B.4.282:: `SAHF': Store AH to Flags
* Section B.4.283:: `SAL', `SAR': Bitwise Arithmetic Shifts
* Section B.4.284:: `SALC': Set AL from Carry Flag
* Section B.4.285:: `SBB': Subtract with Borrow
* Section B.4.286:: `SCASB', `SCASW', `SCASD': Scan String
* Section B.4.287:: `SETcc': Set Register from Condition
* Section B.4.288:: `SFENCE': Store Fence
* Section B.4.289:: `SGDT', `SIDT', `SLDT': Store Descriptor Table Pointers
* Section B.4.290:: `SHL', `SHR': Bitwise Logical Shifts
* Section B.4.291:: `SHLD', `SHRD': Bitwise Double-Precision Shifts
* Section B.4.292:: `SHUFPD': Shuffle Packed Double-Precision FP Values
* Section B.4.293:: `SHUFPS': Shuffle Packed Single-Precision FP Values
* Section B.4.294:: `SMI': System Management Interrupt
* Section B.4.295:: `SMINT', `SMINTOLD': Software SMM Entry (CYRIX)
* Section B.4.296:: `SMSW': Store Machine Status Word
* Section B.4.297:: `SQRTPD': Packed Double-Precision FP Square Root
* Section B.4.298:: `SQRTPS': Packed Single-Precision FP Square Root
* Section B.4.299:: `SQRTSD': Scalar Double-Precision FP Square Root
* Section B.4.300:: `SQRTSS': Scalar Single-Precision FP Square Root
* Section B.4.301:: `STC', `STD', `STI': Set Flags
* Section B.4.302:: `STMXCSR': Store Streaming SIMD Extension Control/Status
* Section B.4.303:: `STOSB', `STOSW', `STOSD': Store Byte to String
* Section B.4.304:: `STR': Store Task Register
* Section B.4.305:: `SUB': Subtract Integers
* Section B.4.306:: `SUBPD': Packed Double-Precision FP Subtract
* Section B.4.307:: `SUBPS': Packed Single-Precision FP Subtract
* Section B.4.308:: `SUBSD': Scalar Single-FP Subtract
* Section B.4.309:: `SUBSS': Scalar Single-FP Subtract
* Section B.4.310:: `SVDC': Save Segment Register and Descriptor
* Section B.4.311:: `SVLDT': Save LDTR and Descriptor
* Section B.4.312:: `SVTS': Save TSR and Descriptor
* Section B.4.313:: `SYSCALL': Call Operating System
* Section B.4.314:: `SYSENTER': Fast System Call
* Section B.4.315:: `SYSEXIT': Fast Return From System Call
* Section B.4.316:: `SYSRET': Return From Operating System
* Section B.4.317:: `TEST': Test Bits (notional bitwise AND)
* Section B.4.318:: `UCOMISD': Unordered Scalar Double-Precision FP compare and set EFLAGS
* Section B.4.319:: `UCOMISS': Unordered Scalar Single-Precision FP compare and set EFLAGS
* Section B.4.320:: `UD0', `UD1', `UD2': Undefined Instruction
* Section B.4.321:: `UMOV': User Move Data
* Section B.4.322:: `UNPCKHPD': Unpack and Interleave High Packed Double-Precision FP Values
* Section B.4.323:: `UNPCKHPS': Unpack and Interleave High Packed Single-Precision FP Values
* Section B.4.324:: `UNPCKLPD': Unpack and Interleave Low Packed Double-Precision FP Data
* Section B.4.325:: `UNPCKLPS': Unpack and Interleave Low Packed Single-Precision FP Data
* Section B.4.326:: `VERR', `VERW': Verify Segment Readability/Writability
* Section B.4.327:: `WAIT': Wait for Floating-Point Processor
* Section B.4.328:: `WBINVD': Write Back and Invalidate Cache
* Section B.4.329:: `WRMSR': Write Model-Specific Registers
* Section B.4.330:: `WRSHR': Write SMM Header Pointer Register
* Section B.4.331:: `XADD': Exchange and Add
* Section B.4.332:: `XBTS': Extract Bit String
* Section B.4.333:: `XCHG': Exchange
* Section B.4.334:: `XLATB': Translate Byte in Lookup Table
* Section B.4.335:: `XOR': Bitwise Exclusive OR
* Section B.4.336:: `XORPD': Bitwise Logical XOR of Double-Precision FP Values
* Section B.4.337:: `XORPS': Bitwise Logical XOR of Single-Precision FP Values


File: nasm.info,  Node: Section B.4.1,  Next: Section B.4.2,  Prev: Section B.4,  Up: Section B.4

B.4.1. `AAA', `AAS', `AAM', `AAD': ASCII Adjustments
----------------------------------------------------

     AAA                           ; 37                   [8086]

     AAS                           ; 3F                   [8086]

     AAD                           ; D5 0A                [8086]
     AAD imm                       ; D5 ib                [8086]

     AAM                           ; D4 0A                [8086]
     AAM imm                       ; D4 ib                [8086]

   These instructions are used in conjunction with the add, subtract,
multiply and divide instructions to perform binary-coded decimal
arithmetic in _unpacked_ (one BCD digit per byte - easy to translate to
and from `ASCII', hence the instruction names) form. There are also
packed BCD instructions `DAA' and `DAS': see *Note Section B.4.57::.

   * `AAA' (ASCII Adjust After Addition) should be used after a one-byte
     `ADD' instruction whose destination was the `AL' register: by
     means of examining the value in the low nibble of `AL' and also the
     auxiliary carry flag `AF', it determines whether the addition has
     overflowed, and adjusts it (and sets the carry flag) if so. You
     can add long BCD strings together by doing `ADD'/`AAA' on the low
     digits, then doing `ADC'/`AAA' on each subsequent digit.

   * `AAS' (ASCII Adjust AL After Subtraction) works similarly to
     `AAA', but is for use after `SUB' instructions rather than `ADD'.

   * `AAM' (ASCII Adjust AX After Multiply) is for use after you have
     multiplied two decimal digits together and left the result in
     `AL': it divides `AL' by ten and stores the quotient in `AH',
     leaving the remainder in `AL'. The divisor 10 can be changed by
     specifying an operand to the instruction: a particularly handy use
     of this is `AAM 16', causing the two nibbles in `AL' to be
     separated into `AH' and `AL'.

   * `AAD' (ASCII Adjust AX Before Division) performs the inverse
     operation to `AAM': it multiplies `AH' by ten, adds it to `AL', and
     sets `AH' to zero. Again, the multiplier 10 can be changed.


File: nasm.info,  Node: Section B.4.2,  Next: Section B.4.3,  Prev: Section B.4.1,  Up: Section B.4

B.4.2. `ADC': Add with Carry
----------------------------

     ADC r/m8,reg8                 ; 10 /r                [8086]
     ADC r/m16,reg16               ; o16 11 /r            [8086]
     ADC r/m32,reg32               ; o32 11 /r            [386]

     ADC reg8,r/m8                 ; 12 /r                [8086]
     ADC reg16,r/m16               ; o16 13 /r            [8086]
     ADC reg32,r/m32               ; o32 13 /r            [386]

     ADC r/m8,imm8                 ; 80 /2 ib             [8086]
     ADC r/m16,imm16               ; o16 81 /2 iw         [8086]
     ADC r/m32,imm32               ; o32 81 /2 id         [386]

     ADC r/m16,imm8                ; o16 83 /2 ib         [8086]
     ADC r/m32,imm8                ; o32 83 /2 ib         [386]

     ADC AL,imm8                   ; 14 ib                [8086]
     ADC AX,imm16                  ; o16 15 iw            [8086]
     ADC EAX,imm32                 ; o32 15 id            [386]

   `ADC' performs integer addition: it adds its two operands together,
plus the value of the carry flag, and leaves the result in its
destination (first) operand. The destination operand can be a register
or a memory location. The source operand can be a register, a memory
location or an immediate value.

   The flags are set according to the result of the operation: in
particular, the carry flag is affected and can be used by a subsequent
`ADC' instruction.

   In the forms with an 8-bit immediate second operand and a longer
first operand, the second operand is considered to be signed, and is
sign- extended to the length of the first operand. In these cases, the
`BYTE' qualifier is necessary to force NASM to generate this form of
the instruction.

   To add two numbers without also adding the contents of the carry
flag, use `ADD' (*Note Section B.4.3::).


File: nasm.info,  Node: Section B.4.3,  Next: Section B.4.4,  Prev: Section B.4.2,  Up: Section B.4

B.4.3. `ADD': Add Integers
--------------------------

     ADD r/m8,reg8                 ; 00 /r                [8086]
     ADD r/m16,reg16               ; o16 01 /r            [8086]
     ADD r/m32,reg32               ; o32 01 /r            [386]

     ADD reg8,r/m8                 ; 02 /r                [8086]
     ADD reg16,r/m16               ; o16 03 /r            [8086]
     ADD reg32,r/m32               ; o32 03 /r            [386]

     ADD r/m8,imm8                 ; 80 /7 ib             [8086]
     ADD r/m16,imm16               ; o16 81 /7 iw         [8086]
     ADD r/m32,imm32               ; o32 81 /7 id         [386]

     ADD r/m16,imm8                ; o16 83 /7 ib         [8086]
     ADD r/m32,imm8                ; o32 83 /7 ib         [386]

     ADD AL,imm8                   ; 04 ib                [8086]
     ADD AX,imm16                  ; o16 05 iw            [8086]
     ADD EAX,imm32                 ; o32 05 id            [386]

   `ADD' performs integer addition: it adds its two operands together,
and leaves the result in its destination (first) operand. The
destination operand can be a register or a memory location. The source
operand can be a register, a memory location or an immediate value.

   The flags are set according to the result of the operation: in
particular, the carry flag is affected and can be used by a subsequent
`ADC' instruction.

   In the forms with an 8-bit immediate second operand and a longer
first operand, the second operand is considered to be signed, and is
sign- extended to the length of the first operand. In these cases, the
`BYTE' qualifier is necessary to force NASM to generate this form of
the instruction.


File: nasm.info,  Node: Section B.4.4,  Next: Section B.4.5,  Prev: Section B.4.3,  Up: Section B.4

B.4.4. `ADDPD': ADD Packed Double-Precision FP Values
-----------------------------------------------------

     ADDPD xmm1,xmm2/mem128        ; 66 0F 58 /r     [WILLAMETTE,SSE2]

   `ADDPD' performs addition on each of two packed double-precision FP
value pairs.

        dst[0-63]   := dst[0-63]   + src[0-63],
        dst[64-127] := dst[64-127] + src[64-127].

   The destination is an `XMM' register. The source operand can be
either an `XMM' register or a 128-bit memory location.


File: nasm.info,  Node: Section B.4.5,  Next: Section B.4.6,  Prev: Section B.4.4,  Up: Section B.4

B.4.5. `ADDPS': ADD Packed Single-Precision FP Values
-----------------------------------------------------

     ADDPS xmm1,xmm2/mem128        ; 0F 58 /r        [KATMAI,SSE]

   `ADDPS' performs addition on each of four packed single-precision FP
value pairs

        dst[0-31]   := dst[0-31]   + src[0-31],
        dst[32-63]  := dst[32-63]  + src[32-63],
        dst[64-95]  := dst[64-95]  + src[64-95],
        dst[96-127] := dst[96-127] + src[96-127].

   The destination is an `XMM' register. The source operand can be
either an `XMM' register or a 128-bit memory location.


File: nasm.info,  Node: Section B.4.6,  Next: Section B.4.7,  Prev: Section B.4.5,  Up: Section B.4

B.4.6. `ADDSD': ADD Scalar Double-Precision FP Values
-----------------------------------------------------

     ADDSD xmm1,xmm2/mem64         ; F2 0F 58 /r     [KATMAI,SSE]

   `ADDSD' adds the low double-precision FP values from the source and
destination operands and stores the double-precision FP result in the
destination operand.

        dst[0-63]   := dst[0-63] + src[0-63],
        dst[64-127) remains unchanged.

   The destination is an `XMM' register. The source operand can be
either an `XMM' register or a 64-bit memory location.


File: nasm.info,  Node: Section B.4.7,  Next: Section B.4.8,  Prev: Section B.4.6,  Up: Section B.4

B.4.7. `ADDSS': ADD Scalar Single-Precision FP Values
-----------------------------------------------------

     ADDSS xmm1,xmm2/mem32         ; F3 0F 58 /r     [WILLAMETTE,SSE2]

   `ADDSS' adds the low single-precision FP values from the source and
destination operands and stores the single-precision FP result in the
destination operand.

        dst[0-31]   := dst[0-31] + src[0-31],
        dst[32-127] remains unchanged.

   The destination is an `XMM' register. The source operand can be
either an `XMM' register or a 32-bit memory location.


File: nasm.info,  Node: Section B.4.8,  Next: Section B.4.9,  Prev: Section B.4.7,  Up: Section B.4

B.4.8. `AND': Bitwise AND
-------------------------

     AND r/m8,reg8                 ; 20 /r                [8086]
     AND r/m16,reg16               ; o16 21 /r            [8086]
     AND r/m32,reg32               ; o32 21 /r            [386]

     AND reg8,r/m8                 ; 22 /r                [8086]
     AND reg16,r/m16               ; o16 23 /r            [8086]
     AND reg32,r/m32               ; o32 23 /r            [386]

     AND r/m8,imm8                 ; 80 /4 ib             [8086]
     AND r/m16,imm16               ; o16 81 /4 iw         [8086]
     AND r/m32,imm32               ; o32 81 /4 id         [386]

     AND r/m16,imm8                ; o16 83 /4 ib         [8086]
     AND r/m32,imm8                ; o32 83 /4 ib         [386]

     AND AL,imm8                   ; 24 ib                [8086]
     AND AX,imm16                  ; o16 25 iw            [8086]
     AND EAX,imm32                 ; o32 25 id            [386]

   `AND' performs a bitwise AND operation between its two operands (i.e.
each bit of the result is 1 if and only if the corresponding bits of the
two inputs were both 1), and stores the result in the destination
(first) operand. The destination operand can be a register or a memory
location.  The source operand can be a register, a memory location or
an immediate value.

   In the forms with an 8-bit immediate second operand and a longer
first operand, the second operand is considered to be signed, and is
sign- extended to the length of the first operand. In these cases, the
`BYTE' qualifier is necessary to force NASM to generate this form of
the instruction.

   The `MMX' instruction `PAND' (see *Note Section B.4.202::) performs
the same operation on the 64-bit `MMX' registers.


File: nasm.info,  Node: Section B.4.9,  Next: Section B.4.10,  Prev: Section B.4.8,  Up: Section B.4

B.4.9. `ANDNPD': Bitwise Logical AND NOT of Packed Double-Precision FP Values
-----------------------------------------------------------------------------

     ANDNPD xmm1,xmm2/mem128       ; 66 0F 55 /r     [WILLAMETTE,SSE2]

   `ANDNPD' inverts the bits of the two double-precision floating-point
values in the destination register, and then performs a logical AND
between the two double-precision floating-point values in the source
operand and the temporary inverted result, storing the result in the
destination register.

        dst[0-63]   := src[0-63]   AND NOT dst[0-63],
        dst[64-127] := src[64-127] AND NOT dst[64-127].

   The destination is an `XMM' register. The source operand can be
either an `XMM' register or a 128-bit memory location.


File: nasm.info,  Node: Section B.4.10,  Next: Section B.4.11,  Prev: Section B.4.9,  Up: Section B.4

B.4.10. `ANDNPS': Bitwise Logical AND NOT of Packed Single-Precision FP Values
------------------------------------------------------------------------------

     ANDNPS xmm1,xmm2/mem128       ; 0F 55 /r        [KATMAI,SSE]

   `ANDNPS' inverts the bits of the four single-precision floating-point
values in the destination register, and then performs a logical AND
between the four single-precision floating-point values in the source
operand and the temporary inverted result, storing the result in the
destination register.

        dst[0-31]   := src[0-31]   AND NOT dst[0-31],
        dst[32-63]  := src[32-63]  AND NOT dst[32-63],
        dst[64-95]  := src[64-95]  AND NOT dst[64-95],
        dst[96-127] := src[96-127] AND NOT dst[96-127].

   The destination is an `XMM' register. The source operand can be
either an `XMM' register or a 128-bit memory location.


File: nasm.info,  Node: Section B.4.11,  Next: Section B.4.12,  Prev: Section B.4.10,  Up: Section B.4

B.4.11. `ANDPD': Bitwise Logical AND For Single FP
--------------------------------------------------

     ANDPD xmm1,xmm2/mem128        ; 66 0F 54 /r     [WILLAMETTE,SSE2]

   `ANDPD' performs a bitwise logical AND of the two double-precision
floating point values in the source and destination operand, and stores
the result in the destination register.

        dst[0-63]   := src[0-63]   AND dst[0-63],
        dst[64-127] := src[64-127] AND dst[64-127].

   The destination is an `XMM' register. The source operand can be
either an `XMM' register or a 128-bit memory location.


File: nasm.info,  Node: Section B.4.12,  Next: Section B.4.13,  Prev: Section B.4.11,  Up: Section B.4

B.4.12. `ANDPS': Bitwise Logical AND For Single FP
--------------------------------------------------

     ANDPS xmm1,xmm2/mem128        ; 0F 54 /r        [KATMAI,SSE]

   `ANDPS' performs a bitwise logical AND of the four single-precision
floating point values in the source and destination operand, and stores
the result in the destination register.

        dst[0-31]   := src[0-31]   AND dst[0-31],
        dst[32-63]  := src[32-63]  AND dst[32-63],
        dst[64-95]  := src[64-95]  AND dst[64-95],
        dst[96-127] := src[96-127] AND dst[96-127].

   The destination is an `XMM' register. The source operand can be
either an `XMM' register or a 128-bit memory location.


File: nasm.info,  Node: Section B.4.13,  Next: Section B.4.14,  Prev: Section B.4.12,  Up: Section B.4

B.4.13. `ARPL': Adjust RPL Field of Selector
--------------------------------------------

     ARPL r/m16,reg16              ; 63 /r                [286,PRIV]

   `ARPL' expects its two word operands to be segment selectors. It
adjusts the `RPL' (requested privilege level - stored in the bottom two
bits of the selector) field of the destination (first) operand to
ensure that it is no less (i.e. no more privileged than) the `RPL'
field of the source operand. The zero flag is set if and only if a
change had to be made.


File: nasm.info,  Node: Section B.4.14,  Next: Section B.4.15,  Prev: Section B.4.13,  Up: Section B.4

B.4.14. `BOUND': Check Array Index against Bounds
-------------------------------------------------

     BOUND reg16,mem               ; o16 62 /r            [186]
     BOUND reg32,mem               ; o32 62 /r            [386]

   `BOUND' expects its second operand to point to an area of memory
containing two signed values of the same size as its first operand (i.e.
two words for the 16-bit form; two doublewords for the 32-bit form). It
performs two signed comparisons: if the value in the register passed as
its first operand is less than the first of the in-memory values, or is
greater than or equal to the second, it throws a `BR' exception.
Otherwise, it does nothing.


File: nasm.info,  Node: Section B.4.15,  Next: Section B.4.16,  Prev: Section B.4.14,  Up: Section B.4

B.4.15. `BSF', `BSR': Bit Scan
------------------------------

     BSF reg16,r/m16               ; o16 0F BC /r         [386]
     BSF reg32,r/m32               ; o32 0F BC /r         [386]

     BSR reg16,r/m16               ; o16 0F BD /r         [386]
     BSR reg32,r/m32               ; o32 0F BD /r         [386]

   * `BSF' searches for the least significant set bit in its source
     (second) operand, and if it finds one, stores the index in its
     destination (first) operand. If no set bit is found, the contents
     of the destination operand are undefined. If the source operand is
     zero, the zero flag is set.

   * `BSR' performs the same function, but searches from the top
     instead, so it finds the most significant set bit.

   Bit indices are from 0 (least significant) to 15 or 31 (most
significant).  The destination operand can only be a register. The
source operand can be a register or a memory location.


File: nasm.info,  Node: Section B.4.16,  Next: Section B.4.17,  Prev: Section B.4.15,  Up: Section B.4

B.4.16. `BSWAP': Byte Swap
--------------------------

     BSWAP reg32                   ; o32 0F C8+r          [486]

   `BSWAP' swaps the order of the four bytes of a 32-bit register: bits
0-7 exchange places with bits 24-31, and bits 8-15 swap with bits 16-23.
There is no explicit 16-bit equivalent: to byte-swap `AX', `BX', `CX'
or `DX', `XCHG' can be used. When `BSWAP' is used with a 16-bit
register, the result is undefined.


File: nasm.info,  Node: Section B.4.17,  Next: Section B.4.18,  Prev: Section B.4.16,  Up: Section B.4

B.4.17. `BT', `BTC', `BTR', `BTS': Bit Test
-------------------------------------------

     BT r/m16,reg16                ; o16 0F A3 /r         [386]
     BT r/m32,reg32                ; o32 0F A3 /r         [386]
     BT r/m16,imm8                 ; o16 0F BA /4 ib      [386]
     BT r/m32,imm8                 ; o32 0F BA /4 ib      [386]

     BTC r/m16,reg16               ; o16 0F BB /r         [386]
     BTC r/m32,reg32               ; o32 0F BB /r         [386]
     BTC r/m16,imm8                ; o16 0F BA /7 ib      [386]
     BTC r/m32,imm8                ; o32 0F BA /7 ib      [386]

     BTR r/m16,reg16               ; o16 0F B3 /r         [386]
     BTR r/m32,reg32               ; o32 0F B3 /r         [386]
     BTR r/m16,imm8                ; o16 0F BA /6 ib      [386]
     BTR r/m32,imm8                ; o32 0F BA /6 ib      [386]

     BTS r/m16,reg16               ; o16 0F AB /r         [386]
     BTS r/m32,reg32               ; o32 0F AB /r         [386]
     BTS r/m16,imm                 ; o16 0F BA /5 ib      [386]
     BTS r/m32,imm                 ; o32 0F BA /5 ib      [386]

   These instructions all test one bit of their first operand, whose
index is given by the second operand, and store the value of that bit
into the carry flag. Bit indices are from 0 (least significant) to 15
or 31 (most significant).

   In addition to storing the original value of the bit into the carry
flag, `BTR' also resets (clears) the bit in the operand itself. `BTS'
sets the bit, and `BTC' complements the bit. `BT' does not modify its
operands.

   The destination can be a register or a memory location. The source
can be a register or an immediate value.

   If the destination operand is a register, the bit offset should be
in the range 0-15 (for 16-bit operands) or 0-31 (for 32-bit operands).
An immediate value outside these ranges will be taken modulo 16/32 by
the processor.

   If the destination operand is a memory location, then an immediate
bit offset follows the same rules as for a register. If the bit offset
is in a register, then it can be anything within the signed range of
the register used (ie, for a 32-bit operand, it can be (-2^31) to (2^31
- 1)


File: nasm.info,  Node: Section B.4.18,  Next: Section B.4.19,  Prev: Section B.4.17,  Up: Section B.4

B.4.18. `CALL': Call Subroutine
-------------------------------

     CALL imm                      ; E8 rw/rd             [8086]
     CALL imm:imm16                ; o16 9A iw iw         [8086]
     CALL imm:imm32                ; o32 9A id iw         [386]
     CALL FAR mem16                ; o16 FF /3            [8086]
     CALL FAR mem32                ; o32 FF /3            [386]
     CALL r/m16                    ; o16 FF /2            [8086]
     CALL r/m32                    ; o32 FF /2            [386]

   `CALL' calls a subroutine, by means of pushing the current
instruction pointer (`IP') and optionally `CS' as well on the stack,
and then jumping to a given address.

   `CS' is pushed as well as `IP' if and only if the call is a far
call, i.e. a destination segment address is specified in the
instruction.  The forms involving two colon-separated arguments are far
calls; so are the `CALL FAR mem' forms.

   The immediate near call takes one of two forms (`call imm16/imm32',
determined by the current segment size limit. For 16-bit operands, you
would use `CALL 0x1234', and for 32-bit operands you would use `CALL
0x12345678'. The value passed as an operand is a relative offset.

   You can choose between the two immediate far call forms (`CALL
imm:imm') by the use of the `WORD' and `DWORD' keywords: `CALL WORD
0x1234:0x5678') or `CALL DWORD 0x1234:0x56789abc'.

   The `CALL FAR mem' forms execute a far call by loading the
destination address out of memory. The address loaded consists of 16 or
32 bits of offset (depending on the operand size), and 16 bits of
segment. The operand size may be overridden using `CALL WORD FAR mem' or
`CALL DWORD FAR mem'.

   The `CALL r/m' forms execute a near call (within the same segment),
loading the destination address out of memory or out of a register. The
keyword `NEAR' may be specified, for clarity, in these forms, but is
not necessary. Again, operand size can be overridden using `CALL WORD
mem' or `CALL DWORD mem'.

   As a convenience, NASM does not require you to call a far procedure
symbol by coding the cumbersome `CALL SEG routine:routine', but instead
allows the easier synonym `CALL FAR routine'.

   The `CALL r/m' forms given above are near calls; NASM will accept the
`NEAR' keyword (e.g. `CALL NEAR [address]'), even though it is not
strictly necessary.


File: nasm.info,  Node: Section B.4.19,  Next: Section B.4.20,  Prev: Section B.4.18,  Up: Section B.4

B.4.19. `CBW', `CWD', `CDQ', `CWDE': Sign Extensions
----------------------------------------------------

     CBW                           ; o16 98               [8086]
     CWDE                          ; o32 98               [386]

     CWD                           ; o16 99               [8086]
     CDQ                           ; o32 99               [386]

   All these instructions sign-extend a short value into a longer one,
by replicating the top bit of the original value to fill the extended
one.

   `CBW' extends `AL' into `AX' by repeating the top bit of `AL' in
every bit of `AH'. `CWDE' extends `AX' into `EAX'. `CWD' extends `AX'
into `DX:AX' by repeating the top bit of `AX' throughout `DX', and
`CDQ' extends `EAX' into `EDX:EAX'.


File: nasm.info,  Node: Section B.4.20,  Next: Section B.4.21,  Prev: Section B.4.19,  Up: Section B.4

B.4.20. `CLC', `CLD', `CLI', `CLTS': Clear Flags
------------------------------------------------

     CLC                           ; F8                   [8086]
     CLD                           ; FC                   [8086]
     CLI                           ; FA                   [8086]
     CLTS                          ; 0F 06                [286,PRIV]

   These instructions clear various flags. `CLC' clears the carry flag;
`CLD' clears the direction flag; `CLI' clears the interrupt flag (thus
disabling interrupts); and `CLTS' clears the task-switched (`TS') flag
in `CR0'.

   To set the carry, direction, or interrupt flags, use the `STC',
`STD' and `STI' instructions (*Note Section B.4.301::). To invert the
carry flag, use `CMC' (*Note Section B.4.22::).


File: nasm.info,  Node: Section B.4.21,  Next: Section B.4.22,  Prev: Section B.4.20,  Up: Section B.4

B.4.21. `CLFLUSH': Flush Cache Line
-----------------------------------

     CLFLUSH mem                   ; 0F AE /7        [WILLAMETTE,SSE2]

   `CLFLUSH' invalidates the cache line that contains the linear address
specified by the source operand from all levels of the processor cache
hierarchy (data and instruction). If, at any level of the cache
hierarchy, the line is inconsistent with memory (dirty) it is written
to memory before invalidation. The source operand points to a
byte-sized memory location.

   Although `CLFLUSH' is flagged `SSE2' and above, it may not be
present on all processors which have `SSE2' support, and it may be
supported on other processors; the `CPUID' instruction (*Note Section
B.4.34::) will return a bit which indicates support for the `CLFLUSH'
instruction.


File: nasm.info,  Node: Section B.4.22,  Next: Section B.4.23,  Prev: Section B.4.21,  Up: Section B.4

B.4.22. `CMC': Complement Carry Flag
------------------------------------

     CMC                           ; F5                   [8086]

   `CMC' changes the value of the carry flag: if it was 0, it sets it to
1, and vice versa.


File: nasm.info,  Node: Section B.4.23,  Next: Section B.4.24,  Prev: Section B.4.22,  Up: Section B.4

B.4.23. `CMOVcc': Conditional Move
----------------------------------

     CMOVcc reg16,r/m16            ; o16 0F 40+cc /r      [P6]
     CMOVcc reg32,r/m32            ; o32 0F 40+cc /r      [P6]

   `CMOV' moves its source (second) operand into its destination (first)
operand if the given condition code is satisfied; otherwise it does
nothing.

   For a list of condition codes, see *Note Section B.2.2::.

   Although the `CMOV' instructions are flagged `P6' and above, they
may not be supported by all Pentium Pro processors; the `CPUID'
instruction (*Note Section B.4.34::) will return a bit which indicates
whether conditional moves are supported.


File: nasm.info,  Node: Section B.4.24,  Next: Section B.4.25,  Prev: Section B.4.23,  Up: Section B.4

B.4.24. `CMP': Compare Integers
-------------------------------

     CMP r/m8,reg8                 ; 38 /r                [8086]
     CMP r/m16,reg16               ; o16 39 /r            [8086]
     CMP r/m32,reg32               ; o32 39 /r            [386]

     CMP reg8,r/m8                 ; 3A /r                [8086]
     CMP reg16,r/m16               ; o16 3B /r            [8086]
     CMP reg32,r/m32               ; o32 3B /r            [386]

     CMP r/m8,imm8                 ; 80 /7 ib             [8086]
     CMP r/m16,imm16               ; o16 81 /7 iw         [8086]
     CMP r/m32,imm32               ; o32 81 /7 id         [386]

     CMP r/m16,imm8                ; o16 83 /7 ib         [8086]
     CMP r/m32,imm8                ; o32 83 /7 ib         [386]

     CMP AL,imm8                   ; 3C ib                [8086]
     CMP AX,imm16                  ; o16 3D iw            [8086]
     CMP EAX,imm32                 ; o32 3D id            [386]

   `CMP' performs a `mental' subtraction of its second operand from its
first operand, and affects the flags as if the subtraction had taken
place, but does not store the result of the subtraction anywhere.

   In the forms with an 8-bit immediate second operand and a longer
first operand, the second operand is considered to be signed, and is
sign- extended to the length of the first operand. In these cases, the
`BYTE' qualifier is necessary to force NASM to generate this form of
the instruction.

   The destination operand can be a register or a memory location. The
source can be a register, memory location or an immediate value of the
same size as the destination.


File: nasm.info,  Node: Section B.4.25,  Next: Section B.4.26,  Prev: Section B.4.24,  Up: Section B.4

B.4.25. `CMPccPD': Packed Double-Precision FP Compare
-----------------------------------------------------

     CMPPD xmm1,xmm2/mem128,imm8   ; 66 0F C2 /r ib  [WILLAMETTE,SSE2]

     CMPEQPD xmm1,xmm2/mem128      ; 66 0F C2 /r 00  [WILLAMETTE,SSE2]
     CMPLTPD xmm1,xmm2/mem128      ; 66 0F C2 /r 01  [WILLAMETTE,SSE2]
     CMPLEPD xmm1,xmm2/mem128      ; 66 0F C2 /r 02  [WILLAMETTE,SSE2]
     CMPUNORDPD xmm1,xmm2/mem128   ; 66 0F C2 /r 03  [WILLAMETTE,SSE2]
     CMPNEQPD xmm1,xmm2/mem128     ; 66 0F C2 /r 04  [WILLAMETTE,SSE2]
     CMPNLTPD xmm1,xmm2/mem128     ; 66 0F C2 /r 05  [WILLAMETTE,SSE2]
     CMPNLEPD xmm1,xmm2/mem128     ; 66 0F C2 /r 06  [WILLAMETTE,SSE2]
     CMPORDPD xmm1,xmm2/mem128     ; 66 0F C2 /r 07  [WILLAMETTE,SSE2]

   The `CMPccPD' instructions compare the two packed double-precision FP
values in the source and destination operands, and returns the result of
the comparison in the destination register. The result of each
comparison is a quadword mask of all 1s (comparison true) or all 0s
(comparison false).

   The destination is an `XMM' register. The source can be either an
`XMM' register or a 128-bit memory location.

   The third operand is an 8-bit immediate value, of which the low 3
bits define the type of comparison. For ease of programming, the 8
two-operand pseudo-instructions are provided, with the third operand
already filled in.  The  `Condition Predicates' are:

     EQ     0   Equal
     LT     1   Less-than
     LE     2   Less-than-or-equal
     UNORD  3   Unordered
     NE     4   Not-equal
     NLT    5   Not-less-than
     NLE    6   Not-less-than-or-equal
     ORD    7   Ordered

   For more details of the comparison predicates, and details of how to
emulate the "greater-than" equivalents, see *Note Section B.2.3::


File: nasm.info,  Node: Section B.4.26,  Next: Section B.4.27,  Prev: Section B.4.25,  Up: Section B.4

B.4.26. `CMPccPS': Packed Single-Precision FP Compare
-----------------------------------------------------

     CMPPS xmm1,xmm2/mem128,imm8   ; 0F C2 /r ib     [KATMAI,SSE]

     CMPEQPS xmm1,xmm2/mem128      ; 0F C2 /r 00     [KATMAI,SSE]
     CMPLTPS xmm1,xmm2/mem128      ; 0F C2 /r 01     [KATMAI,SSE]
     CMPLEPS xmm1,xmm2/mem128      ; 0F C2 /r 02     [KATMAI,SSE]
     CMPUNORDPS xmm1,xmm2/mem128   ; 0F C2 /r 03     [KATMAI,SSE]
     CMPNEQPS xmm1,xmm2/mem128     ; 0F C2 /r 04     [KATMAI,SSE]
     CMPNLTPS xmm1,xmm2/mem128     ; 0F C2 /r 05     [KATMAI,SSE]
     CMPNLEPS xmm1,xmm2/mem128     ; 0F C2 /r 06     [KATMAI,SSE]
     CMPORDPS xmm1,xmm2/mem128     ; 0F C2 /r 07     [KATMAI,SSE]

   The `CMPccPS' instructions compare the two packed single-precision FP
values in the source and destination operands, and returns the result of
the comparison in the destination register. The result of each
comparison is a doubleword mask of all 1s (comparison true) or all 0s
(comparison false).

   The destination is an `XMM' register. The source can be either an
`XMM' register or a 128-bit memory location.

   The third operand is an 8-bit immediate value, of which the low 3
bits define the type of comparison. For ease of programming, the 8
two-operand pseudo-instructions are provided, with the third operand
already filled in.  The  `Condition Predicates' are:

     EQ     0   Equal
     LT     1   Less-than
     LE     2   Less-than-or-equal
     UNORD  3   Unordered
     NE     4   Not-equal
     NLT    5   Not-less-than
     NLE    6   Not-less-than-or-equal
     ORD    7   Ordered

   For more details of the comparison predicates, and details of how to
emulate the "greater-than" equivalents, see *Note Section B.2.3::


File: nasm.info,  Node: Section B.4.27,  Next: Section B.4.28,  Prev: Section B.4.26,  Up: Section B.4

B.4.27. `CMPSB', `CMPSW', `CMPSD': Compare Strings
--------------------------------------------------

     CMPSB                         ; A6                   [8086]
     CMPSW                         ; o16 A7               [8086]
     CMPSD                         ; o32 A7               [386]

   `CMPSB' compares the byte at `[DS:SI]' or `[DS:ESI]' with the byte
at `[ES:DI]' or `[ES:EDI]', and sets the flags accordingly. It then
increments or decrements (depending on the direction flag: increments
if the flag is clear, decrements if it is set) `SI' and `DI' (or `ESI'
and `EDI').

   The registers used are `SI' and `DI' if the address size is 16 bits,
and `ESI' and `EDI' if it is 32 bits. If you need to use an address
size not equal to the current `BITS' setting, you can use an explicit
`a16' or `a32' prefix.

   The segment register used to load from `[SI]' or `[ESI]' can be
overridden by using a segment register name as a prefix (for example,
`ES CMPSB'). The use of `ES' for the load from `[DI]' or `[EDI]' cannot
be overridden.

   `CMPSW' and `CMPSD' work in the same way, but they compare a word or
a doubleword instead of a byte, and increment or decrement the
addressing registers by 2 or 4 instead of 1.

   The `REPE' and `REPNE' prefixes (equivalently, `REPZ' and `REPNZ')
may be used to repeat the instruction up to `CX' (or `ECX' - again, the
address size chooses which) times until the first unequal or equal byte
is found.


File: nasm.info,  Node: Section B.4.28,  Next: Section B.4.29,  Prev: Section B.4.27,  Up: Section B.4

B.4.28. `CMPccSD': Scalar Double-Precision FP Compare
-----------------------------------------------------

     CMPSD xmm1,xmm2/mem64,imm8    ; F2 0F C2 /r ib  [WILLAMETTE,SSE2]

     CMPEQSD xmm1,xmm2/mem64       ; F2 0F C2 /r 00  [WILLAMETTE,SSE2]
     CMPLTSD xmm1,xmm2/mem64       ; F2 0F C2 /r 01  [WILLAMETTE,SSE2]
     CMPLESD xmm1,xmm2/mem64       ; F2 0F C2 /r 02  [WILLAMETTE,SSE2]
     CMPUNORDSD xmm1,xmm2/mem64    ; F2 0F C2 /r 03  [WILLAMETTE,SSE2]
     CMPNEQSD xmm1,xmm2/mem64      ; F2 0F C2 /r 04  [WILLAMETTE,SSE2]
     CMPNLTSD xmm1,xmm2/mem64      ; F2 0F C2 /r 05  [WILLAMETTE,SSE2]
     CMPNLESD xmm1,xmm2/mem64      ; F2 0F C2 /r 06  [WILLAMETTE,SSE2]
     CMPORDSD xmm1,xmm2/mem64      ; F2 0F C2 /r 07  [WILLAMETTE,SSE2]

   The `CMPccSD' instructions compare the low-order double-precision FP
values in the source and destination operands, and returns the result of
the comparison in the destination register. The result of each
comparison is a quadword mask of all 1s (comparison true) or all 0s
(comparison false).

   The destination is an `XMM' register. The source can be either an
`XMM' register or a 128-bit memory location.

   The third operand is an 8-bit immediate value, of which the low 3
bits define the type of comparison. For ease of programming, the 8
two-operand pseudo-instructions are provided, with the third operand
already filled in.  The  `Condition Predicates' are:

     EQ     0   Equal
     LT     1   Less-than
     LE     2   Less-than-or-equal
     UNORD  3   Unordered
     NE     4   Not-equal
     NLT    5   Not-less-than
     NLE    6   Not-less-than-or-equal
     ORD    7   Ordered

   For more details of the comparison predicates, and details of how to
emulate the "greater-than" equivalents, see *Note Section B.2.3::


File: nasm.info,  Node: Section B.4.29,  Next: Section B.4.30,  Prev: Section B.4.28,  Up: Section B.4

B.4.29. `CMPccSS': Scalar Single-Precision FP Compare
-----------------------------------------------------

     CMPSS xmm1,xmm2/mem32,imm8    ; F3 0F C2 /r ib  [KATMAI,SSE]

     CMPEQSS xmm1,xmm2/mem32       ; F3 0F C2 /r 00  [KATMAI,SSE]
     CMPLTSS xmm1,xmm2/mem32       ; F3 0F C2 /r 01  [KATMAI,SSE]
     CMPLESS xmm1,xmm2/mem32       ; F3 0F C2 /r 02  [KATMAI,SSE]
     CMPUNORDSS xmm1,xmm2/mem32    ; F3 0F C2 /r 03  [KATMAI,SSE]
     CMPNEQSS xmm1,xmm2/mem32      ; F3 0F C2 /r 04  [KATMAI,SSE]
     CMPNLTSS xmm1,xmm2/mem32      ; F3 0F C2 /r 05  [KATMAI,SSE]
     CMPNLESS xmm1,xmm2/mem32      ; F3 0F C2 /r 06  [KATMAI,SSE]
     CMPORDSS xmm1,xmm2/mem32      ; F3 0F C2 /r 07  [KATMAI,SSE]

   The `CMPccSS' instructions compare the low-order single-precision FP
values in the source and destination operands, and returns the result of
the comparison in the destination register. The result of each
comparison is a doubleword mask of all 1s (comparison true) or all 0s
(comparison false).

   The destination is an `XMM' register. The source can be either an
`XMM' register or a 128-bit memory location.

   The third operand is an 8-bit immediate value, of which the low 3
bits define the type of comparison. For ease of programming, the 8
two-operand pseudo-instructions are provided, with the third operand
already filled in.  The  `Condition Predicates' are:

     EQ     0   Equal
     LT     1   Less-than
     LE     2   Less-than-or-equal
     UNORD  3   Unordered
     NE     4   Not-equal
     NLT    5   Not-less-than
     NLE    6   Not-less-than-or-equal
     ORD    7   Ordered

   For more details of the comparison predicates, and details of how to
emulate the "greater-than" equivalents, see *Note Section B.2.3::


File: nasm.info,  Node: Section B.4.30,  Next: Section B.4.31,  Prev: Section B.4.29,  Up: Section B.4

B.4.30. `CMPXCHG', `CMPXCHG486': Compare and Exchange
-----------------------------------------------------

     CMPXCHG r/m8,reg8             ; 0F B0 /r             [PENT]
     CMPXCHG r/m16,reg16           ; o16 0F B1 /r         [PENT]
     CMPXCHG r/m32,reg32           ; o32 0F B1 /r         [PENT]

     CMPXCHG486 r/m8,reg8          ; 0F A6 /r             [486,UNDOC]
     CMPXCHG486 r/m16,reg16        ; o16 0F A7 /r         [486,UNDOC]
     CMPXCHG486 r/m32,reg32        ; o32 0F A7 /r         [486,UNDOC]

   These two instructions perform exactly the same operation; however,
apparently some (not all) 486 processors support it under a non-standard
opcode, so NASM provides the undocumented `CMPXCHG486' form to generate
the non-standard opcode.

   `CMPXCHG' compares its destination (first) operand to the value in
`AL', `AX' or `EAX' (depending on the operand size of the instruction).
If they are equal, it copies its source (second) operand into the
destination and sets the zero flag. Otherwise, it clears the zero flag
and copies the destination register to AL, AX or EAX.

   The destination can be either a register or a memory location. The
source is a register.

   `CMPXCHG' is intended to be used for atomic operations in
multitasking or multiprocessor environments. To safely update a value
in shared memory, for example, you might load the value into `EAX',
load the updated value into `EBX', and then execute the instruction
`LOCK CMPXCHG [value],EBX'. If `value' has not changed since being
loaded, it is updated with your desired new value, and the zero flag is
set to let you know it has worked. (The `LOCK' prefix prevents another
processor doing anything in the middle of this operation: it guarantees
atomicity.) However, if another processor has modified the value in
between your load and your attempted store, the store does not happen,
and you are notified of the failure by a cleared zero flag, so you can
go round and try again.


File: nasm.info,  Node: Section B.4.31,  Next: Section B.4.32,  Prev: Section B.4.30,  Up: Section B.4

B.4.31. `CMPXCHG8B': Compare and Exchange Eight Bytes
-----------------------------------------------------

     CMPXCHG8B mem                 ; 0F C7 /1             [PENT]

   This is a larger and more unwieldy version of `CMPXCHG': it compares
the 64-bit (eight-byte) value stored at `[mem]' with the value in
`EDX:EAX'. If they are equal, it sets the zero flag and stores
`ECX:EBX' into the memory area. If they are unequal, it clears the zero
flag and stores the memory contents into `EDX:EAX'.

   `CMPXCHG8B' can be used with the `LOCK' prefix, to allow atomic
execution. This is useful in multi-processor and multi-tasking
environments.


File: nasm.info,  Node: Section B.4.32,  Next: Section B.4.33,  Prev: Section B.4.31,  Up: Section B.4

B.4.32. `COMISD': Scalar Ordered Double-Precision FP Compare and Set EFLAGS
---------------------------------------------------------------------------

     COMISD xmm1,xmm2/mem64        ; 66 0F 2F /r     [WILLAMETTE,SSE2]

   `COMISD' compares the low-order double-precision FP value in the two
source operands. ZF, PF and CF are set according to the result. OF, AF
and AF are cleared. The unordered result is returned if either source
is a NaN (QNaN or SNaN).

   The destination operand is an `XMM' register. The source can be
either an `XMM' register or a memory location.

   The flags are set according to the following rules:

        Result          Flags        Values

        UNORDERED:      ZF,PF,CF <-- 111;
        GREATER_THAN:   ZF,PF,CF <-- 000;
        LESS_THAN:      ZF,PF,CF <-- 001;
        EQUAL:          ZF,PF,CF <-- 100;


File: nasm.info,  Node: Section B.4.33,  Next: Section B.4.34,  Prev: Section B.4.32,  Up: Section B.4

B.4.33. `COMISS': Scalar Ordered Single-Precision FP Compare and Set EFLAGS
---------------------------------------------------------------------------

     COMISS xmm1,xmm2/mem32        ; 66 0F 2F /r     [KATMAI,SSE]

   `COMISS' compares the low-order single-precision FP value in the two
source operands. ZF, PF and CF are set according to the result. OF, AF
and AF are cleared. The unordered result is returned if either source
is a NaN (QNaN or SNaN).

   The destination operand is an `XMM' register. The source can be
either an `XMM' register or a memory location.

   The flags are set according to the following rules:

        Result          Flags        Values

        UNORDERED:      ZF,PF,CF <-- 111;
        GREATER_THAN:   ZF,PF,CF <-- 000;
        LESS_THAN:      ZF,PF,CF <-- 001;
        EQUAL:          ZF,PF,CF <-- 100;


File: nasm.info,  Node: Section B.4.34,  Next: Section B.4.35,  Prev: Section B.4.33,  Up: Section B.4

B.4.34. `CPUID': Get CPU Identification Code
--------------------------------------------

     CPUID                         ; 0F A2                [PENT]

   `CPUID' returns various information about the processor it is being
executed on. It fills the four registers `EAX', `EBX', `ECX' and `EDX'
with information, which varies depending on the input contents of `EAX'.

   `CPUID' also acts as a barrier to serialise instruction execution:
executing the `CPUID' instruction guarantees that all the effects
(memory modification, flag modification, register modification) of
previous instructions have been completed before the next instruction
gets fetched.

   The information returned is as follows:

   * If `EAX' is zero on input, `EAX' on output holds the maximum
     acceptable input value of `EAX', and `EBX:EDX:ECX' contain the
     string `"GenuineIntel"' (or not, if you have a clone processor).
     That is to say, `EBX' contains `"Genu"' (in NASM's own sense of
     character constants, described in *Note Section 3.4.2::), `EDX'
     contains `"ineI"' and `ECX' contains `"ntel"'.

   * If `EAX' is one on input, `EAX' on output contains version
     information about the processor, and `EDX' contains a set of
     feature flags, showing the presence and absence of various
     features. For example, bit 8 is set if the `CMPXCHG8B' instruction
     (*Note Section B.4.31::) is supported, bit 15 is set if the
     conditional move instructions (*Note Section B.4.23:: and *Note
     Section B.4.72::) are supported, and bit 23 is set if `MMX'
     instructions are supported.

   * If `EAX' is two on input, `EAX', `EBX', `ECX' and `EDX' all
     contain information about caches and TLBs (Translation Lookahead
     Buffers).

   For more information on the data returned from `CPUID', see the
documentation from Intel and other processor manufacturers.


File: nasm.info,  Node: Section B.4.35,  Next: Section B.4.36,  Prev: Section B.4.34,  Up: Section B.4

B.4.35. `CVTDQ2PD': Packed Signed INT32 to Packed Double-Precision FP Conversion
--------------------------------------------------------------------------------

     CVTDQ2PD xmm1,xmm2/mem64      ; F3 0F E6 /r     [WILLAMETTE,SSE2]

   `CVTDQ2PD' converts two packed signed doublewords from the source
operand to two packed double-precision FP values in the destination
operand.

   The destination operand is an `XMM' register. The source can be
either an `XMM' register or a 64-bit memory location. If the source is a
register, the packed integers are in the low quadword.


File: nasm.info,  Node: Section B.4.36,  Next: Section B.4.37,  Prev: Section B.4.35,  Up: Section B.4

B.4.36. `CVTDQ2PS': Packed Signed INT32 to Packed Single-Precision FP Conversion
--------------------------------------------------------------------------------

     CVTDQ2PS xmm1,xmm2/mem128     ; 0F 5B /r        [WILLAMETTE,SSE2]

   `CVTDQ2PS' converts four packed signed doublewords from the source
operand to four packed single-precision FP values in the destination
operand.

   The destination operand is an `XMM' register. The source can be
either an `XMM' register or a 128-bit memory location.

   For more details of this instruction, see the Intel Processor
manuals.


File: nasm.info,  Node: Section B.4.37,  Next: Section B.4.38,  Prev: Section B.4.36,  Up: Section B.4

B.4.37. `CVTPD2DQ': Packed Double-Precision FP to Packed Signed INT32 Conversion
--------------------------------------------------------------------------------

     CVTPD2DQ xmm1,xmm2/mem128     ; F2 0F E6 /r     [WILLAMETTE,SSE2]

   `CVTPD2DQ' converts two packed double-precision FP values from the
source operand to two packed signed doublewords in the low quadword of
the destination operand. The high quadword of the destination is set to
all 0s.

   The destination operand is an `XMM' register. The source can be
either an `XMM' register or a 128-bit memory location.

   For more details of this instruction, see the Intel Processor
manuals.


File: nasm.info,  Node: Section B.4.38,  Next: Section B.4.39,  Prev: Section B.4.37,  Up: Section B.4

B.4.38. `CVTPD2PI': Packed Double-Precision FP to Packed Signed INT32 Conversion
--------------------------------------------------------------------------------

     CVTPD2PI mm,xmm/mem128        ; 66 0F 2D /r     [WILLAMETTE,SSE2]

   `CVTPD2PI' converts two packed double-precision FP values from the
source operand to two packed signed doublewords in the destination
operand.

   The destination operand is an `MMX' register. The source can be
either an `XMM' register or a 128-bit memory location.

   For more details of this instruction, see the Intel Processor
manuals.


File: nasm.info,  Node: Section B.4.39,  Next: Section B.4.40,  Prev: Section B.4.38,  Up: Section B.4

B.4.39. `CVTPD2PS': Packed Double-Precision FP to Packed Single-Precision FP Conversion
---------------------------------------------------------------------------------------

     CVTPD2PS xmm1,xmm2/mem128     ; 66 0F 5A /r     [WILLAMETTE,SSE2]

   `CVTPD2PS' converts two packed double-precision FP values from the
source operand to two packed single-precision FP values in the low
quadword of the destination operand. The high quadword of the
destination is set to all 0s.

   The destination operand is an `XMM' register. The source can be
either an `XMM' register or a 128-bit memory location.

   For more details of this instruction, see the Intel Processor
manuals.


File: nasm.info,  Node: Section B.4.40,  Next: Section B.4.41,  Prev: Section B.4.39,  Up: Section B.4

B.4.40. `CVTPI2PD': Packed Signed INT32 to Packed Double-Precision FP Conversion
--------------------------------------------------------------------------------

     CVTPI2PD xmm,mm/mem64         ; 66 0F 2A /r     [WILLAMETTE,SSE2]

   `CVTPI2PD' converts two packed signed doublewords from the source
operand to two packed double-precision FP values in the destination
operand.

   The destination operand is an `XMM' register. The source can be
either an `MMX' register or a 64-bit memory location.

   For more details of this instruction, see the Intel Processor
manuals.


File: nasm.info,  Node: Section B.4.41,  Next: Section B.4.42,  Prev: Section B.4.40,  Up: Section B.4

B.4.41. `CVTPI2PS': Packed Signed INT32 to Packed Single-FP Conversion
----------------------------------------------------------------------

     CVTPI2PS xmm,mm/mem64         ; 0F 2A /r        [KATMAI,SSE]

   `CVTPI2PS' converts two packed signed doublewords from the source
operand to two packed single-precision FP values in the low quadword of
the destination operand. The high quadword of the destination remains
unchanged.

   The destination operand is an `XMM' register. The source can be
either an `MMX' register or a 64-bit memory location.

   For more details of this instruction, see the Intel Processor
manuals.


File: nasm.info,  Node: Section B.4.42,  Next: Section B.4.43,  Prev: Section B.4.41,  Up: Section B.4

B.4.42. `CVTPS2DQ': Packed Single-Precision FP to Packed Signed INT32 Conversion
--------------------------------------------------------------------------------

     CVTPS2DQ xmm1,xmm2/mem128     ; 66 0F 5B /r     [WILLAMETTE,SSE2]

   `CVTPS2DQ' converts four packed single-precision FP values from the
source operand to four packed signed doublewords in the destination
operand.

   The destination operand is an `XMM' register. The source can be
either an `XMM' register or a 128-bit memory location.

   For more details of this instruction, see the Intel Processor
manuals.


File: nasm.info,  Node: Section B.4.43,  Next: Section B.4.44,  Prev: Section B.4.42,  Up: Section B.4

B.4.43. `CVTPS2PD': Packed Single-Precision FP to Packed Double-Precision FP Conversion
---------------------------------------------------------------------------------------

     CVTPS2PD xmm1,xmm2/mem64      ; 0F 5A /r        [WILLAMETTE,SSE2]

   `CVTPS2PD' converts two packed single-precision FP values from the
source operand to two packed double-precision FP values in the
destination operand.

   The destination operand is an `XMM' register. The source can be
either an `XMM' register or a 64-bit memory location. If the source is a
register, the input values are in the low quadword.

   For more details of this instruction, see the Intel Processor
manuals.


File: nasm.info,  Node: Section B.4.44,  Next: Section B.4.45,  Prev: Section B.4.43,  Up: Section B.4

B.4.44. `CVTPS2PI': Packed Single-Precision FP to Packed Signed INT32 Conversion
--------------------------------------------------------------------------------

     CVTPS2PI mm,xmm/mem64         ; 0F 2D /r        [KATMAI,SSE]

   `CVTPS2PI' converts two packed single-precision FP values from the
source operand to two packed signed doublewords in the destination
operand.

   The destination operand is an `MMX' register. The source can be
either an `XMM' register or a 64-bit memory location. If the source is a
register, the input values are in the low quadword.

   For more details of this instruction, see the Intel Processor
manuals.


File: nasm.info,  Node: Section B.4.45,  Next: Section B.4.46,  Prev: Section B.4.44,  Up: Section B.4

B.4.45. `CVTSD2SI': Scalar Double-Precision FP to Signed INT32 Conversion
-------------------------------------------------------------------------

     CVTSD2SI reg32,xmm/mem64      ; F2 0F 2D /r     [WILLAMETTE,SSE2]

   `CVTSD2SI' converts a double-precision FP value from the source
operand to a signed doubleword in the destination operand.

   The destination operand is a general purpose register. The source
can be either an `XMM' register or a 64-bit memory location. If the
source is a register, the input value is in the low quadword.

   For more details of this instruction, see the Intel Processor
manuals.


File: nasm.info,  Node: Section B.4.46,  Next: Section B.4.47,  Prev: Section B.4.45,  Up: Section B.4

B.4.46. `CVTSD2SS': Scalar Double-Precision FP to Scalar Single-Precision FP Conversion
---------------------------------------------------------------------------------------

     CVTSD2SS xmm1,xmm2/mem64      ; F2 0F 5A /r     [KATMAI,SSE]

   `CVTSD2SS' converts a double-precision FP value from the source
operand to a single-precision FP value in the low doubleword of the
destination operand. The upper 3 doublewords are left unchanged.

   The destination operand is an `XMM' register. The source can be
either an `XMM' register or a 64-bit memory location. If the source is a
register, the input value is in the low quadword.

   For more details of this instruction, see the Intel Processor
manuals.


File: nasm.info,  Node: Section B.4.47,  Next: Section B.4.48,  Prev: Section B.4.46,  Up: Section B.4

B.4.47. `CVTSI2SD': Signed INT32 to Scalar Double-Precision FP Conversion
-------------------------------------------------------------------------

     CVTSI2SD xmm,r/m32            ; F2 0F 2A /r     [WILLAMETTE,SSE2]

   `CVTSI2SD' converts a signed doubleword from the source operand to a
double-precision FP value in the low quadword of the destination
operand.  The high quadword is left unchanged.

   The destination operand is an `XMM' register. The source can be
either a general purpose register or a 32-bit memory location.

   For more details of this instruction, see the Intel Processor
manuals.


File: nasm.info,  Node: Section B.4.48,  Next: Section B.4.49,  Prev: Section B.4.47,  Up: Section B.4

B.4.48. `CVTSI2SS': Signed INT32 to Scalar Single-Precision FP Conversion
-------------------------------------------------------------------------

     CVTSI2SS xmm,r/m32            ; F3 0F 2A /r     [KATMAI,SSE]

   `CVTSI2SS' converts a signed doubleword from the source operand to a
single-precision FP value in the low doubleword of the destination
operand.  The upper 3 doublewords are left unchanged.

   The destination operand is an `XMM' register. The source can be
either a general purpose register or a 32-bit memory location.

   For more details of this instruction, see the Intel Processor
manuals.


File: nasm.info,  Node: Section B.4.49,  Next: Section B.4.50,  Prev: Section B.4.48,  Up: Section B.4

B.4.49. `CVTSS2SD': Scalar Single-Precision FP to Scalar Double-Precision FP Conversion
---------------------------------------------------------------------------------------

     CVTSS2SD xmm1,xmm2/mem32      ; F3 0F 5A /r     [WILLAMETTE,SSE2]

   `CVTSS2SD' converts a single-precision FP value from the source
operand to a double-precision FP value in the low quadword of the
destination operand. The upper quadword is left unchanged.

   The destination operand is an `XMM' register. The source can be
either an `XMM' register or a 32-bit memory location. If the source is a
register, the input value is contained in the low doubleword.

   For more details of this instruction, see the Intel Processor
manuals.


File: nasm.info,  Node: Section B.4.50,  Next: Section B.4.51,  Prev: Section B.4.49,  Up: Section B.4

B.4.50. `CVTSS2SI': Scalar Single-Precision FP to Signed INT32 Conversion
-------------------------------------------------------------------------

     CVTSS2SI reg32,xmm/mem32      ; F3 0F 2D /r     [KATMAI,SSE]

   `CVTSS2SI' converts a single-precision FP value from the source
operand to a signed doubleword in the destination operand.

   The destination operand is a general purpose register. The source
can be either an `XMM' register or a 32-bit memory location. If the
source is a register, the input value is in the low doubleword.

   For more details of this instruction, see the Intel Processor
manuals.


File: nasm.info,  Node: Section B.4.51,  Next: Section B.4.52,  Prev: Section B.4.50,  Up: Section B.4

B.4.51. `CVTTPD2DQ': Packed Double-Precision FP to Packed Signed INT32 Conversion with Truncation
-------------------------------------------------------------------------------------------------

     CVTTPD2DQ xmm1,xmm2/mem128    ; 66 0F E6 /r     [WILLAMETTE,SSE2]

   `CVTTPD2DQ' converts two packed double-precision FP values in the
source operand to two packed single-precision FP values in the
destination operand. If the result is inexact, it is truncated (rounded
toward zero).  The high quadword is set to all 0s.

   The destination operand is an `XMM' register. The source can be
either an `XMM' register or a 128-bit memory location.

   For more details of this instruction, see the Intel Processor
manuals.


File: nasm.info,  Node: Section B.4.52,  Next: Section B.4.53,  Prev: Section B.4.51,  Up: Section B.4

B.4.52. `CVTTPD2PI': Packed Double-Precision FP to Packed Signed INT32 Conversion with Truncation
-------------------------------------------------------------------------------------------------

     CVTTPD2PI mm,xmm/mem128        ; 66 0F 2C /r     [WILLAMETTE,SSE2]

   `CVTTPD2PI' converts two packed double-precision FP values in the
source operand to two packed single-precision FP values in the
destination operand. If the result is inexact, it is truncated (rounded
toward zero).

   The destination operand is an `MMX' register. The source can be
either an `XMM' register or a 128-bit memory location.

   For more details of this instruction, see the Intel Processor
manuals.


File: nasm.info,  Node: Section B.4.53,  Next: Section B.4.54,  Prev: Section B.4.52,  Up: Section B.4

B.4.53. `CVTTPS2DQ': Packed Single-Precision FP to Packed Signed INT32 Conversion with Truncation
-------------------------------------------------------------------------------------------------

     CVTTPS2DQ xmm1,xmm2/mem128    ; F3 0F 5B /r     [WILLAMETTE,SSE2]

   `CVTTPS2DQ' converts four packed single-precision FP values in the
source operand to four packed signed doublewords in the destination
operand. If the result is inexact, it is truncated (rounded toward
zero).

   The destination operand is an `XMM' register. The source can be
either an `XMM' register or a 128-bit memory location.

   For more details of this instruction, see the Intel Processor
manuals.


File: nasm.info,  Node: Section B.4.54,  Next: Section B.4.55,  Prev: Section B.4.53,  Up: Section B.4

B.4.54. `CVTTPS2PI': Packed Single-Precision FP to Packed Signed INT32 Conversion with Truncation
-------------------------------------------------------------------------------------------------

     CVTTPS2PI mm,xmm/mem64         ; 0F 2C /r       [KATMAI,SSE]

   `CVTTPS2PI' converts two packed single-precision FP values in the
source operand to two packed signed doublewords in the destination
operand.  If the result is inexact, it is truncated (rounded toward
zero). If the source is a register, the input values are in the low
quadword.

   The destination operand is an `MMX' register. The source can be
either an `XMM' register or a 64-bit memory location. If the source is a
register, the input value is in the low quadword.

   For more details of this instruction, see the Intel Processor
manuals.


File: nasm.info,  Node: Section B.4.55,  Next: Section B.4.56,  Prev: Section B.4.54,  Up: Section B.4

B.4.55. `CVTTSD2SI': Scalar Double-Precision FP to Signed INT32 Conversion with Truncation
------------------------------------------------------------------------------------------

     CVTTSD2SI reg32,xmm/mem64      ; F2 0F 2C /r    [WILLAMETTE,SSE2]

   `CVTTSD2SI' converts a double-precision FP value in the source
operand to a signed doubleword in the destination operand. If the
result is inexact, it is truncated (rounded toward zero).

   The destination operand is a general purpose register. The source
can be either an `XMM' register or a 64-bit memory location. If the
source is a register, the input value is in the low quadword.

   For more details of this instruction, see the Intel Processor
manuals.


File: nasm.info,  Node: Section B.4.56,  Next: Section B.4.57,  Prev: Section B.4.55,  Up: Section B.4

B.4.56. `CVTTSS2SI': Scalar Single-Precision FP to Signed INT32 Conversion with Truncation
------------------------------------------------------------------------------------------

     CVTTSD2SI reg32,xmm/mem32      ; F3 0F 2C /r    [KATMAI,SSE]

   `CVTTSS2SI' converts a single-precision FP value in the source
operand to a signed doubleword in the destination operand. If the
result is inexact, it is truncated (rounded toward zero).

   The destination operand is a general purpose register. The source
can be either an `XMM' register or a 32-bit memory location. If the
source is a register, the input value is in the low doubleword.

   For more details of this instruction, see the Intel Processor
manuals.


File: nasm.info,  Node: Section B.4.57,  Next: Section B.4.58,  Prev: Section B.4.56,  Up: Section B.4

B.4.57. `DAA', `DAS': Decimal Adjustments
-----------------------------------------

     DAA                           ; 27                   [8086]
     DAS                           ; 2F                   [8086]

   These instructions are used in conjunction with the add and subtract
instructions to perform binary-coded decimal arithmetic in _packed_
(one BCD digit per nibble) form. For the unpacked equivalents, see
*Note Section B.4.1::.

   `DAA' should be used after a one-byte `ADD' instruction whose
destination was the `AL' register: by means of examining the value in
the `AL' and also the auxiliary carry flag `AF', it determines whether
either digit of the addition has overflowed, and adjusts it (and sets
the carry and auxiliary-carry flags) if so. You can add long BCD
strings together by doing `ADD'/`DAA' on the low two digits, then doing
`ADC'/`DAA' on each subsequent pair of digits.

   `DAS' works similarly to `DAA', but is for use after `SUB'
instructions rather than `ADD'.


File: nasm.info,  Node: Section B.4.58,  Next: Section B.4.59,  Prev: Section B.4.57,  Up: Section B.4

B.4.58. `DEC': Decrement Integer
--------------------------------

     DEC reg16                     ; o16 48+r             [8086]
     DEC reg32                     ; o32 48+r             [386]
     DEC r/m8                      ; FE /1                [8086]
     DEC r/m16                     ; o16 FF /1            [8086]
     DEC r/m32                     ; o32 FF /1            [386]

   `DEC' subtracts 1 from its operand. It does _not_ affect the carry
flag: to affect the carry flag, use `SUB something,1' (see *Note
Section B.4.305::). `DEC' affects all the other flags according to the
result.

   This instruction can be used with a `LOCK' prefix to allow atomic
execution.

   See also `INC' (*Note Section B.4.120::).


File: nasm.info,  Node: Section B.4.59,  Next: Section B.4.60,  Prev: Section B.4.58,  Up: Section B.4

B.4.59. `DIV': Unsigned Integer Divide
--------------------------------------

     DIV r/m8                      ; F6 /6                [8086]
     DIV r/m16                     ; o16 F7 /6            [8086]
     DIV r/m32                     ; o32 F7 /6            [386]

   `DIV' performs unsigned integer division. The explicit operand
provided is the divisor; the dividend and destination operands are
implicit, in the following way:

   * For `DIV r/m8', `AX' is divided by the given operand; the quotient
     is stored in `AL' and the remainder in `AH'.

   * For `DIV r/m16', `DX:AX' is divided by the given operand; the
     quotient is stored in `AX' and the remainder in `DX'.

   * For `DIV r/m32', `EDX:EAX' is divided by the given operand; the
     quotient is stored in `EAX' and the remainder in `EDX'.

   Signed integer division is performed by the `IDIV' instruction: see
*Note Section B.4.117::.


File: nasm.info,  Node: Section B.4.60,  Next: Section B.4.61,  Prev: Section B.4.59,  Up: Section B.4

B.4.60. `DIVPD': Packed Double-Precision FP Divide
--------------------------------------------------

     DIVPD xmm1,xmm2/mem128        ; 66 0F 5E /r     [WILLAMETTE,SSE2]

   `DIVPD' divides the two packed double-precision FP values in the
destination operand by the two packed double-precision FP values in the
source operand, and stores the packed double-precision results in the
destination register.

   The destination is an `XMM' register. The source operand can be
either an `XMM' register or a 128-bit memory location.

        dst[0-63]   := dst[0-63]   / src[0-63],
        dst[64-127] := dst[64-127] / src[64-127].


File: nasm.info,  Node: Section B.4.61,  Next: Section B.4.62,  Prev: Section B.4.60,  Up: Section B.4

B.4.61. `DIVPS': Packed Single-Precision FP Divide
--------------------------------------------------

     DIVPS xmm1,xmm2/mem128        ; 0F 5E /r        [KATMAI,SSE]

   `DIVPS' divides the four packed single-precision FP values in the
destination operand by the four packed single-precision FP values in the
source operand, and stores the packed single-precision results in the
destination register.

   The destination is an `XMM' register. The source operand can be
either an `XMM' register or a 128-bit memory location.

        dst[0-31]   := dst[0-31]   / src[0-31],
        dst[32-63]  := dst[32-63]  / src[32-63],
        dst[64-95]  := dst[64-95]  / src[64-95],
        dst[96-127] := dst[96-127] / src[96-127].


File: nasm.info,  Node: Section B.4.62,  Next: Section B.4.63,  Prev: Section B.4.61,  Up: Section B.4

B.4.62. `DIVSD': Scalar Double-Precision FP Divide
--------------------------------------------------

     DIVSD xmm1,xmm2/mem64         ; F2 0F 5E /r     [WILLAMETTE,SSE2]

   `DIVSD' divides the low-order double-precision FP value in the
destination operand by the low-order double-precision FP value in the
source operand, and stores the double-precision result in the
destination register.

   The destination is an `XMM' register. The source operand can be
either an `XMM' register or a 64-bit memory location.

        dst[0-63]   := dst[0-63] / src[0-63],
        dst[64-127] remains unchanged.


File: nasm.info,  Node: Section B.4.63,  Next: Section B.4.64,  Prev: Section B.4.62,  Up: Section B.4

B.4.63. `DIVSS': Scalar Single-Precision FP Divide
--------------------------------------------------

     DIVSS xmm1,xmm2/mem32         ; F3 0F 5E /r     [KATMAI,SSE]

   `DIVSS' divides the low-order single-precision FP value in the
destination operand by the low-order single-precision FP value in the
source operand, and stores the single-precision result in the
destination register.

   The destination is an `XMM' register. The source operand can be
either an `XMM' register or a 32-bit memory location.

        dst[0-31]   := dst[0-31] / src[0-31],
        dst[32-127] remains unchanged.


File: nasm.info,  Node: Section B.4.64,  Next: Section B.4.65,  Prev: Section B.4.63,  Up: Section B.4

B.4.64. `EMMS': Empty MMX State
-------------------------------

     EMMS                          ; 0F 77                [PENT,MMX]

   `EMMS' sets the FPU tag word (marking which floating-point registers
are available) to all ones, meaning all registers are available for the
FPU to use. It should be used after executing `MMX' instructions and
before executing any subsequent floating-point operations.


File: nasm.info,  Node: Section B.4.65,  Next: Section B.4.66,  Prev: Section B.4.64,  Up: Section B.4

B.4.65. `ENTER': Create Stack Frame
-----------------------------------

     ENTER imm,imm                 ; C8 iw ib             [186]

   `ENTER' constructs a `stack frame' for a high-level language
procedure call. The first operand (the `iw' in the opcode definition
above refers to the first operand) gives the amount of stack space to
allocate for local variables; the second (the `ib' above) gives the
nesting level of the procedure (for languages like Pascal, with nested
procedures).

   The function of `ENTER', with a nesting level of zero, is equivalent
to

               PUSH EBP            ; or PUSH BP         in 16 bits
               MOV EBP,ESP         ; or MOV BP,SP       in 16 bits
               SUB ESP,operand1    ; or SUB SP,operand1 in 16 bits

   This creates a stack frame with the procedure parameters accessible
upwards from `EBP', and local variables accessible downwards from `EBP'.

   With a nesting level of one, the stack frame created is 4 (or 2)
bytes bigger, and the value of the final frame pointer `EBP' is
accessible in memory at `[EBP-4]'.

   This allows `ENTER', when called with a nesting level of two, to look
at the stack frame described by the _previous_ value of `EBP', find the
frame pointer at offset -4 from that, and push it along with its new
frame pointer, so that when a level-two procedure is called from within
a level-one procedure, `[EBP-4]' holds the frame pointer of the most
recent level-one procedure call and `[EBP-8]' holds that of the most
recent level-two call. And so on, for nesting levels up to 31.

   Stack frames created by `ENTER' can be destroyed by the `LEAVE'
instruction: see *Note Section B.4.136::.


File: nasm.info,  Node: Section B.4.66,  Next: Section B.4.67,  Prev: Section B.4.65,  Up: Section B.4

B.4.66. `F2XM1': Calculate 2**X-1
---------------------------------

     F2XM1                         ; D9 F0                [8086,FPU]

   `F2XM1' raises 2 to the power of `ST0', subtracts one, and stores
the result back into `ST0'. The initial contents of `ST0' must be a
number in the range -1.0 to +1.0.


File: nasm.info,  Node: Section B.4.67,  Next: Section B.4.68,  Prev: Section B.4.66,  Up: Section B.4

B.4.67. `FABS': Floating-Point Absolute Value
---------------------------------------------

     FABS                          ; D9 E1                [8086,FPU]

   `FABS' computes the absolute value of `ST0',by clearing the sign
bit, and stores the result back in `ST0'.


File: nasm.info,  Node: Section B.4.68,  Next: Section B.4.69,  Prev: Section B.4.67,  Up: Section B.4

B.4.68. `FADD', `FADDP': Floating-Point Addition
------------------------------------------------

     FADD mem32                    ; D8 /0                [8086,FPU]
     FADD mem64                    ; DC /0                [8086,FPU]

     FADD fpureg                   ; D8 C0+r              [8086,FPU]
     FADD ST0,fpureg               ; D8 C0+r              [8086,FPU]

     FADD TO fpureg                ; DC C0+r              [8086,FPU]
     FADD fpureg,ST0               ; DC C0+r              [8086,FPU]

     FADDP fpureg                  ; DE C0+r              [8086,FPU]
     FADDP fpureg,ST0              ; DE C0+r              [8086,FPU]

   * `FADD', given one operand, adds the operand to `ST0' and stores
     the result back in `ST0'. If the operand has the `TO' modifier,
     the result is stored in the register given rather than in `ST0'.

   * `FADDP' performs the same function as `FADD TO', but pops the
     register stack after storing the result.

   The given two-operand forms are synonyms for the one-operand forms.

   To add an integer value to `ST0', use the c{FIADD} instruction
(*Note Section B.4.80::)


File: nasm.info,  Node: Section B.4.69,  Next: Section B.4.70,  Prev: Section B.4.68,  Up: Section B.4

B.4.69. `FBLD', `FBSTP': BCD Floating-Point Load and Store
----------------------------------------------------------

     FBLD mem80                    ; DF /4                [8086,FPU]
     FBSTP mem80                   ; DF /6                [8086,FPU]

   `FBLD' loads an 80-bit (ten-byte) packed binary-coded decimal number
from the given memory address, converts it to a real, and pushes it on
the register stack. `FBSTP' stores the value of `ST0', in packed BCD,
at the given address and then pops the register stack.


File: nasm.info,  Node: Section B.4.70,  Next: Section B.4.71,  Prev: Section B.4.69,  Up: Section B.4

B.4.70. `FCHS': Floating-Point Change Sign
------------------------------------------

     FCHS                          ; D9 E0                [8086,FPU]

   `FCHS' negates the number in `ST0', by inverting the sign bit:
negative numbers become positive, and vice versa.


File: nasm.info,  Node: Section B.4.71,  Next: Section B.4.72,  Prev: Section B.4.70,  Up: Section B.4

B.4.71. `FCLEX', `FNCLEX': Clear Floating-Point Exceptions
----------------------------------------------------------

     FCLEX                         ; 9B DB E2             [8086,FPU]
     FNCLEX                        ; DB E2                [8086,FPU]

   `FCLEX' clears any floating-point exceptions which may be pending.
`FNCLEX' does the same thing but doesn't wait for previous floating-
point operations (including the _handling_ of pending exceptions) to
finish first.


File: nasm.info,  Node: Section B.4.72,  Next: Section B.4.73,  Prev: Section B.4.71,  Up: Section B.4

B.4.72. `FCMOVcc': Floating-Point Conditional Move
--------------------------------------------------

     FCMOVB fpureg                 ; DA C0+r              [P6,FPU]
     FCMOVB ST0,fpureg             ; DA C0+r              [P6,FPU]

     FCMOVE fpureg                 ; DA C8+r              [P6,FPU]
     FCMOVE ST0,fpureg             ; DA C8+r              [P6,FPU]

     FCMOVBE fpureg                ; DA D0+r              [P6,FPU]
     FCMOVBE ST0,fpureg            ; DA D0+r              [P6,FPU]

     FCMOVU fpureg                 ; DA D8+r              [P6,FPU]
     FCMOVU ST0,fpureg             ; DA D8+r              [P6,FPU]

     FCMOVNB fpureg                ; DB C0+r              [P6,FPU]
     FCMOVNB ST0,fpureg            ; DB C0+r              [P6,FPU]

     FCMOVNE fpureg                ; DB C8+r              [P6,FPU]
     FCMOVNE ST0,fpureg            ; DB C8+r              [P6,FPU]

     FCMOVNBE fpureg               ; DB D0+r              [P6,FPU]
     FCMOVNBE ST0,fpureg           ; DB D0+r              [P6,FPU]

     FCMOVNU fpureg                ; DB D8+r              [P6,FPU]
     FCMOVNU ST0,fpureg            ; DB D8+r              [P6,FPU]

   The `FCMOV' instructions perform conditional move operations: each of
them moves the contents of the given register into `ST0' if its
condition is satisfied, and does nothing if not.

   The conditions are not the same as the standard condition codes used
with conditional jump instructions. The conditions `B', `BE', `NB',
`NBE', `E' and `NE' are exactly as normal, but none of the other
standard ones are supported. Instead, the condition `U' and its
counterpart `NU' are provided; the `U' condition is satisfied if the
last two floating-point numbers compared were _unordered_, i.e. they
were not equal but neither one could be said to be greater than the
other, for example if they were NaNs. (The flag state which signals
this is the setting of the parity flag: so the `U' condition is
notionally equivalent to `PE', and `NU' is equivalent to `PO'.)

   The `FCMOV' conditions test the main processor's status flags, not
the FPU status flags, so using `FCMOV' directly after `FCOM' will not
work. Instead, you should either use `FCOMI' which writes directly to
the main CPU flags word, or use `FSTSW' to extract the FPU flags.

   Although the `FCMOV' instructions are flagged `P6' above, they may
not be supported by all Pentium Pro processors; the `CPUID' instruction
(*Note Section B.4.34::) will return a bit which indicates whether
conditional moves are supported.


File: nasm.info,  Node: Section B.4.73,  Next: Section B.4.74,  Prev: Section B.4.72,  Up: Section B.4

B.4.73. `FCOM', `FCOMP', `FCOMPP', `FCOMI', `FCOMIP': Floating-Point Compare
----------------------------------------------------------------------------

     FCOM mem32                    ; D8 /2                [8086,FPU]
     FCOM mem64                    ; DC /2                [8086,FPU]
     FCOM fpureg                   ; D8 D0+r              [8086,FPU]
     FCOM ST0,fpureg               ; D8 D0+r              [8086,FPU]

     FCOMP mem32                   ; D8 /3                [8086,FPU]
     FCOMP mem64                   ; DC /3                [8086,FPU]
     FCOMP fpureg                  ; D8 D8+r              [8086,FPU]
     FCOMP ST0,fpureg              ; D8 D8+r              [8086,FPU]

     FCOMPP                        ; DE D9                [8086,FPU]

     FCOMI fpureg                  ; DB F0+r              [P6,FPU]
     FCOMI ST0,fpureg              ; DB F0+r              [P6,FPU]

     FCOMIP fpureg                 ; DF F0+r              [P6,FPU]
     FCOMIP ST0,fpureg             ; DF F0+r              [P6,FPU]

   `FCOM' compares `ST0' with the given operand, and sets the FPU flags
accordingly. `ST0' is treated as the left-hand side of the comparison,
so that the carry flag is set (for a `less-than' result) if `ST0' is
less than the given operand.

   `FCOMP' does the same as `FCOM', but pops the register stack
afterwards. `FCOMPP' compares `ST0' with `ST1' and then pops the
register stack twice.

   `FCOMI' and `FCOMIP' work like the corresponding forms of `FCOM' and
`FCOMP', but write their results directly to the CPU flags register
rather than the FPU status word, so they can be immediately followed by
conditional jump or conditional move instructions.

   The `FCOM' instructions differ from the `FUCOM' instructions (*Note
Section B.4.108::) only in the way they handle quiet NaNs: `FUCOM' will
handle them silently and set the condition code flags to an `unordered'
result, whereas `FCOM' will generate an exception.


File: nasm.info,  Node: Section B.4.74,  Next: Section B.4.75,  Prev: Section B.4.73,  Up: Section B.4

B.4.74. `FCOS': Cosine
----------------------

     FCOS                          ; D9 FF                [386,FPU]

   `FCOS' computes the cosine of `ST0' (in radians), and stores the
result in `ST0'. The absolute value of `ST0' must be less than 2**63.

   See also `FSINCOS' (*Note Section B.4.100::).


File: nasm.info,  Node: Section B.4.75,  Next: Section B.4.76,  Prev: Section B.4.74,  Up: Section B.4

B.4.75. `FDECSTP': Decrement Floating-Point Stack Pointer
---------------------------------------------------------

     FDECSTP                       ; D9 F6                [8086,FPU]

   `FDECSTP' decrements the `top' field in the floating-point status
word. This has the effect of rotating the FPU register stack by one, as
if the contents of `ST7' had been pushed on the stack. See also
`FINCSTP' (*Note Section B.4.85::).


File: nasm.info,  Node: Section B.4.76,  Next: Section B.4.77,  Prev: Section B.4.75,  Up: Section B.4

B.4.76. `FxDISI', `FxENI': Disable and Enable Floating-Point Interrupts
-----------------------------------------------------------------------

     FDISI                         ; 9B DB E1             [8086,FPU]
     FNDISI                        ; DB E1                [8086,FPU]

     FENI                          ; 9B DB E0             [8086,FPU]
     FNENI                         ; DB E0                [8086,FPU]

   `FDISI' and `FENI' disable and enable floating-point interrupts.
These instructions are only meaningful on original 8087 processors: the
287 and above treat them as no-operation instructions.

   `FNDISI' and `FNENI' do the same thing as `FDISI' and `FENI'
respectively, but without waiting for the floating-point processor to
finish what it was doing first.


File: nasm.info,  Node: Section B.4.77,  Next: Section B.4.78,  Prev: Section B.4.76,  Up: Section B.4

B.4.77. `FDIV', `FDIVP', `FDIVR', `FDIVRP': Floating-Point Division
-------------------------------------------------------------------

     FDIV mem32                    ; D8 /6                [8086,FPU]
     FDIV mem64                    ; DC /6                [8086,FPU]

     FDIV fpureg                   ; D8 F0+r              [8086,FPU]
     FDIV ST0,fpureg               ; D8 F0+r              [8086,FPU]

     FDIV TO fpureg                ; DC F8+r              [8086,FPU]
     FDIV fpureg,ST0               ; DC F8+r              [8086,FPU]

     FDIVR mem32                   ; D8 /7                [8086,FPU]
     FDIVR mem64                   ; DC /7                [8086,FPU]

     FDIVR fpureg                  ; D8 F8+r              [8086,FPU]
     FDIVR ST0,fpureg              ; D8 F8+r              [8086,FPU]

     FDIVR TO fpureg               ; DC F0+r              [8086,FPU]
     FDIVR fpureg,ST0              ; DC F0+r              [8086,FPU]

     FDIVP fpureg                  ; DE F8+r              [8086,FPU]
     FDIVP fpureg,ST0              ; DE F8+r              [8086,FPU]

     FDIVRP fpureg                 ; DE F0+r              [8086,FPU]
     FDIVRP fpureg,ST0             ; DE F0+r              [8086,FPU]

   * `FDIV' divides `ST0' by the given operand and stores the result
     back in `ST0', unless the `TO' qualifier is given, in which case
     it divides the given operand by `ST0' and stores the result in the
     operand.

   * `FDIVR' does the same thing, but does the division the other way
     up: so if `TO' is not given, it divides the given operand by `ST0'
     and stores the result in `ST0', whereas if `TO' is given it
     divides `ST0' by its operand and stores the result in the operand.

   * `FDIVP' operates like `FDIV TO', but pops the register stack once
     it has finished.

   * `FDIVRP' operates like `FDIVR TO', but pops the register stack
     once it has finished.

   For FP/Integer divisions, see `FIDIV' (*Note Section B.4.82::).


File: nasm.info,  Node: Section B.4.78,  Next: Section B.4.79,  Prev: Section B.4.77,  Up: Section B.4

B.4.78. `FEMMS': Faster Enter/Exit of the MMX or floating-point state
---------------------------------------------------------------------

     FEMMS                         ; 0F 0E           [PENT,3DNOW]

   `FEMMS' can be used in place of the `EMMS' instruction on processors
which support the 3DNow! instruction set. Following execution of
`FEMMS', the state of the `MMX/FP' registers is undefined, and this
allows a faster context switch between `FP' and `MMX' instructions. The
`FEMMS' instruction can also be used _before_ executing `MMX'
instructions


File: nasm.info,  Node: Section B.4.79,  Next: Section B.4.80,  Prev: Section B.4.78,  Up: Section B.4

B.4.79. `FFREE': Flag Floating-Point Register as Unused
-------------------------------------------------------

     FFREE fpureg                  ; DD C0+r              [8086,FPU]
     FFREEP fpureg                 ; DF C0+r              [286,FPU,UNDOC]

   `FFREE' marks the given register as being empty.

   `FFREEP' marks the given register as being empty, and then pops the
register stack.


File: nasm.info,  Node: Section B.4.80,  Next: Section B.4.81,  Prev: Section B.4.79,  Up: Section B.4

B.4.80. `FIADD': Floating-Point/Integer Addition
------------------------------------------------

     FIADD mem16                   ; DE /0                [8086,FPU]
     FIADD mem32                   ; DA /0                [8086,FPU]

   `FIADD' adds the 16-bit or 32-bit integer stored in the given memory
location to `ST0', storing the result in `ST0'.


File: nasm.info,  Node: Section B.4.81,  Next: Section B.4.82,  Prev: Section B.4.80,  Up: Section B.4

B.4.81. `FICOM', `FICOMP': Floating-Point/Integer Compare
---------------------------------------------------------

     FICOM mem16                   ; DE /2                [8086,FPU]
     FICOM mem32                   ; DA /2                [8086,FPU]

     FICOMP mem16                  ; DE /3                [8086,FPU]
     FICOMP mem32                  ; DA /3                [8086,FPU]

   `FICOM' compares `ST0' with the 16-bit or 32-bit integer stored in
the given memory location, and sets the FPU flags accordingly.
`FICOMP' does the same, but pops the register stack afterwards.


File: nasm.info,  Node: Section B.4.82,  Next: Section B.4.83,  Prev: Section B.4.81,  Up: Section B.4

B.4.82. `FIDIV', `FIDIVR': Floating-Point/Integer Division
----------------------------------------------------------

     FIDIV mem16                   ; DE /6                [8086,FPU]
     FIDIV mem32                   ; DA /6                [8086,FPU]

     FIDIVR mem16                  ; DE /7                [8086,FPU]
     FIDIVR mem32                  ; DA /7                [8086,FPU]

   `FIDIV' divides `ST0' by the 16-bit or 32-bit integer stored in the
given memory location, and stores the result in `ST0'.  `FIDIVR' does
the division the other way up: it divides the integer by `ST0', but
still stores the result in `ST0'.


File: nasm.info,  Node: Section B.4.83,  Next: Section B.4.84,  Prev: Section B.4.82,  Up: Section B.4

B.4.83. `FILD', `FIST', `FISTP': Floating-Point/Integer Conversion
------------------------------------------------------------------

     FILD mem16                    ; DF /0                [8086,FPU]
     FILD mem32                    ; DB /0                [8086,FPU]
     FILD mem64                    ; DF /5                [8086,FPU]

     FIST mem16                    ; DF /2                [8086,FPU]
     FIST mem32                    ; DB /2                [8086,FPU]

     FISTP mem16                   ; DF /3                [8086,FPU]
     FISTP mem32                   ; DB /3                [8086,FPU]
     FISTP mem64                   ; DF /7                [8086,FPU]

   `FILD' loads an integer out of a memory location, converts it to a
real, and pushes it on the FPU register stack. `FIST' converts `ST0' to
an integer and stores that in memory; `FISTP' does the same as `FIST',
but pops the register stack afterwards.


File: nasm.info,  Node: Section B.4.84,  Next: Section B.4.85,  Prev: Section B.4.83,  Up: Section B.4

B.4.84. `FIMUL': Floating-Point/Integer Multiplication
------------------------------------------------------

     FIMUL mem16                   ; DE /1                [8086,FPU]
     FIMUL mem32                   ; DA /1                [8086,FPU]

   `FIMUL' multiplies `ST0' by the 16-bit or 32-bit integer stored in
the given memory location, and stores the result in `ST0'.


File: nasm.info,  Node: Section B.4.85,  Next: Section B.4.86,  Prev: Section B.4.84,  Up: Section B.4

B.4.85. `FINCSTP': Increment Floating-Point Stack Pointer
---------------------------------------------------------

     FINCSTP                       ; D9 F7                [8086,FPU]

   `FINCSTP' increments the `top' field in the floating-point status
word. This has the effect of rotating the FPU register stack by one, as
if the register stack had been popped; however, unlike the popping of
the stack performed by many FPU instructions, it does not flag the new
`ST7' (previously `ST0') as empty. See also `FDECSTP' (*Note Section
B.4.75::).


File: nasm.info,  Node: Section B.4.86,  Next: Section B.4.87,  Prev: Section B.4.85,  Up: Section B.4

B.4.86. `FINIT', `FNINIT': Initialise Floating-Point Unit
---------------------------------------------------------

     FINIT                         ; 9B DB E3             [8086,FPU]
     FNINIT                        ; DB E3                [8086,FPU]

   `FINIT' initialises the FPU to its default state. It flags all
registers as empty, without actually change their values, clears the
top of stack pointer. `FNINIT' does the same, without first waiting for
pending exceptions to clear.


File: nasm.info,  Node: Section B.4.87,  Next: Section B.4.88,  Prev: Section B.4.86,  Up: Section B.4

B.4.87. `FISUB': Floating-Point/Integer Subtraction
---------------------------------------------------

     FISUB mem16                   ; DE /4                [8086,FPU]
     FISUB mem32                   ; DA /4                [8086,FPU]

     FISUBR mem16                  ; DE /5                [8086,FPU]
     FISUBR mem32                  ; DA /5                [8086,FPU]

   `FISUB' subtracts the 16-bit or 32-bit integer stored in the given
memory location from `ST0', and stores the result in `ST0'.  `FISUBR'
does the subtraction the other way round, i.e. it subtracts `ST0' from
the given integer, but still stores the result in `ST0'.


File: nasm.info,  Node: Section B.4.88,  Next: Section B.4.89,  Prev: Section B.4.87,  Up: Section B.4

B.4.88. `FLD': Floating-Point Load
----------------------------------

     FLD mem32                     ; D9 /0                [8086,FPU]
     FLD mem64                     ; DD /0                [8086,FPU]
     FLD mem80                     ; DB /5                [8086,FPU]
     FLD fpureg                    ; D9 C0+r              [8086,FPU]

   `FLD' loads a floating-point value out of the given register or
memory location, and pushes it on the FPU register stack.


File: nasm.info,  Node: Section B.4.89,  Next: Section B.4.90,  Prev: Section B.4.88,  Up: Section B.4

B.4.89. `FLDxx': Floating-Point Load Constants
----------------------------------------------

     FLD1                          ; D9 E8                [8086,FPU]
     FLDL2E                        ; D9 EA                [8086,FPU]
     FLDL2T                        ; D9 E9                [8086,FPU]
     FLDLG2                        ; D9 EC                [8086,FPU]
     FLDLN2                        ; D9 ED                [8086,FPU]
     FLDPI                         ; D9 EB                [8086,FPU]
     FLDZ                          ; D9 EE                [8086,FPU]

   These instructions push specific standard constants on the FPU
register stack.

      Instruction    Constant pushed

      FLD1           1
      FLDL2E         base-2 logarithm of e
      FLDL2T         base-2 log of 10
      FLDLG2         base-10 log of 2
      FLDLN2         base-e log of 2
      FLDPI          pi
      FLDZ           zero


File: nasm.info,  Node: Section B.4.90,  Next: Section B.4.91,  Prev: Section B.4.89,  Up: Section B.4

B.4.90. `FLDCW': Load Floating-Point Control Word
-------------------------------------------------

     FLDCW mem16                   ; D9 /5                [8086,FPU]

   `FLDCW' loads a 16-bit value out of memory and stores it into the FPU
control word (governing things like the rounding mode, the precision,
and the exception masks). See also `FSTCW' (*Note Section B.4.103::). If
exceptions are enabled and you don't want to generate one, use `FCLEX'
or `FNCLEX' (*Note Section B.4.71::) before loading the new control
word.


File: nasm.info,  Node: Section B.4.91,  Next: Section B.4.92,  Prev: Section B.4.90,  Up: Section B.4

B.4.91. `FLDENV': Load Floating-Point Environment
-------------------------------------------------

     FLDENV mem                    ; D9 /4                [8086,FPU]

   `FLDENV' loads the FPU operating environment (control word, status
word, tag word, instruction pointer, data pointer and last opcode) from
memory. The memory area is 14 or 28 bytes long, depending on the CPU
mode at the time. See also `FSTENV' (*Note Section B.4.104::).


File: nasm.info,  Node: Section B.4.92,  Next: Section B.4.93,  Prev: Section B.4.91,  Up: Section B.4

B.4.92. `FMUL', `FMULP': Floating-Point Multiply
------------------------------------------------

     FMUL mem32                    ; D8 /1                [8086,FPU]
     FMUL mem64                    ; DC /1                [8086,FPU]

     FMUL fpureg                   ; D8 C8+r              [8086,FPU]
     FMUL ST0,fpureg               ; D8 C8+r              [8086,FPU]

     FMUL TO fpureg                ; DC C8+r              [8086,FPU]
     FMUL fpureg,ST0               ; DC C8+r              [8086,FPU]

     FMULP fpureg                  ; DE C8+r              [8086,FPU]
     FMULP fpureg,ST0              ; DE C8+r              [8086,FPU]

   `FMUL' multiplies `ST0' by the given operand, and stores the result
in `ST0', unless the `TO' qualifier is used in which case it stores the
result in the operand. `FMULP' performs the same operation as `FMUL
TO', and then pops the register stack.


File: nasm.info,  Node: Section B.4.93,  Next: Section B.4.94,  Prev: Section B.4.92,  Up: Section B.4

B.4.93. `FNOP': Floating-Point No Operation
-------------------------------------------

     FNOP                          ; D9 D0                [8086,FPU]

   `FNOP' does nothing.


File: nasm.info,  Node: Section B.4.94,  Next: Section B.4.95,  Prev: Section B.4.93,  Up: Section B.4

B.4.94. `FPATAN', `FPTAN': Arctangent and Tangent
-------------------------------------------------

     FPATAN                        ; D9 F3                [8086,FPU]
     FPTAN                         ; D9 F2                [8086,FPU]

   `FPATAN' computes the arctangent, in radians, of the result of
dividing `ST1' by `ST0', stores the result in `ST1', and pops the
register stack. It works like the C `atan2' function, in that changing
the sign of both `ST0' and `ST1' changes the output value by pi (so it
performs true rectangular-to-polar coordinate conversion, with `ST1'
being the Y coordinate and `ST0' being the X coordinate, not merely an
arctangent).

   `FPTAN' computes the tangent of the value in `ST0' (in radians), and
stores the result back into `ST0'.

   The absolute value of `ST0' must be less than 2**63.


File: nasm.info,  Node: Section B.4.95,  Next: Section B.4.96,  Prev: Section B.4.94,  Up: Section B.4

B.4.95. `FPREM', `FPREM1': Floating-Point Partial Remainder
-----------------------------------------------------------

     FPREM                         ; D9 F8                [8086,FPU]
     FPREM1                        ; D9 F5                [386,FPU]

   These instructions both produce the remainder obtained by dividing
`ST0' by `ST1'. This is calculated, notionally, by dividing `ST0' by
`ST1', rounding the result to an integer, multiplying by `ST1' again,
and computing the value which would need to be added back on to the
result to get back to the original value in `ST0'.

   The two instructions differ in the way the notional round-to-integer
operation is performed. `FPREM' does it by rounding towards zero, so
that the remainder it returns always has the same sign as the original
value in `ST0'; `FPREM1' does it by rounding to the nearest integer, so
that the remainder always has at most half the magnitude of `ST1'.

   Both instructions calculate _partial_ remainders, meaning that they
may not manage to provide the final result, but might leave intermediate
results in `ST0' instead. If this happens, they will set the C2 flag in
the FPU status word; therefore, to calculate a remainder, you should
repeatedly execute `FPREM' or `FPREM1' until C2 becomes clear.


File: nasm.info,  Node: Section B.4.96,  Next: Section B.4.97,  Prev: Section B.4.95,  Up: Section B.4

B.4.96. `FRNDINT': Floating-Point Round to Integer
--------------------------------------------------

     FRNDINT                       ; D9 FC                [8086,FPU]

   `FRNDINT' rounds the contents of `ST0' to an integer, according to
the current rounding mode set in the FPU control word, and stores the
result back in `ST0'.


File: nasm.info,  Node: Section B.4.97,  Next: Section B.4.98,  Prev: Section B.4.96,  Up: Section B.4

B.4.97. `FSAVE', `FRSTOR': Save/Restore Floating-Point State
------------------------------------------------------------

     FSAVE mem                     ; 9B DD /6             [8086,FPU]
     FNSAVE mem                    ; DD /6                [8086,FPU]

     FRSTOR mem                    ; DD /4                [8086,FPU]

   `FSAVE' saves the entire floating-point unit state, including all the
information saved by `FSTENV' (*Note Section B.4.104::) plus the
contents of all the registers, to a 94 or 108 byte area of memory
(depending on the CPU mode). `FRSTOR' restores the floating-point state
from the same area of memory.

   `FNSAVE' does the same as `FSAVE', without first waiting for pending
floating-point exceptions to clear.


File: nasm.info,  Node: Section B.4.98,  Next: Section B.4.99,  Prev: Section B.4.97,  Up: Section B.4

B.4.98. `FSCALE': Scale Floating-Point Value by Power of Two
------------------------------------------------------------

     FSCALE                        ; D9 FD                [8086,FPU]

   `FSCALE' scales a number by a power of two: it rounds `ST1' towards
zero to obtain an integer, then multiplies `ST0' by two to the power of
that integer, and stores the result in `ST0'.


File: nasm.info,  Node: Section B.4.99,  Next: Section B.4.100,  Prev: Section B.4.98,  Up: Section B.4

B.4.99. `FSETPM': Set Protected Mode
------------------------------------

     FSETPM                        ; DB E4                [286,FPU]

   This instruction initialises protected mode on the 287 floating-point
coprocessor. It is only meaningful on that processor: the 387 and above
treat the instruction as a no-operation.


File: nasm.info,  Node: Section B.4.100,  Next: Section B.4.101,  Prev: Section B.4.99,  Up: Section B.4

B.4.100. `FSIN', `FSINCOS': Sine and Cosine
-------------------------------------------

     FSIN                          ; D9 FE                [386,FPU]
     FSINCOS                       ; D9 FB                [386,FPU]

   `FSIN' calculates the sine of `ST0' (in radians) and stores the
result in `ST0'. `FSINCOS' does the same, but then pushes the cosine of
the same value on the register stack, so that the sine ends up in `ST1'
and the cosine in `ST0'. `FSINCOS' is faster than executing `FSIN' and
`FCOS' (see *Note Section B.4.74::) in succession.

   The absolute value of `ST0' must be less than 2**63.


File: nasm.info,  Node: Section B.4.101,  Next: Section B.4.102,  Prev: Section B.4.100,  Up: Section B.4

B.4.101. `FSQRT': Floating-Point Square Root
--------------------------------------------

     FSQRT                         ; D9 FA                [8086,FPU]

   `FSQRT' calculates the square root of `ST0' and stores the result in
`ST0'.


File: nasm.info,  Node: Section B.4.102,  Next: Section B.4.103,  Prev: Section B.4.101,  Up: Section B.4

B.4.102. `FST', `FSTP': Floating-Point Store
--------------------------------------------

     FST mem32                     ; D9 /2                [8086,FPU]
     FST mem64                     ; DD /2                [8086,FPU]
     FST fpureg                    ; DD D0+r              [8086,FPU]

     FSTP mem32                    ; D9 /3                [8086,FPU]
     FSTP mem64                    ; DD /3                [8086,FPU]
     FSTP mem80                    ; DB /7                [8086,FPU]
     FSTP fpureg                   ; DD D8+r              [8086,FPU]

   `FST' stores the value in `ST0' into the given memory location or
other FPU register. `FSTP' does the same, but then pops the register
stack.


File: nasm.info,  Node: Section B.4.103,  Next: Section B.4.104,  Prev: Section B.4.102,  Up: Section B.4

B.4.103. `FSTCW': Store Floating-Point Control Word
---------------------------------------------------

     FSTCW mem16                   ; 9B D9 /7             [8086,FPU]
     FNSTCW mem16                  ; D9 /7                [8086,FPU]

   `FSTCW' stores the `FPU' control word (governing things like the
rounding mode, the precision, and the exception masks) into a 2-byte
memory area. See also `FLDCW' (*Note Section B.4.90::).

   `FNSTCW' does the same thing as `FSTCW', without first waiting for
pending floating-point exceptions to clear.


File: nasm.info,  Node: Section B.4.104,  Next: Section B.4.105,  Prev: Section B.4.103,  Up: Section B.4

B.4.104. `FSTENV': Store Floating-Point Environment
---------------------------------------------------

     FSTENV mem                    ; 9B D9 /6             [8086,FPU]
     FNSTENV mem                   ; D9 /6                [8086,FPU]

   `FSTENV' stores the `FPU' operating environment (control word,
status word, tag word, instruction pointer, data pointer and last
opcode) into memory. The memory area is 14 or 28 bytes long, depending
on the CPU mode at the time. See also `FLDENV' (*Note Section B.4.91::).

   `FNSTENV' does the same thing as `FSTENV', without first waiting for
pending floating-point exceptions to clear.


File: nasm.info,  Node: Section B.4.105,  Next: Section B.4.106,  Prev: Section B.4.104,  Up: Section B.4

B.4.105. `FSTSW': Store Floating-Point Status Word
--------------------------------------------------

     FSTSW mem16                   ; 9B DD /7             [8086,FPU]
     FSTSW AX                      ; 9B DF E0             [286,FPU]

     FNSTSW mem16                  ; DD /7                [8086,FPU]
     FNSTSW AX                     ; DF E0                [286,FPU]

   `FSTSW' stores the `FPU' status word into `AX' or into a 2- byte
memory area.

   `FNSTSW' does the same thing as `FSTSW', without first waiting for
pending floating-point exceptions to clear.


File: nasm.info,  Node: Section B.4.106,  Next: Section B.4.107,  Prev: Section B.4.105,  Up: Section B.4

B.4.106. `FSUB', `FSUBP', `FSUBR', `FSUBRP': Floating-Point Subtract
--------------------------------------------------------------------

     FSUB mem32                    ; D8 /4                [8086,FPU]
     FSUB mem64                    ; DC /4                [8086,FPU]

     FSUB fpureg                   ; D8 E0+r              [8086,FPU]
     FSUB ST0,fpureg               ; D8 E0+r              [8086,FPU]

     FSUB TO fpureg                ; DC E8+r              [8086,FPU]
     FSUB fpureg,ST0               ; DC E8+r              [8086,FPU]

     FSUBR mem32                   ; D8 /5                [8086,FPU]
     FSUBR mem64                   ; DC /5                [8086,FPU]

     FSUBR fpureg                  ; D8 E8+r              [8086,FPU]
     FSUBR ST0,fpureg              ; D8 E8+r              [8086,FPU]

     FSUBR TO fpureg               ; DC E0+r              [8086,FPU]
     FSUBR fpureg,ST0              ; DC E0+r              [8086,FPU]

     FSUBP fpureg                  ; DE E8+r              [8086,FPU]
     FSUBP fpureg,ST0              ; DE E8+r              [8086,FPU]

     FSUBRP fpureg                 ; DE E0+r              [8086,FPU]
     FSUBRP fpureg,ST0             ; DE E0+r              [8086,FPU]

   * `FSUB' subtracts the given operand from `ST0' and stores the
     result back in `ST0', unless the `TO' qualifier is given, in which
     case it subtracts `ST0' from the given operand and stores the
     result in the operand.

   * `FSUBR' does the same thing, but does the subtraction the other way
     up: so if `TO' is not given, it subtracts `ST0' from the given
     operand and stores the result in `ST0', whereas if `TO' is given
     it subtracts its operand from `ST0' and stores the result in the
     operand.

   * `FSUBP' operates like `FSUB TO', but pops the register stack once
     it has finished.

   * `FSUBRP' operates like `FSUBR TO', but pops the register stack
     once it has finished.


File: nasm.info,  Node: Section B.4.107,  Next: Section B.4.108,  Prev: Section B.4.106,  Up: Section B.4

B.4.107. `FTST': Test `ST0' Against Zero
----------------------------------------

     FTST                          ; D9 E4                [8086,FPU]

   `FTST' compares `ST0' with zero and sets the FPU flags accordingly.
`ST0' is treated as the left-hand side of the comparison, so that a
`less-than' result is generated if `ST0' is negative.


File: nasm.info,  Node: Section B.4.108,  Next: Section B.4.109,  Prev: Section B.4.107,  Up: Section B.4

B.4.108. `FUCOMxx': Floating-Point Unordered Compare
----------------------------------------------------

     FUCOM fpureg                  ; DD E0+r              [386,FPU]
     FUCOM ST0,fpureg              ; DD E0+r              [386,FPU]

     FUCOMP fpureg                 ; DD E8+r              [386,FPU]
     FUCOMP ST0,fpureg             ; DD E8+r              [386,FPU]

     FUCOMPP                       ; DA E9                [386,FPU]

     FUCOMI fpureg                 ; DB E8+r              [P6,FPU]
     FUCOMI ST0,fpureg             ; DB E8+r              [P6,FPU]

     FUCOMIP fpureg                ; DF E8+r              [P6,FPU]
     FUCOMIP ST0,fpureg            ; DF E8+r              [P6,FPU]

   * `FUCOM' compares `ST0' with the given operand, and sets the FPU
     flags accordingly. `ST0' is treated as the left-hand side of the
     comparison, so that the carry flag is set (for a `less-than'
     result) if `ST0' is less than the given operand.

   * `FUCOMP' does the same as `FUCOM', but pops the register stack
     afterwards. `FUCOMPP' compares `ST0' with `ST1' and then pops the
     register stack twice.

   * `FUCOMI' and `FUCOMIP' work like the corresponding forms of
     `FUCOM' and `FUCOMP', but write their results directly to the CPU
     flags register rather than the FPU status word, so they can be
     immediately followed by conditional jump or conditional move
     instructions.

   The `FUCOM' instructions differ from the `FCOM' instructions (*Note
Section B.4.73::) only in the way they handle quiet NaNs: `FUCOM' will
handle them silently and set the condition code flags to an `unordered'
result, whereas `FCOM' will generate an exception.


File: nasm.info,  Node: Section B.4.109,  Next: Section B.4.110,  Prev: Section B.4.108,  Up: Section B.4

B.4.109. `FXAM': Examine Class of Value in `ST0'
------------------------------------------------

     FXAM                          ; D9 E5                [8086,FPU]

   `FXAM' sets the FPU flags `C3', `C2' and `C0' depending on the type
of value stored in `ST0':

      Register contents     Flags

      Unsupported format    000
      NaN                   001
      Finite number         010
      Infinity              011
      Zero                  100
      Empty register        101
      Denormal              110

   Additionally, the `C1' flag is set to the sign of the number.


File: nasm.info,  Node: Section B.4.110,  Next: Section B.4.111,  Prev: Section B.4.109,  Up: Section B.4

B.4.110. `FXCH': Floating-Point Exchange
----------------------------------------

     FXCH                          ; D9 C9                [8086,FPU]
     FXCH fpureg                   ; D9 C8+r              [8086,FPU]
     FXCH fpureg,ST0               ; D9 C8+r              [8086,FPU]
     FXCH ST0,fpureg               ; D9 C8+r              [8086,FPU]

   `FXCH' exchanges `ST0' with a given FPU register. The no-operand
form exchanges `ST0' with `ST1'.


File: nasm.info,  Node: Section B.4.111,  Next: Section B.4.112,  Prev: Section B.4.110,  Up: Section B.4

B.4.111. `FXRSTOR': Restore `FP', `MMX' and `SSE' State
-------------------------------------------------------

     FXRSTOR memory                ; 0F AE /1               [P6,SSE,FPU]

   The `FXRSTOR' instruction reloads the `FPU', `MMX' and `SSE' state
(environment and registers), from the 512 byte memory area defined by
the source operand. This data should have been written by a previous
`FXSAVE'.


File: nasm.info,  Node: Section B.4.112,  Next: Section B.4.113,  Prev: Section B.4.111,  Up: Section B.4

B.4.112. `FXSAVE': Store `FP', `MMX' and `SSE' State
----------------------------------------------------

     FXSAVE memory                 ; 0F AE /0         [P6,SSE,FPU]

   `FXSAVE'The FXSAVE instruction writes the current `FPU', `MMX' and
`SSE' technology states (environment and registers), to the 512 byte
memory area defined by the destination operand. It does this without
checking for pending unmasked floating-point exceptions (similar to the
operation of `FNSAVE').

   Unlike the `FSAVE/FNSAVE' instructions, the processor retains the
contents of the `FPU', `MMX' and `SSE' state in the processor after the
state has been saved. This instruction has been optimised to maximize
floating-point save performance.


File: nasm.info,  Node: Section B.4.113,  Next: Section B.4.114,  Prev: Section B.4.112,  Up: Section B.4

B.4.113. `FXTRACT': Extract Exponent and Significand
----------------------------------------------------

     FXTRACT                       ; D9 F4                [8086,FPU]

   `FXTRACT' separates the number in `ST0' into its exponent and
significand (mantissa), stores the exponent back into `ST0', and then
pushes the significand on the register stack (so that the significand
ends up in `ST0', and the exponent in `ST1').


File: nasm.info,  Node: Section B.4.114,  Next: Section B.4.115,  Prev: Section B.4.113,  Up: Section B.4

B.4.114. `FYL2X', `FYL2XP1': Compute Y times Log2(X) or Log2(X+1)
-----------------------------------------------------------------

     FYL2X                         ; D9 F1                [8086,FPU]
     FYL2XP1                       ; D9 F9                [8086,FPU]

   `FYL2X' multiplies `ST1' by the base-2 logarithm of `ST0', stores
the result in `ST1', and pops the register stack (so that the result
ends up in `ST0'). `ST0' must be non-zero and positive.

   `FYL2XP1' works the same way, but replacing the base-2 log of `ST0'
with that of `ST0' plus one. This time, `ST0' must have magnitude no
greater than 1 minus half the square root of two.


File: nasm.info,  Node: Section B.4.115,  Next: Section B.4.116,  Prev: Section B.4.114,  Up: Section B.4

B.4.115. `HLT': Halt Processor
------------------------------

     HLT                           ; F4                   [8086,PRIV]

   `HLT' puts the processor into a halted state, where it will perform
no more operations until restarted by an interrupt or a reset.

   On the 286 and later processors, this is a privileged instruction.


File: nasm.info,  Node: Section B.4.116,  Next: Section B.4.117,  Prev: Section B.4.115,  Up: Section B.4

B.4.116. `IBTS': Insert Bit String
----------------------------------

     IBTS r/m16,reg16              ; o16 0F A7 /r         [386,UNDOC]
     IBTS r/m32,reg32              ; o32 0F A7 /r         [386,UNDOC]

   The implied operation of this instruction is:

     IBTS r/m16,AX,CL,reg16
     IBTS r/m32,EAX,CL,reg32

   Writes a bit string from the source operand to the destination. `CL'
indicates the number of bits to be copied, from the low bits of the
source.  `(E)AX' indicates the low order bit offset in the destination
that is written to. For example, if `CL' is set to 4 and `AX' (for
16-bit code) is set to 5, bits 0-3 of `src' will be copied to bits 5-8
of `dst'. This instruction is very poorly documented, and I have been
unable to find any official source of documentation on it.

   `IBTS' is supported only on the early Intel 386s, and conflicts with
the opcodes for `CMPXCHG486' (on early Intel 486s). NASM supports it
only for completeness. Its counterpart is `XBTS' (see *Note Section
B.4.332::).


File: nasm.info,  Node: Section B.4.117,  Next: Section B.4.118,  Prev: Section B.4.116,  Up: Section B.4

B.4.117. `IDIV': Signed Integer Divide
--------------------------------------

     IDIV r/m8                     ; F6 /7                [8086]
     IDIV r/m16                    ; o16 F7 /7            [8086]
     IDIV r/m32                    ; o32 F7 /7            [386]

   `IDIV' performs signed integer division. The explicit operand
provided is the divisor; the dividend and destination operands are
implicit, in the following way:

   * For `IDIV r/m8', `AX' is divided by the given operand; the
     quotient is stored in `AL' and the remainder in `AH'.

   * For `IDIV r/m16', `DX:AX' is divided by the given operand; the
     quotient is stored in `AX' and the remainder in `DX'.

   * For `IDIV r/m32', `EDX:EAX' is divided by the given operand; the
     quotient is stored in `EAX' and the remainder in `EDX'.

   Unsigned integer division is performed by the `DIV' instruction: see
*Note Section B.4.59::.


File: nasm.info,  Node: Section B.4.118,  Next: Section B.4.119,  Prev: Section B.4.117,  Up: Section B.4

B.4.118. `IMUL': Signed Integer Multiply
----------------------------------------

     IMUL r/m8                     ; F6 /5                [8086]
     IMUL r/m16                    ; o16 F7 /5            [8086]
     IMUL r/m32                    ; o32 F7 /5            [386]

     IMUL reg16,r/m16              ; o16 0F AF /r         [386]
     IMUL reg32,r/m32              ; o32 0F AF /r         [386]

     IMUL reg16,imm8               ; o16 6B /r ib         [186]
     IMUL reg16,imm16              ; o16 69 /r iw         [186]
     IMUL reg32,imm8               ; o32 6B /r ib         [386]
     IMUL reg32,imm32              ; o32 69 /r id         [386]

     IMUL reg16,r/m16,imm8         ; o16 6B /r ib         [186]
     IMUL reg16,r/m16,imm16        ; o16 69 /r iw         [186]
     IMUL reg32,r/m32,imm8         ; o32 6B /r ib         [386]
     IMUL reg32,r/m32,imm32        ; o32 69 /r id         [386]

   `IMUL' performs signed integer multiplication. For the single-operand
form, the other operand and destination are implicit, in the following
way:

   * For `IMUL r/m8', `AL' is multiplied by the given operand; the
     product is stored in `AX'.

   * For `IMUL r/m16', `AX' is multiplied by the given operand; the
     product is stored in `DX:AX'.

   * For `IMUL r/m32', `EAX' is multiplied by the given operand; the
     product is stored in `EDX:EAX'.

   The two-operand form multiplies its two operands and stores the
result in the destination (first) operand. The three-operand form
multiplies its last two operands and stores the result in the first
operand.

   The two-operand form with an immediate second operand is in fact a
shorthand for the three-operand form, as can be seen by examining the
opcode descriptions: in the two-operand form, the code `/r' takes both
its register and `r/m' parts from the same operand (the first one).

   In the forms with an 8-bit immediate operand and another longer
source operand, the immediate operand is considered to be signed, and
is sign- extended to the length of the other source operand. In these
cases, the `BYTE' qualifier is necessary to force NASM to generate this
form of the instruction.

   Unsigned integer multiplication is performed by the `MUL'
instruction: see *Note Section B.4.184::.


File: nasm.info,  Node: Section B.4.119,  Next: Section B.4.120,  Prev: Section B.4.118,  Up: Section B.4

B.4.119. `IN': Input from I/O Port
----------------------------------

     IN AL,imm8                    ; E4 ib                [8086]
     IN AX,imm8                    ; o16 E5 ib            [8086]
     IN EAX,imm8                   ; o32 E5 ib            [386]
     IN AL,DX                      ; EC                   [8086]
     IN AX,DX                      ; o16 ED               [8086]
     IN EAX,DX                     ; o32 ED               [386]

   `IN' reads a byte, word or doubleword from the specified I/O port,
and stores it in the given destination register. The port number may be
specified as an immediate value if it is between 0 and 255, and
otherwise must be stored in `DX'. See also `OUT' (*Note Section
B.4.194::).


File: nasm.info,  Node: Section B.4.120,  Next: Section B.4.121,  Prev: Section B.4.119,  Up: Section B.4

B.4.120. `INC': Increment Integer
---------------------------------

     INC reg16                     ; o16 40+r             [8086]
     INC reg32                     ; o32 40+r             [386]
     INC r/m8                      ; FE /0                [8086]
     INC r/m16                     ; o16 FF /0            [8086]
     INC r/m32                     ; o32 FF /0            [386]

   `INC' adds 1 to its operand. It does _not_ affect the carry flag: to
affect the carry flag, use `ADD something,1' (see *Note Section
B.4.3::). `INC' affects all the other flags according to the result.

   This instruction can be used with a `LOCK' prefix to allow atomic
execution.

   See also `DEC' (*Note Section B.4.58::).


File: nasm.info,  Node: Section B.4.121,  Next: Section B.4.122,  Prev: Section B.4.120,  Up: Section B.4

B.4.121. `INSB', `INSW', `INSD': Input String from I/O Port
-----------------------------------------------------------

     INSB                          ; 6C                   [186]
     INSW                          ; o16 6D               [186]
     INSD                          ; o32 6D               [386]

   `INSB' inputs a byte from the I/O port specified in `DX' and stores
it at `[ES:DI]' or `[ES:EDI]'. It then increments or decrements
(depending on the direction flag: increments if the flag is clear,
decrements if it is set) `DI' or `EDI'.

   The register used is `DI' if the address size is 16 bits, and `EDI'
if it is 32 bits. If you need to use an address size not equal to the
current `BITS' setting, you can use an explicit `a16' or `a32' prefix.

   Segment override prefixes have no effect for this instruction: the
use of `ES' for the load from `[DI]' or `[EDI]' cannot be overridden.

   `INSW' and `INSD' work in the same way, but they input a word or a
doubleword instead of a byte, and increment or decrement the addressing
register by 2 or 4 instead of 1.

   The `REP' prefix may be used to repeat the instruction `CX' (or
`ECX' - again, the address size chooses which) times.

   See also `OUTSB', `OUTSW' and `OUTSD' (*Note Section B.4.195::).


File: nasm.info,  Node: Section B.4.122,  Next: Section B.4.123,  Prev: Section B.4.121,  Up: Section B.4

B.4.122. `INT': Software Interrupt
----------------------------------

     INT imm8                      ; CD ib                [8086]

   `INT' causes a software interrupt through a specified vector number
from 0 to 255.

   The code generated by the `INT' instruction is always two bytes long:
although there are short forms for some `INT' instructions, NASM does
not generate them when it sees the `INT' mnemonic. In order to generate
single-byte breakpoint instructions, use the `INT3' or `INT1'
instructions (see *Note Section B.4.123::) instead.


File: nasm.info,  Node: Section B.4.123,  Next: Section B.4.124,  Prev: Section B.4.122,  Up: Section B.4

B.4.123. `INT3', `INT1', `ICEBP', `INT01': Breakpoints
------------------------------------------------------

     INT1                          ; F1                   [P6]
     ICEBP                         ; F1                   [P6]
     INT01                         ; F1                   [P6]

     INT3                          ; CC                   [8086]
     INT03                         ; CC                   [8086]

   `INT1' and `INT3' are short one-byte forms of the instructions `INT
1' and `INT 3' (see *Note Section B.4.122::). They perform a similar
function to their longer counterparts, but take up less code space.
They are used as breakpoints by debuggers.

   * `INT1', and its alternative synonyms `INT01' and `ICEBP', is an
     instruction used by in-circuit emulators (ICEs). It is present,
     though not documented, on some processors down to the 286, but is
     only documented for the Pentium Pro. `INT3' is the instruction
     normally used as a breakpoint by debuggers.

   * `INT3', and its synonym `INT03', is not precisely equivalent to
     `INT 3': the short form, since it is designed to be used as a
     breakpoint, bypasses the normal `IOPL' checks in virtual-8086 mode,
     and also does not go through interrupt redirection.


File: nasm.info,  Node: Section B.4.124,  Next: Section B.4.125,  Prev: Section B.4.123,  Up: Section B.4

B.4.124. `INTO': Interrupt if Overflow
--------------------------------------

     INTO                          ; CE                   [8086]

   `INTO' performs an `INT 4' software interrupt (see *Note Section
B.4.122::) if and only if the overflow flag is set.


File: nasm.info,  Node: Section B.4.125,  Next: Section B.4.126,  Prev: Section B.4.124,  Up: Section B.4

B.4.125. `INVD': Invalidate Internal Caches
-------------------------------------------

     INVD                          ; 0F 08                [486]

   `INVD' invalidates and empties the processor's internal caches, and
causes the processor to instruct external caches to do the same. It does
not write the contents of the caches back to memory first: any modified
data held in the caches will be lost. To write the data back first, use
`WBINVD' (*Note Section B.4.328::).


File: nasm.info,  Node: Section B.4.126,  Next: Section B.4.127,  Prev: Section B.4.125,  Up: Section B.4

B.4.126. `INVLPG': Invalidate TLB Entry
---------------------------------------

     INVLPG mem                    ; 0F 01 /7             [486]

   `INVLPG' invalidates the translation lookahead buffer (TLB) entry
associated with the supplied memory address.


File: nasm.info,  Node: Section B.4.127,  Next: Section B.4.128,  Prev: Section B.4.126,  Up: Section B.4

B.4.127. `IRET', `IRETW', `IRETD': Return from Interrupt
--------------------------------------------------------

     IRET                          ; CF                   [8086]
     IRETW                         ; o16 CF               [8086]
     IRETD                         ; o32 CF               [386]

   `IRET' returns from an interrupt (hardware or software) by means of
popping `IP' (or `EIP'), `CS' and the flags off the stack and then
continuing execution from the new `CS:IP'.

   `IRETW' pops `IP', `CS' and the flags as 2 bytes each, taking 6
bytes off the stack in total. `IRETD' pops `EIP' as 4 bytes, pops a
further 4 bytes of which the top two are discarded and the bottom two
go into `CS', and pops the flags as 4 bytes as well, taking 12 bytes
off the stack.

   `IRET' is a shorthand for either `IRETW' or `IRETD', depending on
the default `BITS' setting at the time.


File: nasm.info,  Node: Section B.4.128,  Next: Section B.4.129,  Prev: Section B.4.127,  Up: Section B.4

B.4.128. `Jcc': Conditional Branch
----------------------------------

     Jcc imm                       ; 70+cc rb             [8086]
     Jcc NEAR imm                  ; 0F 80+cc rw/rd       [386]

   The conditional jump instructions execute a near (same segment) jump
if and only if their conditions are satisfied. For example, `JNZ' jumps
only if the zero flag is not set.

   The ordinary form of the instructions has only a 128-byte range; the
`NEAR' form is a 386 extension to the instruction set, and can span the
full size of a segment. NASM will not override your choice of jump
instruction: if you want `Jcc NEAR', you have to use the `NEAR' keyword.

   The `SHORT' keyword is allowed on the first form of the instruction,
for clarity, but is not necessary.

   For details of the condition codes, see *Note Section B.2.2::.


File: nasm.info,  Node: Section B.4.129,  Next: Section B.4.130,  Prev: Section B.4.128,  Up: Section B.4

B.4.129. `JCXZ', `JECXZ': Jump if CX/ECX Zero
---------------------------------------------

     JCXZ imm                      ; a16 E3 rb            [8086]
     JECXZ imm                     ; a32 E3 rb            [386]

   `JCXZ' performs a short jump (with maximum range 128 bytes) if and
only if the contents of the `CX' register is 0. `JECXZ' does the same
thing, but with `ECX'.


File: nasm.info,  Node: Section B.4.130,  Next: Section B.4.131,  Prev: Section B.4.129,  Up: Section B.4

B.4.130. `JMP': Jump
--------------------

     JMP imm                       ; E9 rw/rd             [8086]
     JMP SHORT imm                 ; EB rb                [8086]
     JMP imm:imm16                 ; o16 EA iw iw         [8086]
     JMP imm:imm32                 ; o32 EA id iw         [386]
     JMP FAR mem                   ; o16 FF /5            [8086]
     JMP FAR mem32                 ; o32 FF /5            [386]
     JMP r/m16                     ; o16 FF /4            [8086]
     JMP r/m32                     ; o32 FF /4            [386]

   `JMP' jumps to a given address. The address may be specified as an
absolute segment and offset, or as a relative jump within the current
segment.

   `JMP SHORT imm' has a maximum range of 128 bytes, since the
displacement is specified as only 8 bits, but takes up less code space.
NASM does not choose when to generate `JMP SHORT' for you: you must
explicitly code `SHORT' every time you want a short jump.

   You can choose between the two immediate far jump forms (`JMP
imm:imm') by the use of the `WORD' and `DWORD' keywords: `JMP WORD
0x1234:0x5678') or `JMP DWORD 0x1234:0x56789abc'.

   The `JMP FAR mem' forms execute a far jump by loading the destination
address out of memory. The address loaded consists of 16 or 32 bits of
offset (depending on the operand size), and 16 bits of segment. The
operand size may be overridden using `JMP WORD FAR mem' or `JMP DWORD
FAR mem'.

   The `JMP r/m' forms execute a near jump (within the same segment),
loading the destination address out of memory or out of a register. The
keyword `NEAR' may be specified, for clarity, in these forms, but is
not necessary. Again, operand size can be overridden using `JMP WORD
mem' or `JMP DWORD mem'.

   As a convenience, NASM does not require you to jump to a far symbol
by coding the cumbersome `JMP SEG routine:routine', but instead allows
the easier synonym `JMP FAR routine'.

   The `CALL r/m' forms given above are near calls; NASM will accept the
`NEAR' keyword (e.g. `CALL NEAR [address]'), even though it is not
strictly necessary.


File: nasm.info,  Node: Section B.4.131,  Next: Section B.4.132,  Prev: Section B.4.130,  Up: Section B.4

B.4.131. `LAHF': Load AH from Flags
-----------------------------------

     LAHF                          ; 9F                   [8086]

   `LAHF' sets the `AH' register according to the contents of the low
byte of the flags word.

   The operation of `LAHF' is:

      AH <-- SF:ZF:0:AF:0:PF:1:CF

   See also `SAHF' (*Note Section B.4.282::).


File: nasm.info,  Node: Section B.4.132,  Next: Section B.4.133,  Prev: Section B.4.131,  Up: Section B.4

B.4.132. `LAR': Load Access Rights
----------------------------------

     LAR reg16,r/m16               ; o16 0F 02 /r         [286,PRIV]
     LAR reg32,r/m32               ; o32 0F 02 /r         [286,PRIV]

   `LAR' takes the segment selector specified by its source (second)
operand, finds the corresponding segment descriptor in the GDT or LDT,
and loads the access-rights byte of the descriptor into its destination
(first) operand.


File: nasm.info,  Node: Section B.4.133,  Next: Section B.4.134,  Prev: Section B.4.132,  Up: Section B.4

B.4.133. `LDMXCSR': Load Streaming SIMD Extension Control/Status
----------------------------------------------------------------

     LDMXCSR mem32                 ; 0F AE /2        [KATMAI,SSE]

   `LDMXCSR' loads 32-bits of data from the specified memory location
into the `MXCSR' control/status register. `MXCSR' is used to enable
masked/unmasked exception handling, to set rounding modes, to set
flush-to-zero mode, and to view exception status flags.

   For details of the `MXCSR' register, see the Intel processor docs.

   See also `STMXCSR' (*Note Section B.4.302::


File: nasm.info,  Node: Section B.4.134,  Next: Section B.4.135,  Prev: Section B.4.133,  Up: Section B.4

B.4.134. `LDS', `LES', `LFS', `LGS', `LSS': Load Far Pointer
------------------------------------------------------------

     LDS reg16,mem                 ; o16 C5 /r            [8086]
     LDS reg32,mem                 ; o32 C5 /r            [386]

     LES reg16,mem                 ; o16 C4 /r            [8086]
     LES reg32,mem                 ; o32 C4 /r            [386]

     LFS reg16,mem                 ; o16 0F B4 /r         [386]
     LFS reg32,mem                 ; o32 0F B4 /r         [386]

     LGS reg16,mem                 ; o16 0F B5 /r         [386]
     LGS reg32,mem                 ; o32 0F B5 /r         [386]

     LSS reg16,mem                 ; o16 0F B2 /r         [386]
     LSS reg32,mem                 ; o32 0F B2 /r         [386]

   These instructions load an entire far pointer (16 or 32 bits of
offset, plus 16 bits of segment) out of memory in one go. `LDS', for
example, loads 16 or 32 bits from the given memory address into the
given register (depending on the size of the register), then loads the
_next_ 16 bits from memory into `DS'. `LES', `LFS', `LGS' and `LSS'
work in the same way but use the other segment registers.


File: nasm.info,  Node: Section B.4.135,  Next: Section B.4.136,  Prev: Section B.4.134,  Up: Section B.4

B.4.135. `LEA': Load Effective Address
--------------------------------------

     LEA reg16,mem                 ; o16 8D /r            [8086]
     LEA reg32,mem                 ; o32 8D /r            [386]

   `LEA', despite its syntax, does not access memory. It calculates the
effective address specified by its second operand as if it were going to
load or store data from it, but instead it stores the calculated address
into the register specified by its first operand. This can be used to
perform quite complex calculations (e.g. `LEA EAX,[EBX+ECX*4+100]') in
one instruction.

   `LEA', despite being a purely arithmetic instruction which accesses
no memory, still requires square brackets around its second operand, as
if it were a memory reference.

   The size of the calculation is the current _address_ size, and the
size that the result is stored as is the current _operand_ size. If the
address and operand size are not the same, then if the addressing mode
was 32-bits, the low 16-bits are stored, and if the address was
16-bits, it is zero-extended to 32-bits before storing.


File: nasm.info,  Node: Section B.4.136,  Next: Section B.4.137,  Prev: Section B.4.135,  Up: Section B.4

B.4.136. `LEAVE': Destroy Stack Frame
-------------------------------------

     LEAVE                         ; C9                   [186]

   `LEAVE' destroys a stack frame of the form created by the `ENTER'
instruction (see *Note Section B.4.65::). It is functionally equivalent
to `MOV ESP,EBP' followed by `POP EBP' (or `MOV SP,BP' followed by `POP
BP' in 16-bit mode).


File: nasm.info,  Node: Section B.4.137,  Next: Section B.4.138,  Prev: Section B.4.136,  Up: Section B.4

B.4.137. `LFENCE': Load Fence
-----------------------------

     LFENCE                        ; 0F AE /5        [WILLAMETTE,SSE2]

   `LFENCE' performs a serialising operation on all loads from memory
that were issued before the `LFENCE' instruction. This guarantees that
all memory reads before the `LFENCE' instruction are visible before any
reads after the `LFENCE' instruction.

   `LFENCE' is ordered respective to other `LFENCE' instruction,
`MFENCE', any memory read and any other serialising instruction (such
as `CPUID').

   Weakly ordered memory types can be used to achieve higher processor
performance through such techniques as out-of-order issue and
speculative reads. The degree to which a consumer of data recognizes or
knows that the data is weakly ordered varies among applications and may
be unknown to the producer of this data. The `LFENCE' instruction
provides a performance-efficient way of ensuring load ordering between
routines that produce weakly-ordered results and routines that consume
that data.

   `LFENCE' uses the following ModRM encoding:

               Mod (7:6)        = 11B
               Reg/Opcode (5:3) = 101B
               R/M (2:0)        = 000B

   All other ModRM encodings are defined to be reserved, and use of
these encodings risks incompatibility with future processors.

   See also `SFENCE' (*Note Section B.4.288::) and `MFENCE' (*Note
Section B.4.151::).


File: nasm.info,  Node: Section B.4.138,  Next: Section B.4.139,  Prev: Section B.4.137,  Up: Section B.4

B.4.138. `LGDT', `LIDT', `LLDT': Load Descriptor Tables
-------------------------------------------------------

     LGDT mem                      ; 0F 01 /2             [286,PRIV]
     LIDT mem                      ; 0F 01 /3             [286,PRIV]
     LLDT r/m16                    ; 0F 00 /2             [286,PRIV]

   `LGDT' and `LIDT' both take a 6-byte memory area as an operand: they
load a 32-bit linear address and a 16-bit size limit from that area (in
the opposite order) into the `GDTR' (global descriptor table register)
or `IDTR' (interrupt descriptor table register). These are the only
instructions which directly use _linear_ addresses, rather than
segment/offset pairs.

   `LLDT' takes a segment selector as an operand. The processor looks up
that selector in the GDT and stores the limit and base address given
there into the `LDTR' (local descriptor table register).

   See also `SGDT', `SIDT' and `SLDT' (*Note Section B.4.289::).


File: nasm.info,  Node: Section B.4.139,  Next: Section B.4.140,  Prev: Section B.4.138,  Up: Section B.4

B.4.139. `LMSW': Load/Store Machine Status Word
-----------------------------------------------

     LMSW r/m16                    ; 0F 01 /6             [286,PRIV]

   `LMSW' loads the bottom four bits of the source operand into the
bottom four bits of the `CR0' control register (or the Machine Status
Word, on 286 processors). See also `SMSW' (*Note Section B.4.296::).


File: nasm.info,  Node: Section B.4.140,  Next: Section B.4.141,  Prev: Section B.4.139,  Up: Section B.4

B.4.140. `LOADALL', `LOADALL286': Load Processor State
------------------------------------------------------

     LOADALL                       ; 0F 07                [386,UNDOC]
     LOADALL286                    ; 0F 05                [286,UNDOC]

   This instruction, in its two different-opcode forms, is apparently
supported on most 286 processors, some 386 and possibly some 486. The
opcode differs between the 286 and the 386.

   The function of the instruction is to load all information relating
to the state of the processor out of a block of memory: on the 286,
this block is located implicitly at absolute address `0x800', and on
the 386 and 486 it is at `[ES:EDI]'.


File: nasm.info,  Node: Section B.4.141,  Next: Section B.4.142,  Prev: Section B.4.140,  Up: Section B.4

B.4.141. `LODSB', `LODSW', `LODSD': Load from String
----------------------------------------------------

     LODSB                         ; AC                   [8086]
     LODSW                         ; o16 AD               [8086]
     LODSD                         ; o32 AD               [386]

   `LODSB' loads a byte from `[DS:SI]' or `[DS:ESI]' into `AL'. It then
increments or decrements (depending on the direction flag: increments
if the flag is clear, decrements if it is set) `SI' or `ESI'.

   The register used is `SI' if the address size is 16 bits, and `ESI'
if it is 32 bits. If you need to use an address size not equal to the
current `BITS' setting, you can use an explicit `a16' or `a32' prefix.

   The segment register used to load from `[SI]' or `[ESI]' can be
overridden by using a segment register name as a prefix (for example,
`ES LODSB').

   `LODSW' and `LODSD' work in the same way, but they load a word or a
doubleword instead of a byte, and increment or decrement the addressing
registers by 2 or 4 instead of 1.


File: nasm.info,  Node: Section B.4.142,  Next: Section B.4.143,  Prev: Section B.4.141,  Up: Section B.4

B.4.142. `LOOP', `LOOPE', `LOOPZ', `LOOPNE', `LOOPNZ': Loop with Counter
------------------------------------------------------------------------

     LOOP imm                      ; E2 rb                [8086]
     LOOP imm,CX                   ; a16 E2 rb            [8086]
     LOOP imm,ECX                  ; a32 E2 rb            [386]

     LOOPE imm                     ; E1 rb                [8086]
     LOOPE imm,CX                  ; a16 E1 rb            [8086]
     LOOPE imm,ECX                 ; a32 E1 rb            [386]
     LOOPZ imm                     ; E1 rb                [8086]
     LOOPZ imm,CX                  ; a16 E1 rb            [8086]
     LOOPZ imm,ECX                 ; a32 E1 rb            [386]

     LOOPNE imm                    ; E0 rb                [8086]
     LOOPNE imm,CX                 ; a16 E0 rb            [8086]
     LOOPNE imm,ECX                ; a32 E0 rb            [386]
     LOOPNZ imm                    ; E0 rb                [8086]
     LOOPNZ imm,CX                 ; a16 E0 rb            [8086]
     LOOPNZ imm,ECX                ; a32 E0 rb            [386]

   `LOOP' decrements its counter register (either `CX' or `ECX' - if
one is not specified explicitly, the `BITS' setting dictates which is
used) by one, and if the counter does not become zero as a result of
this operation, it jumps to the given label. The jump has a range of 128
bytes.

   `LOOPE' (or its synonym `LOOPZ') adds the additional condition that
it only jumps if the counter is nonzero _and_ the zero flag is set.
Similarly, `LOOPNE' (and `LOOPNZ') jumps only if the counter is nonzero
and the zero flag is clear.


File: nasm.info,  Node: Section B.4.143,  Next: Section B.4.144,  Prev: Section B.4.142,  Up: Section B.4

B.4.143. `LSL': Load Segment Limit
----------------------------------

     LSL reg16,r/m16               ; o16 0F 03 /r         [286,PRIV]
     LSL reg32,r/m32               ; o32 0F 03 /r         [286,PRIV]

   `LSL' is given a segment selector in its source (second) operand; it
computes the segment limit value by loading the segment limit field from
the associated segment descriptor in the `GDT' or `LDT'. (This involves
shifting left by 12 bits if the segment limit is page-granular, and not
if it is byte-granular; so you end up with a byte limit in either
case.) The segment limit obtained is then loaded into the destination
(first) operand.


File: nasm.info,  Node: Section B.4.144,  Next: Section B.4.145,  Prev: Section B.4.143,  Up: Section B.4

B.4.144. `LTR': Load Task Register
----------------------------------

     LTR r/m16                     ; 0F 00 /3             [286,PRIV]

   `LTR' looks up the segment base and limit in the GDT or LDT
descriptor specified by the segment selector given as its operand, and
loads them into the Task Register.


File: nasm.info,  Node: Section B.4.145,  Next: Section B.4.146,  Prev: Section B.4.144,  Up: Section B.4

B.4.145. `MASKMOVDQU': Byte Mask Write
--------------------------------------

     MASKMOVDQU xmm1,xmm2          ; 66 0F F7 /r     [WILLAMETTE,SSE2]

   `MASKMOVDQU' stores data from xmm1 to the location specified by
`ES:(E)DI'. The size of the store depends on the address-size
attribute. The most significant bit in each byte of the mask register
xmm2 is used to selectively write the data (0 = no write, 1 = write) on
a per- byte basis.


File: nasm.info,  Node: Section B.4.146,  Next: Section B.4.147,  Prev: Section B.4.145,  Up: Section B.4

B.4.146. `MASKMOVQ': Byte Mask Write
------------------------------------

     MASKMOVQ mm1,mm2              ; 0F F7 /r        [KATMAI,MMX]

   `MASKMOVQ' stores data from mm1 to the location specified by
`ES:(E)DI'. The size of the store depends on the address-size
attribute. The most significant bit in each byte of the mask register
mm2 is used to selectively write the data (0 = no write, 1 = write) on
a per- byte basis.


File: nasm.info,  Node: Section B.4.147,  Next: Section B.4.148,  Prev: Section B.4.146,  Up: Section B.4

B.4.147. `MAXPD': Return Packed Double-Precision FP Maximum
-----------------------------------------------------------

     MAXPD xmm1,xmm2/m128          ; 66 0F 5F /r     [WILLAMETTE,SSE2]

   `MAXPD' performs a SIMD compare of the packed double-precision FP
numbers from xmm1 and xmm2/mem, and stores the maximum values of each
pair of values in xmm1. If the values being compared are both zeroes,
source2 (xmm2/m128) would be returned. If source2 (xmm2/m128) is an
SNaN, this SNaN is forwarded unchanged to the destination (i.e., a QNaN
version of the SNaN is not returned).


File: nasm.info,  Node: Section B.4.148,  Next: Section B.4.149,  Prev: Section B.4.147,  Up: Section B.4

B.4.148. `MAXPS': Return Packed Single-Precision FP Maximum
-----------------------------------------------------------

     MAXPS xmm1,xmm2/m128          ; 0F 5F /r        [KATMAI,SSE]

   `MAXPS' performs a SIMD compare of the packed single-precision FP
numbers from xmm1 and xmm2/mem, and stores the maximum values of each
pair of values in xmm1. If the values being compared are both zeroes,
source2 (xmm2/m128) would be returned. If source2 (xmm2/m128) is an
SNaN, this SNaN is forwarded unchanged to the destination (i.e., a QNaN
version of the SNaN is not returned).


File: nasm.info,  Node: Section B.4.149,  Next: Section B.4.150,  Prev: Section B.4.148,  Up: Section B.4

B.4.149. `MAXSD': Return Scalar Double-Precision FP Maximum
-----------------------------------------------------------

     MAXSD xmm1,xmm2/m64           ; F2 0F 5F /r     [WILLAMETTE,SSE2]

   `MAXSD' compares the low-order double-precision FP numbers from xmm1
and xmm2/mem, and stores the maximum value in xmm1. If the values being
compared are both zeroes, source2 (xmm2/m64) would be returned. If
source2 (xmm2/m64) is an SNaN, this SNaN is forwarded unchanged to the
destination (i.e., a QNaN version of the SNaN is not returned). The
high quadword of the destination is left unchanged.


File: nasm.info,  Node: Section B.4.150,  Next: Section B.4.151,  Prev: Section B.4.149,  Up: Section B.4

B.4.150. `MAXSS': Return Scalar Single-Precision FP Maximum
-----------------------------------------------------------

     MAXSS xmm1,xmm2/m32           ; F3 0F 5F /r     [KATMAI,SSE]

   `MAXSS' compares the low-order single-precision FP numbers from xmm1
and xmm2/mem, and stores the maximum value in xmm1. If the values being
compared are both zeroes, source2 (xmm2/m32) would be returned. If
source2 (xmm2/m32) is an SNaN, this SNaN is forwarded unchanged to the
destination (i.e., a QNaN version of the SNaN is not returned). The
high three doublewords of the destination are left unchanged.


File: nasm.info,  Node: Section B.4.151,  Next: Section B.4.152,  Prev: Section B.4.150,  Up: Section B.4

B.4.151. `MFENCE': Memory Fence
-------------------------------

     MFENCE                        ; 0F AE /6        [WILLAMETTE,SSE2]

   `MFENCE' performs a serialising operation on all loads from memory
and writes to memory that were issued before the `MFENCE' instruction.
This guarantees that all memory reads and writes before the `MFENCE'
instruction are completed before any reads and writes after the
`MFENCE' instruction.

   `MFENCE' is ordered respective to other `MFENCE' instructions,
`LFENCE', `SFENCE', any memory read and any other serialising
instruction (such as `CPUID').

   Weakly ordered memory types can be used to achieve higher processor
performance through such techniques as out-of-order issue, speculative
reads, write-combining, and write-collapsing. The degree to which a
consumer of data recognizes or knows that the data is weakly ordered
varies among applications and may be unknown to the producer of this
data. The `MFENCE' instruction provides a performance-efficient way of
ensuring load and store ordering between routines that produce
weakly-ordered results and routines that consume that data.

   `MFENCE' uses the following ModRM encoding:

               Mod (7:6)        = 11B
               Reg/Opcode (5:3) = 110B
               R/M (2:0)        = 000B

   All other ModRM encodings are defined to be reserved, and use of
these encodings risks incompatibility with future processors.

   See also `LFENCE' (*Note Section B.4.137::) and `SFENCE' (*Note
Section B.4.288::).


File: nasm.info,  Node: Section B.4.152,  Next: Section B.4.153,  Prev: Section B.4.151,  Up: Section B.4

B.4.152. `MINPD': Return Packed Double-Precision FP Minimum
-----------------------------------------------------------

     MINPD xmm1,xmm2/m128          ; 66 0F 5D /r     [WILLAMETTE,SSE2]

   `MINPD' performs a SIMD compare of the packed double-precision FP
numbers from xmm1 and xmm2/mem, and stores the minimum values of each
pair of values in xmm1. If the values being compared are both zeroes,
source2 (xmm2/m128) would be returned. If source2 (xmm2/m128) is an
SNaN, this SNaN is forwarded unchanged to the destination (i.e., a QNaN
version of the SNaN is not returned).


File: nasm.info,  Node: Section B.4.153,  Next: Section B.4.154,  Prev: Section B.4.152,  Up: Section B.4

B.4.153. `MINPS': Return Packed Single-Precision FP Minimum
-----------------------------------------------------------

     MINPS xmm1,xmm2/m128          ; 0F 5D /r        [KATMAI,SSE]

   `MINPS' performs a SIMD compare of the packed single-precision FP
numbers from xmm1 and xmm2/mem, and stores the minimum values of each
pair of values in xmm1. If the values being compared are both zeroes,
source2 (xmm2/m128) would be returned. If source2 (xmm2/m128) is an
SNaN, this SNaN is forwarded unchanged to the destination (i.e., a QNaN
version of the SNaN is not returned).


File: nasm.info,  Node: Section B.4.154,  Next: Section B.4.155,  Prev: Section B.4.153,  Up: Section B.4

B.4.154. `MINSD': Return Scalar Double-Precision FP Minimum
-----------------------------------------------------------

     MINSD xmm1,xmm2/m64           ; F2 0F 5D /r     [WILLAMETTE,SSE2]

   `MINSD' compares the low-order double-precision FP numbers from xmm1
and xmm2/mem, and stores the minimum value in xmm1. If the values being
compared are both zeroes, source2 (xmm2/m64) would be returned. If
source2 (xmm2/m64) is an SNaN, this SNaN is forwarded unchanged to the
destination (i.e., a QNaN version of the SNaN is not returned). The
high quadword of the destination is left unchanged.


File: nasm.info,  Node: Section B.4.155,  Next: Section B.4.156,  Prev: Section B.4.154,  Up: Section B.4

B.4.155. `MINSS': Return Scalar Single-Precision FP Minimum
-----------------------------------------------------------

     MINSS xmm1,xmm2/m32           ; F3 0F 5D /r     [KATMAI,SSE]

   `MINSS' compares the low-order single-precision FP numbers from xmm1
and xmm2/mem, and stores the minimum value in xmm1. If the values being
compared are both zeroes, source2 (xmm2/m32) would be returned. If
source2 (xmm2/m32) is an SNaN, this SNaN is forwarded unchanged to the
destination (i.e., a QNaN version of the SNaN is not returned). The
high three doublewords of the destination are left unchanged.


File: nasm.info,  Node: Section B.4.156,  Next: Section B.4.157,  Prev: Section B.4.155,  Up: Section B.4

B.4.156. `MOV': Move Data
-------------------------

     MOV r/m8,reg8                 ; 88 /r                [8086]
     MOV r/m16,reg16               ; o16 89 /r            [8086]
     MOV r/m32,reg32               ; o32 89 /r            [386]
     MOV reg8,r/m8                 ; 8A /r                [8086]
     MOV reg16,r/m16               ; o16 8B /r            [8086]
     MOV reg32,r/m32               ; o32 8B /r            [386]

     MOV reg8,imm8                 ; B0+r ib              [8086]
     MOV reg16,imm16               ; o16 B8+r iw          [8086]
     MOV reg32,imm32               ; o32 B8+r id          [386]
     MOV r/m8,imm8                 ; C6 /0 ib             [8086]
     MOV r/m16,imm16               ; o16 C7 /0 iw         [8086]
     MOV r/m32,imm32               ; o32 C7 /0 id         [386]

     MOV AL,memoffs8               ; A0 ow/od             [8086]
     MOV AX,memoffs16              ; o16 A1 ow/od         [8086]
     MOV EAX,memoffs32             ; o32 A1 ow/od         [386]
     MOV memoffs8,AL               ; A2 ow/od             [8086]
     MOV memoffs16,AX              ; o16 A3 ow/od         [8086]
     MOV memoffs32,EAX             ; o32 A3 ow/od         [386]

     MOV r/m16,segreg              ; o16 8C /r            [8086]
     MOV r/m32,segreg              ; o32 8C /r            [386]
     MOV segreg,r/m16              ; o16 8E /r            [8086]
     MOV segreg,r/m32              ; o32 8E /r            [386]

     MOV reg32,CR0/2/3/4           ; 0F 20 /r             [386]
     MOV reg32,DR0/1/2/3/6/7       ; 0F 21 /r             [386]
     MOV reg32,TR3/4/5/6/7         ; 0F 24 /r             [386]
     MOV CR0/2/3/4,reg32           ; 0F 22 /r             [386]
     MOV DR0/1/2/3/6/7,reg32       ; 0F 23 /r             [386]
     MOV TR3/4/5/6/7,reg32         ; 0F 26 /r             [386]

   `MOV' copies the contents of its source (second) operand into its
destination (first) operand.

   In all forms of the `MOV' instruction, the two operands are the same
size, except for moving between a segment register and an `r/m32'
operand. These instructions are treated exactly like the corresponding
16- bit equivalent (so that, for example, `MOV DS,EAX' functions
identically to `MOV DS,AX' but saves a prefix when in 32-bit mode),
except that when a segment register is moved into a 32-bit destination,
the top two bytes of the result are undefined.

   `MOV' may not use `CS' as a destination.

   `CR4' is only a supported register on the Pentium and above.

   Test registers are supported on 386/486 processors and on some
non-Intel Pentium class processors.


File: nasm.info,  Node: Section B.4.157,  Next: Section B.4.158,  Prev: Section B.4.156,  Up: Section B.4

B.4.157. `MOVAPD': Move Aligned Packed Double-Precision FP Values
-----------------------------------------------------------------

     MOVAPD xmm1,xmm2/mem128       ; 66 0F 28 /r     [WILLAMETTE,SSE2]
     MOVAPD xmm1/mem128,xmm2       ; 66 0F 29 /r     [WILLAMETTE,SSE2]

   `MOVAPD' moves a double quadword containing 2 packed double-precision
FP values from the source operand to the destination. When the source or
destination operand is a memory location, it must be aligned on a
16-byte boundary.

   To move data in and out of memory locations that are not known to be
on 16- byte boundaries, use the `MOVUPD' instruction (*Note Section
B.4.182::).


File: nasm.info,  Node: Section B.4.158,  Next: Section B.4.159,  Prev: Section B.4.157,  Up: Section B.4

B.4.158. `MOVAPS': Move Aligned Packed Single-Precision FP Values
-----------------------------------------------------------------

     MOVAPS xmm1,xmm2/mem128       ; 0F 28 /r        [KATMAI,SSE]
     MOVAPS xmm1/mem128,xmm2       ; 0F 29 /r        [KATMAI,SSE]

   `MOVAPS' moves a double quadword containing 4 packed single-precision
FP values from the source operand to the destination. When the source or
destination operand is a memory location, it must be aligned on a
16-byte boundary.

   To move data in and out of memory locations that are not known to be
on 16- byte boundaries, use the `MOVUPS' instruction (*Note Section
B.4.183::).


File: nasm.info,  Node: Section B.4.159,  Next: Section B.4.160,  Prev: Section B.4.158,  Up: Section B.4

B.4.159. `MOVD': Move Doubleword to/from MMX Register
-----------------------------------------------------

     MOVD mm,r/m32                 ; 0F 6E /r             [PENT,MMX]
     MOVD r/m32,mm                 ; 0F 7E /r             [PENT,MMX]
     MOVD xmm,r/m32                ; 66 0F 6E /r     [WILLAMETTE,SSE2]
     MOVD r/m32,xmm                ; 66 0F 7E /r     [WILLAMETTE,SSE2]

   `MOVD' copies 32 bits from its source (second) operand into its
destination (first) operand. When the destination is a 64-bit `MMX'
register or a 128-bit `XMM' register, the input value is zero-extended
to fill the destination register.


File: nasm.info,  Node: Section B.4.160,  Next: Section B.4.161,  Prev: Section B.4.159,  Up: Section B.4

B.4.160. `MOVDQ2Q': Move Quadword from XMM to MMX register.
-----------------------------------------------------------

     MOVDQ2Q mm,xmm                ; F2 OF D6 /r     [WILLAMETTE,SSE2]

   `MOVDQ2Q' moves the low quadword from the source operand to the
destination operand.


File: nasm.info,  Node: Section B.4.161,  Next: Section B.4.162,  Prev: Section B.4.160,  Up: Section B.4

B.4.161. `MOVDQA': Move Aligned Double Quadword
-----------------------------------------------

     MOVDQA xmm1,xmm2/m128         ; 66 OF 6F /r     [WILLAMETTE,SSE2]
     MOVDQA xmm1/m128,xmm2         ; 66 OF 7F /r     [WILLAMETTE,SSE2]

   `MOVDQA' moves a double quadword from the source operand to the
destination operand. When the source or destination operand is a memory
location, it must be aligned to a 16-byte boundary.

   To move a double quadword to or from unaligned memory locations, use
the `MOVDQU' instruction (*Note Section B.4.162::).


File: nasm.info,  Node: Section B.4.162,  Next: Section B.4.163,  Prev: Section B.4.161,  Up: Section B.4

B.4.162. `MOVDQU': Move Unaligned Double Quadword
-------------------------------------------------

     MOVDQU xmm1,xmm2/m128         ; F3 OF 6F /r     [WILLAMETTE,SSE2]
     MOVDQU xmm1/m128,xmm2         ; F3 OF 7F /r     [WILLAMETTE,SSE2]

   `MOVDQU' moves a double quadword from the source operand to the
destination operand. When the source or destination operand is a memory
location, the memory may be unaligned.

   To move a double quadword to or from known aligned memory locations,
use the `MOVDQA' instruction (*Note Section B.4.161::).


File: nasm.info,  Node: Section B.4.163,  Next: Section B.4.164,  Prev: Section B.4.162,  Up: Section B.4

B.4.163. `MOVHLPS': Move Packed Single-Precision FP High to Low
---------------------------------------------------------------

     MOVHLPS xmm1,xmm2             ; OF 12 /r        [KATMAI,SSE]

   `MOVHLPS' moves the two packed single-precision FP values from the
high quadword of the source register xmm2 to the low quadword of the
destination register, xmm2. The upper quadword of xmm1 is left
unchanged.

   The operation of this instruction is:

        dst[0-63]   := src[64-127],
        dst[64-127] remains unchanged.


File: nasm.info,  Node: Section B.4.164,  Next: Section B.4.165,  Prev: Section B.4.163,  Up: Section B.4

B.4.164. `MOVHPD': Move High Packed Double-Precision FP
-------------------------------------------------------

     MOVHPD xmm,m64               ; 66 OF 16 /r      [WILLAMETTE,SSE2]
     MOVHPD m64,xmm               ; 66 OF 17 /r      [WILLAMETTE,SSE2]

   `MOVHPD' moves a double-precision FP value between the source and
destination operands. One of the operands is a 64-bit memory location,
the other is the high quadword of an `XMM' register.

   The operation of this instruction is:

        mem[0-63]   := xmm[64-127];

   or

        xmm[0-63]   remains unchanged;
        xmm[64-127] := mem[0-63].


File: nasm.info,  Node: Section B.4.165,  Next: Section B.4.166,  Prev: Section B.4.164,  Up: Section B.4

B.4.165. `MOVHPS': Move High Packed Single-Precision FP
-------------------------------------------------------

     MOVHPS xmm,m64               ; 0F 16 /r         [KATMAI,SSE]
     MOVHPS m64,xmm               ; 0F 17 /r         [KATMAI,SSE]

   `MOVHPS' moves two packed single-precision FP values between the
source and destination operands. One of the operands is a 64-bit memory
location, the other is the high quadword of an `XMM' register.

   The operation of this instruction is:

        mem[0-63]   := xmm[64-127];

   or

        xmm[0-63]   remains unchanged;
        xmm[64-127] := mem[0-63].


File: nasm.info,  Node: Section B.4.166,  Next: Section B.4.167,  Prev: Section B.4.165,  Up: Section B.4

B.4.166. `MOVLHPS': Move Packed Single-Precision FP Low to High
---------------------------------------------------------------

     MOVLHPS xmm1,xmm2             ; OF 16 /r         [KATMAI,SSE]

   `MOVLHPS' moves the two packed single-precision FP values from the
low quadword of the source register xmm2 to the high quadword of the
destination register, xmm2. The low quadword of xmm1 is left unchanged.

   The operation of this instruction is:

        dst[0-63]   remains unchanged;
        dst[64-127] := src[0-63].


File: nasm.info,  Node: Section B.4.167,  Next: Section B.4.168,  Prev: Section B.4.166,  Up: Section B.4

B.4.167. `MOVLPD': Move Low Packed Double-Precision FP
------------------------------------------------------

     MOVLPD xmm,m64                ; 66 OF 12 /r     [WILLAMETTE,SSE2]
     MOVLPD m64,xmm                ; 66 OF 13 /r     [WILLAMETTE,SSE2]

   `MOVLPD' moves a double-precision FP value between the source and
destination operands. One of the operands is a 64-bit memory location,
the other is the low quadword of an `XMM' register.

   The operation of this instruction is:

        mem(0-63)   := xmm(0-63);

   or

        xmm(0-63)   := mem(0-63);
        xmm(64-127) remains unchanged.


File: nasm.info,  Node: Section B.4.168,  Next: Section B.4.169,  Prev: Section B.4.167,  Up: Section B.4

B.4.168. `MOVLPS': Move Low Packed Single-Precision FP
------------------------------------------------------

     MOVLPS xmm,m64                ; OF 12 /r        [KATMAI,SSE]
     MOVLPS m64,xmm                ; OF 13 /r        [KATMAI,SSE]

   `MOVLPS' moves two packed single-precision FP values between the
source and destination operands. One of the operands is a 64-bit memory
location, the other is the low quadword of an `XMM' register.

   The operation of this instruction is:

        mem(0-63)   := xmm(0-63);

   or

        xmm(0-63)   := mem(0-63);
        xmm(64-127) remains unchanged.


File: nasm.info,  Node: Section B.4.169,  Next: Section B.4.170,  Prev: Section B.4.168,  Up: Section B.4

B.4.169. `MOVMSKPD': Extract Packed Double-Precision FP Sign Mask
-----------------------------------------------------------------

     MOVMSKPD reg32,xmm              ; 66 0F 50 /r   [WILLAMETTE,SSE2]

   `MOVMSKPD' inserts a 2-bit mask in r32, formed of the most
significant bits of each double-precision FP number of the source
operand.


File: nasm.info,  Node: Section B.4.170,  Next: Section B.4.171,  Prev: Section B.4.169,  Up: Section B.4

B.4.170. `MOVMSKPS': Extract Packed Single-Precision FP Sign Mask
-----------------------------------------------------------------

     MOVMSKPS reg32,xmm              ; 0F 50 /r      [KATMAI,SSE]

   `MOVMSKPS' inserts a 4-bit mask in r32, formed of the most
significant bits of each single-precision FP number of the source
operand.


File: nasm.info,  Node: Section B.4.171,  Next: Section B.4.172,  Prev: Section B.4.170,  Up: Section B.4

B.4.171. `MOVNTDQ': Move Double Quadword Non Temporal
-----------------------------------------------------

     MOVNTDQ m128,xmm              ; 66 0F E7 /r     [WILLAMETTE,SSE2]

   `MOVNTDQ' moves the double quadword from the `XMM' source register
to the destination memory location, using a non-temporal hint.  This
store instruction minimizes cache pollution.


File: nasm.info,  Node: Section B.4.172,  Next: Section B.4.173,  Prev: Section B.4.171,  Up: Section B.4

B.4.172. `MOVNTI': Move Doubleword Non Temporal
-----------------------------------------------

     MOVNTI m32,reg32              ; 0F C3 /r        [WILLAMETTE,SSE2]

   `MOVNTI' moves the doubleword in the source register to the
destination memory location, using a non-temporal hint. This store
instruction minimizes cache pollution.


File: nasm.info,  Node: Section B.4.173,  Next: Section B.4.174,  Prev: Section B.4.172,  Up: Section B.4

B.4.173. `MOVNTPD': Move Aligned Four Packed Single-Precision FP Values Non Temporal
------------------------------------------------------------------------------------

     MOVNTPD m128,xmm              ; 66 0F 2B /r     [WILLAMETTE,SSE2]

   `MOVNTPD' moves the double quadword from the `XMM' source register
to the destination memory location, using a non-temporal hint.  This
store instruction minimizes cache pollution. The memory location must
be aligned to a 16-byte boundary.


File: nasm.info,  Node: Section B.4.174,  Next: Section B.4.175,  Prev: Section B.4.173,  Up: Section B.4

B.4.174. `MOVNTPS': Move Aligned Four Packed Single-Precision FP Values Non Temporal
------------------------------------------------------------------------------------

     MOVNTPS m128,xmm              ; 0F 2B /r        [KATMAI,SSE]

   `MOVNTPS' moves the double quadword from the `XMM' source register
to the destination memory location, using a non-temporal hint.  This
store instruction minimizes cache pollution. The memory location must
be aligned to a 16-byte boundary.


File: nasm.info,  Node: Section B.4.175,  Next: Section B.4.176,  Prev: Section B.4.174,  Up: Section B.4

B.4.175. `MOVNTQ': Move Quadword Non Temporal
---------------------------------------------

     MOVNTQ m64,mm                 ; 0F E7 /r        [KATMAI,MMX]

   `MOVNTQ' moves the quadword in the `MMX' source register to the
destination memory location, using a non-temporal hint. This store
instruction minimizes cache pollution.


File: nasm.info,  Node: Section B.4.176,  Next: Section B.4.177,  Prev: Section B.4.175,  Up: Section B.4

B.4.176. `MOVQ': Move Quadword to/from MMX Register
---------------------------------------------------

     MOVQ mm1,mm2/m64               ; 0F 6F /r             [PENT,MMX]
     MOVQ mm1/m64,mm2               ; 0F 7F /r             [PENT,MMX]

     MOVQ xmm1,xmm2/m64             ; F3 0F 7E /r    [WILLAMETTE,SSE2]
     MOVQ xmm1/m64,xmm2             ; 66 0F D6 /r    [WILLAMETTE,SSE2]

   `MOVQ' copies 64 bits from its source (second) operand into its
destination (first) operand. When the source is an `XMM' register, the
low quadword is moved. When the destination is an `XMM' register, the
destination is the low quadword, and the high quadword is cleared.


File: nasm.info,  Node: Section B.4.177,  Next: Section B.4.178,  Prev: Section B.4.176,  Up: Section B.4

B.4.177. `MOVQ2DQ': Move Quadword from MMX to XMM register.
-----------------------------------------------------------

     MOVQ2DQ xmm,mm                ; F3 OF D6 /r     [WILLAMETTE,SSE2]

   `MOVQ2DQ' moves the quadword from the source operand to the low
quadword of the destination operand, and clears the high quadword.


File: nasm.info,  Node: Section B.4.178,  Next: Section B.4.179,  Prev: Section B.4.177,  Up: Section B.4

B.4.178. `MOVSB', `MOVSW', `MOVSD': Move String
-----------------------------------------------

     MOVSB                         ; A4                   [8086]
     MOVSW                         ; o16 A5               [8086]
     MOVSD                         ; o32 A5               [386]

   `MOVSB' copies the byte at `[DS:SI]' or `[DS:ESI]' to `[ES:DI]' or
`[ES:EDI]'. It then increments or decrements (depending on the
direction flag: increments if the flag is clear, decrements if it is
set) `SI' and `DI' (or `ESI' and `EDI').

   The registers used are `SI' and `DI' if the address size is 16 bits,
and `ESI' and `EDI' if it is 32 bits. If you need to use an address
size not equal to the current `BITS' setting, you can use an explicit
`a16' or `a32' prefix.

   The segment register used to load from `[SI]' or `[ESI]' can be
overridden by using a segment register name as a prefix (for example,
`es movsb'). The use of `ES' for the store to `[DI]' or `[EDI]' cannot
be overridden.

   `MOVSW' and `MOVSD' work in the same way, but they copy a word or a
doubleword instead of a byte, and increment or decrement the addressing
registers by 2 or 4 instead of 1.

   The `REP' prefix may be used to repeat the instruction `CX' (or
`ECX' - again, the address size chooses which) times.


File: nasm.info,  Node: Section B.4.179,  Next: Section B.4.180,  Prev: Section B.4.178,  Up: Section B.4

B.4.179. `MOVSD': Move Scalar Double-Precision FP Value
-------------------------------------------------------

     MOVSD xmm1,xmm2/m64           ; F2 0F 10 /r     [WILLAMETTE,SSE2]
     MOVSD xmm1/m64,xmm2           ; F2 0F 11 /r     [WILLAMETTE,SSE2]

   `MOVSD' moves a double-precision FP value from the source operand to
the destination operand. When the source or destination is a register,
the low-order FP value is read or written.


File: nasm.info,  Node: Section B.4.180,  Next: Section B.4.181,  Prev: Section B.4.179,  Up: Section B.4

B.4.180. `MOVSS': Move Scalar Single-Precision FP Value
-------------------------------------------------------

     MOVSS xmm1,xmm2/m32           ; F3 0F 10 /r     [KATMAI,SSE]
     MOVSS xmm1/m32,xmm2           ; F3 0F 11 /r     [KATMAI,SSE]

   `MOVSS' moves a single-precision FP value from the source operand to
the destination operand. When the source or destination is a register,
the low-order FP value is read or written.


File: nasm.info,  Node: Section B.4.181,  Next: Section B.4.182,  Prev: Section B.4.180,  Up: Section B.4

B.4.181. `MOVSX', `MOVZX': Move Data with Sign or Zero Extend
-------------------------------------------------------------

     MOVSX reg16,r/m8              ; o16 0F BE /r         [386]
     MOVSX reg32,r/m8              ; o32 0F BE /r         [386]
     MOVSX reg32,r/m16             ; o32 0F BF /r         [386]

     MOVZX reg16,r/m8              ; o16 0F B6 /r         [386]
     MOVZX reg32,r/m8              ; o32 0F B6 /r         [386]
     MOVZX reg32,r/m16             ; o32 0F B7 /r         [386]

   `MOVSX' sign-extends its source (second) operand to the length of its
destination (first) operand, and copies the result into the destination
operand. `MOVZX' does the same, but zero-extends rather than sign-
extending.


File: nasm.info,  Node: Section B.4.182,  Next: Section B.4.183,  Prev: Section B.4.181,  Up: Section B.4

B.4.182. `MOVUPD': Move Unaligned Packed Double-Precision FP Values
-------------------------------------------------------------------

     MOVUPD xmm1,xmm2/mem128       ; 66 0F 10 /r     [WILLAMETTE,SSE2]
     MOVUPD xmm1/mem128,xmm2       ; 66 0F 11 /r     [WILLAMETTE,SSE2]

   `MOVUPD' moves a double quadword containing 2 packed double-precision
FP values from the source operand to the destination. This instruction
makes no assumptions about alignment of memory operands.

   To move data in and out of memory locations that are known to be on
16-byte boundaries, use the `MOVAPD' instruction (*Note Section
B.4.157::).


File: nasm.info,  Node: Section B.4.183,  Next: Section B.4.184,  Prev: Section B.4.182,  Up: Section B.4

B.4.183. `MOVUPS': Move Unaligned Packed Single-Precision FP Values
-------------------------------------------------------------------

     MOVUPS xmm1,xmm2/mem128       ; 0F 10 /r        [KATMAI,SSE]
     MOVUPS xmm1/mem128,xmm2       ; 0F 11 /r        [KATMAI,SSE]

   `MOVUPS' moves a double quadword containing 4 packed single-precision
FP values from the source operand to the destination. This instruction
makes no assumptions about alignment of memory operands.

   To move data in and out of memory locations that are known to be on
16-byte boundaries, use the `MOVAPS' instruction (*Note Section
B.4.158::).


File: nasm.info,  Node: Section B.4.184,  Next: Section B.4.185,  Prev: Section B.4.183,  Up: Section B.4

B.4.184. `MUL': Unsigned Integer Multiply
-----------------------------------------

     MUL r/m8                      ; F6 /4                [8086]
     MUL r/m16                     ; o16 F7 /4            [8086]
     MUL r/m32                     ; o32 F7 /4            [386]

   `MUL' performs unsigned integer multiplication. The other operand to
the multiplication, and the destination operand, are implicit, in the
following way:

   * For `MUL r/m8', `AL' is multiplied by the given operand; the
     product is stored in `AX'.

   * For `MUL r/m16', `AX' is multiplied by the given operand; the
     product is stored in `DX:AX'.

   * For `MUL r/m32', `EAX' is multiplied by the given operand; the
     product is stored in `EDX:EAX'.

   Signed integer multiplication is performed by the `IMUL' instruction:
see *Note Section B.4.118::.


File: nasm.info,  Node: Section B.4.185,  Next: Section B.4.186,  Prev: Section B.4.184,  Up: Section B.4

B.4.185. `MULPD': Packed Single-FP Multiply
-------------------------------------------

     MULPD xmm1,xmm2/mem128        ; 66 0F 59 /r     [WILLAMETTE,SSE2]

   `MULPD' performs a SIMD multiply of the packed double-precision FP
values in both operands, and stores the results in the destination
register.


File: nasm.info,  Node: Section B.4.186,  Next: Section B.4.187,  Prev: Section B.4.185,  Up: Section B.4

B.4.186. `MULPS': Packed Single-FP Multiply
-------------------------------------------

     MULPS xmm1,xmm2/mem128        ; 0F 59 /r        [KATMAI,SSE]

   `MULPS' performs a SIMD multiply of the packed single-precision FP
values in both operands, and stores the results in the destination
register.


File: nasm.info,  Node: Section B.4.187,  Next: Section B.4.188,  Prev: Section B.4.186,  Up: Section B.4

B.4.187. `MULSD': Scalar Single-FP Multiply
-------------------------------------------

     MULSD xmm1,xmm2/mem32         ; F2 0F 59 /r     [WILLAMETTE,SSE2]

   `MULSD' multiplies the lowest double-precision FP values of both
operands, and stores the result in the low quadword of xmm1.


File: nasm.info,  Node: Section B.4.188,  Next: Section B.4.189,  Prev: Section B.4.187,  Up: Section B.4

B.4.188. `MULSS': Scalar Single-FP Multiply
-------------------------------------------

     MULSS xmm1,xmm2/mem32         ; F3 0F 59 /r     [KATMAI,SSE]

   `MULSS' multiplies the lowest single-precision FP values of both
operands, and stores the result in the low doubleword of xmm1.


File: nasm.info,  Node: Section B.4.189,  Next: Section B.4.190,  Prev: Section B.4.188,  Up: Section B.4

B.4.189. `NEG', `NOT': Two's and One's Complement
-------------------------------------------------

     NEG r/m8                      ; F6 /3                [8086]
     NEG r/m16                     ; o16 F7 /3            [8086]
     NEG r/m32                     ; o32 F7 /3            [386]

     NOT r/m8                      ; F6 /2                [8086]
     NOT r/m16                     ; o16 F7 /2            [8086]
     NOT r/m32                     ; o32 F7 /2            [386]

   `NEG' replaces the contents of its operand by the two's complement
negation (invert all the bits and then add one) of the original value.
`NOT', similarly, performs one's complement (inverts all the bits).


File: nasm.info,  Node: Section B.4.190,  Next: Section B.4.191,  Prev: Section B.4.189,  Up: Section B.4

B.4.190. `NOP': No Operation
----------------------------

     NOP                           ; 90                   [8086]

   `NOP' performs no operation. Its opcode is the same as that generated
by `XCHG AX,AX' or `XCHG EAX,EAX' (depending on the processor mode; see
*Note Section B.4.333::).


File: nasm.info,  Node: Section B.4.191,  Next: Section B.4.192,  Prev: Section B.4.190,  Up: Section B.4

B.4.191. `OR': Bitwise OR
-------------------------

     OR r/m8,reg8                  ; 08 /r                [8086]
     OR r/m16,reg16                ; o16 09 /r            [8086]
     OR r/m32,reg32                ; o32 09 /r            [386]

     OR reg8,r/m8                  ; 0A /r                [8086]
     OR reg16,r/m16                ; o16 0B /r            [8086]
     OR reg32,r/m32                ; o32 0B /r            [386]

     OR r/m8,imm8                  ; 80 /1 ib             [8086]
     OR r/m16,imm16                ; o16 81 /1 iw         [8086]
     OR r/m32,imm32                ; o32 81 /1 id         [386]

     OR r/m16,imm8                 ; o16 83 /1 ib         [8086]
     OR r/m32,imm8                 ; o32 83 /1 ib         [386]

     OR AL,imm8                    ; 0C ib                [8086]
     OR AX,imm16                   ; o16 0D iw            [8086]
     OR EAX,imm32                  ; o32 0D id            [386]

   `OR' performs a bitwise OR operation between its two operands (i.e.
each bit of the result is 1 if and only if at least one of the
corresponding bits of the two inputs was 1), and stores the result in
the destination (first) operand.

   In the forms with an 8-bit immediate second operand and a longer
first operand, the second operand is considered to be signed, and is
sign- extended to the length of the first operand. In these cases, the
`BYTE' qualifier is necessary to force NASM to generate this form of
the instruction.

   The MMX instruction `POR' (see *Note Section B.4.247::) performs the
same operation on the 64-bit MMX registers.


File: nasm.info,  Node: Section B.4.192,  Next: Section B.4.193,  Prev: Section B.4.191,  Up: Section B.4

B.4.192. `ORPD': Bit-wise Logical OR of Double-Precision FP Data
----------------------------------------------------------------

     ORPD xmm1,xmm2/m128           ; 66 0F 56 /r     [WILLAMETTE,SSE2]

   `ORPD' return a bit-wise logical OR between xmm1 and xmm2/mem, and
stores the result in xmm1. If the source operand is a memory location,
it must be aligned to a 16-byte boundary.


File: nasm.info,  Node: Section B.4.193,  Next: Section B.4.194,  Prev: Section B.4.192,  Up: Section B.4

B.4.193. `ORPS': Bit-wise Logical OR of Single-Precision FP Data
----------------------------------------------------------------

     ORPS xmm1,xmm2/m128           ; 0F 56 /r        [KATMAI,SSE]

   `ORPS' return a bit-wise logical OR between xmm1 and xmm2/mem, and
stores the result in xmm1. If the source operand is a memory location,
it must be aligned to a 16-byte boundary.


File: nasm.info,  Node: Section B.4.194,  Next: Section B.4.195,  Prev: Section B.4.193,  Up: Section B.4

B.4.194. `OUT': Output Data to I/O Port
---------------------------------------

     OUT imm8,AL                   ; E6 ib                [8086]
     OUT imm8,AX                   ; o16 E7 ib            [8086]
     OUT imm8,EAX                  ; o32 E7 ib            [386]
     OUT DX,AL                     ; EE                   [8086]
     OUT DX,AX                     ; o16 EF               [8086]
     OUT DX,EAX                    ; o32 EF               [386]

   `OUT' writes the contents of the given source register to the
specified I/O port. The port number may be specified as an immediate
value if it is between 0 and 255, and otherwise must be stored in `DX'.
See also `IN' (*Note Section B.4.119::).


File: nasm.info,  Node: Section B.4.195,  Next: Section B.4.196,  Prev: Section B.4.194,  Up: Section B.4

B.4.195. `OUTSB', `OUTSW', `OUTSD': Output String to I/O Port
-------------------------------------------------------------

     OUTSB                         ; 6E                   [186]
     OUTSW                         ; o16 6F               [186]
     OUTSD                         ; o32 6F               [386]

   `OUTSB' loads a byte from `[DS:SI]' or `[DS:ESI]' and writes it to
the I/O port specified in `DX'. It then increments or decrements
(depending on the direction flag: increments if the flag is clear,
decrements if it is set) `SI' or `ESI'.

   The register used is `SI' if the address size is 16 bits, and `ESI'
if it is 32 bits. If you need to use an address size not equal to the
current `BITS' setting, you can use an explicit `a16' or `a32' prefix.

   The segment register used to load from `[SI]' or `[ESI]' can be
overridden by using a segment register name as a prefix (for example,
`es outsb').

   `OUTSW' and `OUTSD' work in the same way, but they output a word or
a doubleword instead of a byte, and increment or decrement the
addressing registers by 2 or 4 instead of 1.

   The `REP' prefix may be used to repeat the instruction `CX' (or
`ECX' - again, the address size chooses which) times.


File: nasm.info,  Node: Section B.4.196,  Next: Section B.4.197,  Prev: Section B.4.195,  Up: Section B.4

B.4.196. `PACKSSDW', `PACKSSWB', `PACKUSWB': Pack Data
------------------------------------------------------

     PACKSSDW mm1,mm2/m64          ; 0F 6B /r             [PENT,MMX]
     PACKSSWB mm1,mm2/m64          ; 0F 63 /r             [PENT,MMX]
     PACKUSWB mm1,mm2/m64          ; 0F 67 /r             [PENT,MMX]

     PACKSSDW xmm1,xmm2/m128       ; 66 0F 6B /r     [WILLAMETTE,SSE2]
     PACKSSWB xmm1,xmm2/m128       ; 66 0F 63 /r     [WILLAMETTE,SSE2]
     PACKUSWB xmm1,xmm2/m128       ; 66 0F 67 /r     [WILLAMETTE,SSE2]

   All these instructions start by combining the source and destination
operands, and then splitting the result in smaller sections which it
then packs into the destination register. The `MMX' versions pack two
64- bit operands into one 64-bit register, while the `SSE' versions pack
two 128-bit operands into one 128-bit register.

   * `PACKSSWB' splits the combined value into words, and then reduces
     the words to bytes, using signed saturation. It then packs the
     bytes into the destination register in the same order the words
     were in.

   * `PACKSSDW' performs the same operation as `PACKSSWB', except that
     it reduces doublewords to words, then packs them into the
     destination register.

   * `PACKUSWB' performs the same operation as `PACKSSWB', except that
     it uses unsigned saturation when reducing the size of the elements.

   To perform signed saturation on a number, it is replaced by the
largest signed number (`7FFFh' or `7Fh') that _will_ fit, and if it is
too small it is replaced by the smallest signed number (`8000h' or
`80h') that will fit. To perform unsigned saturation, the input is
treated as unsigned, and the input is replaced by the largest unsigned
number that will fit.


File: nasm.info,  Node: Section B.4.197,  Next: Section B.4.198,  Prev: Section B.4.196,  Up: Section B.4

B.4.197. `PADDB', `PADDW', `PADDD': Add Packed Integers
-------------------------------------------------------

     PADDB mm1,mm2/m64             ; 0F FC /r             [PENT,MMX]
     PADDW mm1,mm2/m64             ; 0F FD /r             [PENT,MMX]
     PADDD mm1,mm2/m64             ; 0F FE /r             [PENT,MMX]

     PADDB xmm1,xmm2/m128          ; 66 0F FC /r     [WILLAMETTE,SSE2]
     PADDW xmm1,xmm2/m128          ; 66 0F FD /r     [WILLAMETTE,SSE2]
     PADDD xmm1,xmm2/m128          ; 66 0F FE /r     [WILLAMETTE,SSE2]

   `PADDx' performs packed addition of the two operands, storing the
result in the destination (first) operand.

   * `PADDB' treats the operands as packed bytes, and adds each byte
     individually;

   * `PADDW' treats the operands as packed words;

   * `PADDD' treats its operands as packed doublewords.

   When an individual result is too large to fit in its destination, it
is wrapped around and the low bits are stored, with the carry bit
discarded.


File: nasm.info,  Node: Section B.4.198,  Next: Section B.4.199,  Prev: Section B.4.197,  Up: Section B.4

B.4.198. `PADDQ': Add Packed Quadword Integers
----------------------------------------------

     PADDQ mm1,mm2/m64             ; 0F D4 /r             [PENT,MMX]

     PADDQ xmm1,xmm2/m128          ; 66 0F D4 /r     [WILLAMETTE,SSE2]

   `PADDQ' adds the quadwords in the source and destination operands,
and stores the result in the destination register.

   When an individual result is too large to fit in its destination, it
is wrapped around and the low bits are stored, with the carry bit
discarded.


File: nasm.info,  Node: Section B.4.199,  Next: Section B.4.200,  Prev: Section B.4.198,  Up: Section B.4

B.4.199. `PADDSB', `PADDSW': Add Packed Signed Integers With Saturation
-----------------------------------------------------------------------

     PADDSB mm1,mm2/m64            ; 0F EC /r             [PENT,MMX]
     PADDSW mm1,mm2/m64            ; 0F ED /r             [PENT,MMX]

     PADDSB xmm1,xmm2/m128         ; 66 0F EC /r     [WILLAMETTE,SSE2]
     PADDSW xmm1,xmm2/m128         ; 66 0F ED /r     [WILLAMETTE,SSE2]

   `PADDSx' performs packed addition of the two operands, storing the
result in the destination (first) operand. `PADDSB' treats the operands
as packed bytes, and adds each byte individually; and `PADDSW' treats
the operands as packed words.

   When an individual result is too large to fit in its destination, a
saturated value is stored. The resulting value is the value with the
largest magnitude of the same sign as the result which will fit in the
available space.


File: nasm.info,  Node: Section B.4.200,  Next: Section B.4.201,  Prev: Section B.4.199,  Up: Section B.4

B.4.200. `PADDSIW': MMX Packed Addition to Implicit Destination
---------------------------------------------------------------

     PADDSIW mmxreg,r/m64          ; 0F 51 /r             [CYRIX,MMX]

   `PADDSIW', specific to the Cyrix extensions to the MMX instruction
set, performs the same function as `PADDSW', except that the result is
placed in an implied register.

   To work out the implied register, invert the lowest bit in the
register number. So `PADDSIW MM0,MM2' would put the result in `MM1', but
`PADDSIW MM1,MM2' would put the result in `MM0'.


File: nasm.info,  Node: Section B.4.201,  Next: Section B.4.202,  Prev: Section B.4.200,  Up: Section B.4

B.4.201. `PADDUSB', `PADDUSW': Add Packed Unsigned Integers With Saturation
---------------------------------------------------------------------------

     PADDUSB mm1,mm2/m64           ; 0F DC /r             [PENT,MMX]
     PADDUSW mm1,mm2/m64           ; 0F DD /r             [PENT,MMX]

     PADDUSB xmm1,xmm2/m128         ; 66 0F DC /r    [WILLAMETTE,SSE2]
     PADDUSW xmm1,xmm2/m128         ; 66 0F DD /r    [WILLAMETTE,SSE2]

   `PADDUSx' performs packed addition of the two operands, storing the
result in the destination (first) operand. `PADDUSB' treats the
operands as packed bytes, and adds each byte individually; and
`PADDUSW' treats the operands as packed words.

   When an individual result is too large to fit in its destination, a
saturated value is stored. The resulting value is the maximum value that
will fit in the available space.


File: nasm.info,  Node: Section B.4.202,  Next: Section B.4.203,  Prev: Section B.4.201,  Up: Section B.4

B.4.202. `PAND', `PANDN': MMX Bitwise AND and AND-NOT
-----------------------------------------------------

     PAND mm1,mm2/m64              ; 0F DB /r             [PENT,MMX]
     PANDN mm1,mm2/m64             ; 0F DF /r             [PENT,MMX]

     PAND xmm1,xmm2/m128           ; 66 0F DB /r     [WILLAMETTE,SSE2]
     PANDN xmm1,xmm2/m128          ; 66 0F DF /r     [WILLAMETTE,SSE2]

   `PAND' performs a bitwise AND operation between its two operands
(i.e.  each bit of the result is 1 if and only if the corresponding
bits of the two inputs were both 1), and stores the result in the
destination (first) operand.

   `PANDN' performs the same operation, but performs a one's complement
operation on the destination (first) operand first.


File: nasm.info,  Node: Section B.4.203,  Next: Section B.4.204,  Prev: Section B.4.202,  Up: Section B.4

B.4.203. `PAUSE': Spin Loop Hint
--------------------------------

     PAUSE                         ; F3 90           [WILLAMETTE,SSE2]

   `PAUSE' provides a hint to the processor that the following code is a
spin loop. This improves processor performance by bypassing possible
memory order violations. On older processors, this instruction operates
as a `NOP'.


File: nasm.info,  Node: Section B.4.204,  Next: Section B.4.205,  Prev: Section B.4.203,  Up: Section B.4

B.4.204. `PAVEB': MMX Packed Average
------------------------------------

     PAVEB mmxreg,r/m64            ; 0F 50 /r             [CYRIX,MMX]

   `PAVEB', specific to the Cyrix MMX extensions, treats its two
operands as vectors of eight unsigned bytes, and calculates the average
of the corresponding bytes in the operands. The resulting vector of
eight averages is stored in the first operand.

   This opcode maps to `MOVMSKPS r32, xmm' on processors that support
the SSE instruction set.


File: nasm.info,  Node: Section B.4.205,  Next: Section B.4.206,  Prev: Section B.4.204,  Up: Section B.4

B.4.205. `PAVGB' `PAVGW': Average Packed Integers
-------------------------------------------------

     PAVGB mm1,mm2/m64             ; 0F E0 /r        [KATMAI,MMX]
     PAVGW mm1,mm2/m64             ; 0F E3 /r        [KATMAI,MMX,SM]

     PAVGB xmm1,xmm2/m128          ; 66 0F E0 /r     [WILLAMETTE,SSE2]
     PAVGW xmm1,xmm2/m128          ; 66 0F E3 /r     [WILLAMETTE,SSE2]

   `PAVGB' and `PAVGW' add the unsigned data elements of the source
operand to the unsigned data elements of the destination register, then
adds 1 to the temporary results. The results of the add are then each
independently right-shifted by one bit position. The high order bits of
each element are filled with the carry bits of the corresponding sum.

   * `PAVGB' operates on packed unsigned bytes, and

   * `PAVGW' operates on packed unsigned words.


File: nasm.info,  Node: Section B.4.206,  Next: Section B.4.207,  Prev: Section B.4.205,  Up: Section B.4

B.4.206. `PAVGUSB': Average of unsigned packed 8-bit values
-----------------------------------------------------------

     PAVGUSB mm1,mm2/m64           ; 0F 0F /r BF          [PENT,3DNOW]

   `PAVGUSB' adds the unsigned data elements of the source operand to
the unsigned data elements of the destination register, then adds 1 to
the temporary results. The results of the add are then each
independently right-shifted by one bit position. The high order bits of
each element are filled with the carry bits of the corresponding sum.

   This instruction performs exactly the same operations as the `PAVGB'
`MMX' instruction (*Note Section B.4.205::).


File: nasm.info,  Node: Section B.4.207,  Next: Section B.4.208,  Prev: Section B.4.206,  Up: Section B.4

B.4.207. `PCMPxx': Compare Packed Integers.
-------------------------------------------

     PCMPEQB mm1,mm2/m64           ; 0F 74 /r             [PENT,MMX]
     PCMPEQW mm1,mm2/m64           ; 0F 75 /r             [PENT,MMX]
     PCMPEQD mm1,mm2/m64           ; 0F 76 /r             [PENT,MMX]

     PCMPGTB mm1,mm2/m64           ; 0F 64 /r             [PENT,MMX]
     PCMPGTW mm1,mm2/m64           ; 0F 65 /r             [PENT,MMX]
     PCMPGTD mm1,mm2/m64           ; 0F 66 /r             [PENT,MMX]

     PCMPEQB xmm1,xmm2/m128        ; 66 0F 74 /r     [WILLAMETTE,SSE2]
     PCMPEQW xmm1,xmm2/m128        ; 66 0F 75 /r     [WILLAMETTE,SSE2]
     PCMPEQD xmm1,xmm2/m128        ; 66 0F 76 /r     [WILLAMETTE,SSE2]

     PCMPGTB xmm1,xmm2/m128        ; 66 0F 64 /r     [WILLAMETTE,SSE2]
     PCMPGTW xmm1,xmm2/m128        ; 66 0F 65 /r     [WILLAMETTE,SSE2]
     PCMPGTD xmm1,xmm2/m128        ; 66 0F 66 /r     [WILLAMETTE,SSE2]

   The `PCMPxx' instructions all treat their operands as vectors of
bytes, words, or doublewords; corresponding elements of the source and
destination are compared, and the corresponding element of the
destination (first) operand is set to all zeros or all ones depending
on the result of the comparison.

   * `PCMPxxB' treats the operands as vectors of bytes;

   * `PCMPxxW' treats the operands as vectors of words;

   * `PCMPxxD' treats the operands as vectors of doublewords;

   * `PCMPEQx' sets the corresponding element of the destination
     operand to all ones if the two elements compared are equal;

   * `PCMPGTx' sets the destination element to all ones if the element
     of the first (destination) operand is greater (treated as a signed
     integer) than that of the second (source) operand.


File: nasm.info,  Node: Section B.4.208,  Next: Section B.4.209,  Prev: Section B.4.207,  Up: Section B.4

B.4.208. `PDISTIB': MMX Packed Distance and Accumulate with Implied Register
----------------------------------------------------------------------------

     PDISTIB mm,m64                ; 0F 54 /r             [CYRIX,MMX]

   `PDISTIB', specific to the Cyrix MMX extensions, treats its two input
operands as vectors of eight unsigned bytes. For each byte position, it
finds the absolute difference between the bytes in that position in the
two input operands, and adds that value to the byte in the same
position in the implied output register. The addition is saturated to
an unsigned byte in the same way as `PADDUSB'.

   To work out the implied register, invert the lowest bit in the
register number. So `PDISTIB MM0,M64' would put the result in `MM1', but
`PDISTIB MM1,M64' would put the result in `MM0'.

   Note that `PDISTIB' cannot take a register as its second source
operand.

   Operation:

        dstI[0-7]     := dstI[0-7]   + ABS(src0[0-7] - src1[0-7]),
        dstI[8-15]    := dstI[8-15]  + ABS(src0[8-15] - src1[8-15]),
        .......
        .......
        dstI[56-63]   := dstI[56-63] + ABS(src0[56-63] - src1[56-63]).


File: nasm.info,  Node: Section B.4.209,  Next: Section B.4.210,  Prev: Section B.4.208,  Up: Section B.4

B.4.209. `PEXTRW': Extract Word
-------------------------------

     PEXTRW reg32,mm,imm8          ; 0F C5 /r ib     [KATMAI,MMX]
     PEXTRW reg32,xmm,imm8         ; 66 0F C5 /r ib  [WILLAMETTE,SSE2]

   `PEXTRW' moves the word in the source register (second operand) that
is pointed to by the count operand (third operand), into the lower half
of a 32-bit general purpose register. The upper half of the register is
cleared to all 0s.

   When the source operand is an `MMX' register, the two least
significant bits of the count specify the source word. When it is an
`SSE' register, the three least significant bits specify the word
location.


File: nasm.info,  Node: Section B.4.210,  Next: Section B.4.211,  Prev: Section B.4.209,  Up: Section B.4

B.4.210. `PF2ID': Packed Single-Precision FP to Integer Convert
---------------------------------------------------------------

     PF2ID mm1,mm2/m64             ; 0F 0F /r 1D          [PENT,3DNOW]

   `PF2ID' converts two single-precision FP values in the source operand
to signed 32-bit integers, using truncation, and stores them in the
destination operand. Source values that are outside the range supported
by the destination are saturated to the largest absolute value of the
same sign.


File: nasm.info,  Node: Section B.4.211,  Next: Section B.4.212,  Prev: Section B.4.210,  Up: Section B.4

B.4.211. `PF2IW': Packed Single-Precision FP to Integer Word Convert
--------------------------------------------------------------------

     PF2IW mm1,mm2/m64             ; 0F 0F /r 1C          [PENT,3DNOW]

   `PF2IW' converts two single-precision FP values in the source operand
to signed 16-bit integers, using truncation, and stores them in the
destination operand. Source values that are outside the range supported
by the destination are saturated to the largest absolute value of the
same sign.

   * In the K6-2 and K6-III, the 16-bit value is zero-extended to
     32-bits before storing.

   * In the K6-2+, K6-III+ and Athlon processors, the value is
     sign-extended to 32-bits before storing.


File: nasm.info,  Node: Section B.4.212,  Next: Section B.4.213,  Prev: Section B.4.211,  Up: Section B.4

B.4.212. `PFACC': Packed Single-Precision FP Accumulate
-------------------------------------------------------

     PFACC mm1,mm2/m64             ; 0F 0F /r AE          [PENT,3DNOW]

   `PFACC' adds the two single-precision FP values from the destination
operand together, then adds the two single-precision FP values from the
source operand, and places the results in the low and high doublewords
of the destination operand.

   The operation is:

        dst[0-31]   := dst[0-31] + dst[32-63],
        dst[32-63]  := src[0-31] + src[32-63].


File: nasm.info,  Node: Section B.4.213,  Next: Section B.4.214,  Prev: Section B.4.212,  Up: Section B.4

B.4.213. `PFADD': Packed Single-Precision FP Addition
-----------------------------------------------------

     PFADD mm1,mm2/m64             ; 0F 0F /r 9E          [PENT,3DNOW]

   `PFADD' performs addition on each of two packed single-precision FP
value pairs.

        dst[0-31]   := dst[0-31]  + src[0-31],
        dst[32-63]  := dst[32-63] + src[32-63].


File: nasm.info,  Node: Section B.4.214,  Next: Section B.4.215,  Prev: Section B.4.213,  Up: Section B.4

B.4.214. `PFCMPxx': Packed Single-Precision FP Compare
------------------------------------------------------

     PFCMPEQ mm1,mm2/m64           ; 0F 0F /r B0          [PENT,3DNOW]
     PFCMPGE mm1,mm2/m64           ; 0F 0F /r 90          [PENT,3DNOW]
     PFCMPGT mm1,mm2/m64           ; 0F 0F /r A0          [PENT,3DNOW]

   The `PFCMPxx' instructions compare the packed single-point FP values
in the source and destination operands, and set the destination
according to the result. If the condition is true, the destination is
set to all 1s, otherwise it's set to all 0s.

   * `PFCMPEQ' tests whether dst == src;

   * `PFCMPGE' tests whether dst >= src;

   * `PFCMPGT' tests whether dst > src.


File: nasm.info,  Node: Section B.4.215,  Next: Section B.4.216,  Prev: Section B.4.214,  Up: Section B.4

B.4.215. `PFMAX': Packed Single-Precision FP Maximum
----------------------------------------------------

     PFMAX mm1,mm2/m64             ; 0F 0F /r A4          [PENT,3DNOW]

   `PFMAX' returns the higher of each pair of single-precision FP
values.  If the higher value is zero, it is returned as positive zero.


File: nasm.info,  Node: Section B.4.216,  Next: Section B.4.217,  Prev: Section B.4.215,  Up: Section B.4

B.4.216. `PFMIN': Packed Single-Precision FP Minimum
----------------------------------------------------

     PFMIN mm1,mm2/m64             ; 0F 0F /r 94          [PENT,3DNOW]

   `PFMIN' returns the lower of each pair of single-precision FP values.
If the lower value is zero, it is returned as positive zero.


File: nasm.info,  Node: Section B.4.217,  Next: Section B.4.218,  Prev: Section B.4.216,  Up: Section B.4

B.4.217. `PFMUL': Packed Single-Precision FP Multiply
-----------------------------------------------------

     PFMUL mm1,mm2/m64             ; 0F 0F /r B4          [PENT,3DNOW]

   `PFMUL' returns the product of each pair of single-precision FP
values.

        dst[0-31]  := dst[0-31]  * src[0-31],
        dst[32-63] := dst[32-63] * src[32-63].


File: nasm.info,  Node: Section B.4.218,  Next: Section B.4.219,  Prev: Section B.4.217,  Up: Section B.4

B.4.218. `PFNACC': Packed Single-Precision FP Negative Accumulate
-----------------------------------------------------------------

     PFNACC mm1,mm2/m64            ; 0F 0F /r 8A          [PENT,3DNOW]

   `PFNACC' performs a negative accumulate of the two single-precision
FP values in the source and destination registers. The result of the
accumulate from the destination register is stored in the low
doubleword of the destination, and the result of the source accumulate
is stored in the high doubleword of the destination register.

   The operation is:

        dst[0-31]  := dst[0-31] - dst[32-63],
        dst[32-63] := src[0-31] - src[32-63].


File: nasm.info,  Node: Section B.4.219,  Next: Section B.4.220,  Prev: Section B.4.218,  Up: Section B.4

B.4.219. `PFPNACC': Packed Single-Precision FP Mixed Accumulate
---------------------------------------------------------------

     PFPNACC mm1,mm2/m64           ; 0F 0F /r 8E          [PENT,3DNOW]

   `PFPNACC' performs a positive accumulate of the two single-precision
FP values in the source register and a negative accumulate of the
destination register. The result of the accumulate from the destination
register is stored in the low doubleword of the destination, and the
result of the source accumulate is stored in the high doubleword of the
destination register.

   The operation is:

        dst[0-31]  := dst[0-31] - dst[32-63],
        dst[32-63] := src[0-31] + src[32-63].


File: nasm.info,  Node: Section B.4.220,  Next: Section B.4.221,  Prev: Section B.4.219,  Up: Section B.4

B.4.220. `PFRCP': Packed Single-Precision FP Reciprocal Approximation
---------------------------------------------------------------------

     PFRCP mm1,mm2/m64             ; 0F 0F /r 96          [PENT,3DNOW]

   `PFRCP' performs a low precision estimate of the reciprocal of the
low-order single-precision FP value in the source operand, storing the
result in both halves of the destination register. The result is
accurate to 14 bits.

   For higher precision reciprocals, this instruction should be
followed by two more instructions: `PFRCPIT1' (*Note Section B.4.221::)
and `PFRCPIT2' (*Note Section B.4.221::). This will result in a 24-bit
accuracy. For more details, see the AMD 3DNow! technology manual.


File: nasm.info,  Node: Section B.4.221,  Next: Section B.4.222,  Prev: Section B.4.220,  Up: Section B.4

B.4.221. `PFRCPIT1': Packed Single-Precision FP Reciprocal, First Iteration Step
--------------------------------------------------------------------------------

     PFRCPIT1 mm1,mm2/m64          ; 0F 0F /r A6          [PENT,3DNOW]

   `PFRCPIT1' performs the first intermediate step in the calculation of
the reciprocal of a single-precision FP value. The first source value
(`mm1' is the original value, and the second source value (`mm2/m64' is
the result of a `PFRCP' instruction.

   For the final step in a reciprocal, returning the full 24-bit
accuracy of a single-precision FP value, see `PFRCPIT2' (*Note Section
B.4.222::). For more details, see the AMD 3DNow! technology manual.


File: nasm.info,  Node: Section B.4.222,  Next: Section B.4.223,  Prev: Section B.4.221,  Up: Section B.4

B.4.222. `PFRCPIT2': Packed Single-Precision FP Reciprocal/ Reciprocal Square Root, Second Iteration Step
---------------------------------------------------------------------------------------------------------

     PFRCPIT2 mm1,mm2/m64          ; 0F 0F /r B6          [PENT,3DNOW]

   `PFRCPIT2' performs the second and final intermediate step in the
calculation of a reciprocal or reciprocal square root, refining the
values returned by the `PFRCP' and `PFRSQRT' instructions, respectively.

   The first source value (`mm1') is the output of either a `PFRCPIT1'
or a `PFRSQIT1' instruction, and the second source is the output of
either the `PFRCP' or the `PFRSQRT' instruction.  For more details, see
the AMD 3DNow! technology manual.


File: nasm.info,  Node: Section B.4.223,  Next: Section B.4.224,  Prev: Section B.4.222,  Up: Section B.4

B.4.223. `PFRSQIT1': Packed Single-Precision FP Reciprocal Square Root, First Iteration Step
--------------------------------------------------------------------------------------------

     PFRSQIT1 mm1,mm2/m64          ; 0F 0F /r A7          [PENT,3DNOW]

   `PFRSQIT1' performs the first intermediate step in the calculation of
the reciprocal square root of a single-precision FP value. The first
source value (`mm1' is the square of the result of a `PFRSQRT'
instruction, and the second source value (`mm2/m64' is the original
value.

   For the final step in a calculation, returning the full 24-bit
accuracy of a single-precision FP value, see `PFRCPIT2' (*Note Section
B.4.222::).  For more details, see the AMD 3DNow! technology manual.


File: nasm.info,  Node: Section B.4.224,  Next: Section B.4.225,  Prev: Section B.4.223,  Up: Section B.4

B.4.224. `PFRSQRT': Packed Single-Precision FP Reciprocal Square Root Approximation
-----------------------------------------------------------------------------------

     PFRSQRT mm1,mm2/m64           ; 0F 0F /r 97          [PENT,3DNOW]

   `PFRSQRT' performs a low precision estimate of the reciprocal square
root of the low-order single-precision FP value in the source operand,
storing the result in both halves of the destination register. The
result is accurate to 15 bits.

   For higher precision reciprocals, this instruction should be
followed by two more instructions: `PFRSQIT1' (*Note Section B.4.223::)
and `PFRCPIT2' (*Note Section B.4.221::). This will result in a 24-bit
accuracy. For more details, see the AMD 3DNow! technology manual.


File: nasm.info,  Node: Section B.4.225,  Next: Section B.4.226,  Prev: Section B.4.224,  Up: Section B.4

B.4.225. `PFSUB': Packed Single-Precision FP Subtract
-----------------------------------------------------

     PFSUB mm1,mm2/m64             ; 0F 0F /r 9A          [PENT,3DNOW]

   `PFSUB' subtracts the single-precision FP values in the source from
those in the destination, and stores the result in the destination
operand.

        dst[0-31]  := dst[0-31]  - src[0-31],
        dst[32-63] := dst[32-63] - src[32-63].


File: nasm.info,  Node: Section B.4.226,  Next: Section B.4.227,  Prev: Section B.4.225,  Up: Section B.4

B.4.226. `PFSUBR': Packed Single-Precision FP Reverse Subtract
--------------------------------------------------------------

     PFSUBR mm1,mm2/m64            ; 0F 0F /r AA          [PENT,3DNOW]

   `PFSUBR' subtracts the single-precision FP values in the destination
from those in the source, and stores the result in the destination
operand.

        dst[0-31]  := src[0-31]  - dst[0-31],
        dst[32-63] := src[32-63] - dst[32-63].


File: nasm.info,  Node: Section B.4.227,  Next: Section B.4.228,  Prev: Section B.4.226,  Up: Section B.4

B.4.227. `PI2FD': Packed Doubleword Integer to Single-Precision FP Convert
--------------------------------------------------------------------------

     PI2FD mm1,mm2/m64             ; 0F 0F /r 0D          [PENT,3DNOW]

   `PF2ID' converts two signed 32-bit integers in the source operand to
single-precision FP values, using truncation of significant digits, and
stores them in the destination operand.


File: nasm.info,  Node: Section B.4.228,  Next: Section B.4.229,  Prev: Section B.4.227,  Up: Section B.4

B.4.228. `PF2IW': Packed Word Integer to Single-Precision FP Convert
--------------------------------------------------------------------

     PI2FW mm1,mm2/m64             ; 0F 0F /r 0C          [PENT,3DNOW]

   `PF2IW' converts two signed 16-bit integers in the source operand to
single-precision FP values, and stores them in the destination operand.
The input values are in the low word of each doubleword.


File: nasm.info,  Node: Section B.4.229,  Next: Section B.4.230,  Prev: Section B.4.228,  Up: Section B.4

B.4.229. `PINSRW': Insert Word
------------------------------

     PINSRW mm,r16/r32/m16,imm8    ;0F C4 /r ib      [KATMAI,MMX]
     PINSRW xmm,r16/r32/m16,imm8   ;66 0F C4 /r ib   [WILLAMETTE,SSE2]

   `PINSRW' loads a word from a 16-bit register (or the low half of a
32- bit register), or from memory, and loads it to the word position in
the destination register, pointed at by the count operand (third
operand). If the destination is an `MMX' register, the low two bits of
the count byte are used, if it is an `XMM' register the low 3 bits are
used. The insertion is done in such a way that the other words from the
destination register are left untouched.


File: nasm.info,  Node: Section B.4.230,  Next: Section B.4.231,  Prev: Section B.4.229,  Up: Section B.4

B.4.230. `PMACHRIW': Packed Multiply and Accumulate with Rounding
-----------------------------------------------------------------

     PMACHRIW mm,m64               ; 0F 5E /r             [CYRIX,MMX]

   `PMACHRIW' takes two packed 16-bit integer inputs, multiplies the
values in the inputs, rounds on bit 15 of each result, then adds bits
15-30 of each result to the corresponding position of the _implied_
destination register.

   The operation of this instruction is:

        dstI[0-15]  := dstI[0-15]  + (mm[0-15] *m64[0-15]
                                               + 0x00004000)[15-30],
        dstI[16-31] := dstI[16-31] + (mm[16-31]*m64[16-31]
                                               + 0x00004000)[15-30],
        dstI[32-47] := dstI[32-47] + (mm[32-47]*m64[32-47]
                                               + 0x00004000)[15-30],
        dstI[48-63] := dstI[48-63] + (mm[48-63]*m64[48-63]
                                               + 0x00004000)[15-30].

   Note that `PMACHRIW' cannot take a register as its second source
operand.


File: nasm.info,  Node: Section B.4.231,  Next: Section B.4.232,  Prev: Section B.4.230,  Up: Section B.4

B.4.231. `PMADDWD': MMX Packed Multiply and Add
-----------------------------------------------

     PMADDWD mm1,mm2/m64           ; 0F F5 /r             [PENT,MMX]
     PMADDWD xmm1,xmm2/m128        ; 66 0F F5 /r     [WILLAMETTE,SSE2]

   `PMADDWD' treats its two inputs as vectors of signed words. It
multiplies corresponding elements of the two operands, giving doubleword
results. These are then added together in pairs and stored in the
destination operand.

   The operation of this instruction is:

        dst[0-31]   := (dst[0-15] * src[0-15])
                                    + (dst[16-31] * src[16-31]);
        dst[32-63]  := (dst[32-47] * src[32-47])
                                    + (dst[48-63] * src[48-63]);

   The following apply to the `SSE' version of the instruction:

        dst[64-95]  := (dst[64-79] * src[64-79])
                                    + (dst[80-95] * src[80-95]);
        dst[96-127] := (dst[96-111] * src[96-111])
                                    + (dst[112-127] * src[112-127]).


File: nasm.info,  Node: Section B.4.232,  Next: Section B.4.233,  Prev: Section B.4.231,  Up: Section B.4

B.4.232. `PMAGW': MMX Packed Magnitude
--------------------------------------

     PMAGW mm1,mm2/m64             ; 0F 52 /r             [CYRIX,MMX]

   `PMAGW', specific to the Cyrix MMX extensions, treats both its
operands as vectors of four signed words. It compares the absolute
values of the words in corresponding positions, and sets each word of
the destination (first) operand to whichever of the two words in that
position had the larger absolute value.


File: nasm.info,  Node: Section B.4.233,  Next: Section B.4.234,  Prev: Section B.4.232,  Up: Section B.4

B.4.233. `PMAXSW': Packed Signed Integer Word Maximum
-----------------------------------------------------

     PMAXSW mm1,mm2/m64            ; 0F EE /r        [KATMAI,MMX]
     PMAXSW xmm1,xmm2/m128         ; 66 0F EE /r     [WILLAMETTE,SSE2]

   `PMAXSW' compares each pair of words in the two source operands, and
for each pair it stores the maximum value in the destination register.


File: nasm.info,  Node: Section B.4.234,  Next: Section B.4.235,  Prev: Section B.4.233,  Up: Section B.4

B.4.234. `PMAXUB': Packed Unsigned Integer Byte Maximum
-------------------------------------------------------

     PMAXUB mm1,mm2/m64            ; 0F DE /r        [KATMAI,MMX]
     PMAXUB xmm1,xmm2/m128         ; 66 0F DE /r     [WILLAMETTE,SSE2]

   `PMAXUB' compares each pair of bytes in the two source operands, and
for each pair it stores the maximum value in the destination register.


File: nasm.info,  Node: Section B.4.235,  Next: Section B.4.236,  Prev: Section B.4.234,  Up: Section B.4

B.4.235. `PMINSW': Packed Signed Integer Word Minimum
-----------------------------------------------------

     PMINSW mm1,mm2/m64            ; 0F EA /r        [KATMAI,MMX]
     PMINSW xmm1,xmm2/m128         ; 66 0F EA /r     [WILLAMETTE,SSE2]

   `PMINSW' compares each pair of words in the two source operands, and
for each pair it stores the minimum value in the destination register.


File: nasm.info,  Node: Section B.4.236,  Next: Section B.4.237,  Prev: Section B.4.235,  Up: Section B.4

B.4.236. `PMINUB': Packed Unsigned Integer Byte Minimum
-------------------------------------------------------

     PMINUB mm1,mm2/m64            ; 0F DA /r        [KATMAI,MMX]
     PMINUB xmm1,xmm2/m128         ; 66 0F DA /r     [WILLAMETTE,SSE2]

   `PMINUB' compares each pair of bytes in the two source operands, and
for each pair it stores the minimum value in the destination register.


File: nasm.info,  Node: Section B.4.237,  Next: Section B.4.238,  Prev: Section B.4.236,  Up: Section B.4

B.4.237. `PMOVMSKB': Move Byte Mask To Integer
----------------------------------------------

     PMOVMSKB reg32,mm             ; 0F D7 /r        [KATMAI,MMX]
     PMOVMSKB reg32,xmm            ; 66 0F D7 /r     [WILLAMETTE,SSE2]

   `PMOVMSKB' returns an 8-bit or 16-bit mask formed of the most
significant bits of each byte of source operand (8-bits for an `MMX'
register, 16-bits for an `XMM' register).


File: nasm.info,  Node: Section B.4.238,  Next: Section B.4.239,  Prev: Section B.4.237,  Up: Section B.4

B.4.238. `PMULHRWC', `PMULHRIW': Multiply Packed 16-bit Integers With Rounding, and Store High Word
---------------------------------------------------------------------------------------------------

     PMULHRWC mm1,mm2/m64         ; 0F 59 /r              [CYRIX,MMX]
     PMULHRIW mm1,mm2/m64         ; 0F 5D /r              [CYRIX,MMX]

   These instructions take two packed 16-bit integer inputs, multiply
the values in the inputs, round on bit 15 of each result, then store
bits 15-30 of each result to the corresponding position of the
destination register.

   * For `PMULHRWC', the destination is the first source operand.

   * For `PMULHRIW', the destination is an implied register (worked out
     as described for `PADDSIW' (*Note Section B.4.200::)).

   The operation of this instruction is:

        dst[0-15]  := (src1[0-15] *src2[0-15]  + 0x00004000)[15-30]
        dst[16-31] := (src1[16-31]*src2[16-31] + 0x00004000)[15-30]
        dst[32-47] := (src1[32-47]*src2[32-47] + 0x00004000)[15-30]
        dst[48-63] := (src1[48-63]*src2[48-63] + 0x00004000)[15-30]

   See also `PMULHRWA' (*Note Section B.4.239::) for a 3DNow! version of
this instruction.


File: nasm.info,  Node: Section B.4.239,  Next: Section B.4.240,  Prev: Section B.4.238,  Up: Section B.4

B.4.239. `PMULHRWA': Multiply Packed 16-bit Integers With Rounding, and Store High Word
---------------------------------------------------------------------------------------

     PMULHRWA mm1,mm2/m64          ; 0F 0F /r B7     [PENT,3DNOW]

   `PMULHRWA' takes two packed 16-bit integer inputs, multiplies the
values in the inputs, rounds on bit 16 of each result, then stores bits
16- 31 of each result to the corresponding position of the destination
register.

   The operation of this instruction is:

        dst[0-15]  := (src1[0-15] *src2[0-15]  + 0x00008000)[16-31];
        dst[16-31] := (src1[16-31]*src2[16-31] + 0x00008000)[16-31];
        dst[32-47] := (src1[32-47]*src2[32-47] + 0x00008000)[16-31];
        dst[48-63] := (src1[48-63]*src2[48-63] + 0x00008000)[16-31].

   See also `PMULHRWC' (*Note Section B.4.238::) for a Cyrix version of
this instruction.


File: nasm.info,  Node: Section B.4.240,  Next: Section B.4.241,  Prev: Section B.4.239,  Up: Section B.4

B.4.240. `PMULHUW': Multiply Packed 16-bit Integers, and Store High Word
------------------------------------------------------------------------

     PMULHUW mm1,mm2/m64           ; 0F E4 /r        [KATMAI,MMX]
     PMULHUW xmm1,xmm2/m128        ; 66 0F E4 /r     [WILLAMETTE,SSE2]

   `PMULHUW' takes two packed unsigned 16-bit integer inputs, multiplies
the values in the inputs, then stores bits 16-31 of each result to the
corresponding position of the destination register.


File: nasm.info,  Node: Section B.4.241,  Next: Section B.4.242,  Prev: Section B.4.240,  Up: Section B.4

B.4.241. `PMULHW', `PMULLW': Multiply Packed 16-bit Integers, and Store
-----------------------------------------------------------------------

     PMULHW mm1,mm2/m64            ; 0F E5 /r             [PENT,MMX]
     PMULLW mm1,mm2/m64            ; 0F D5 /r             [PENT,MMX]

     PMULHW xmm1,xmm2/m128         ; 66 0F E5 /r     [WILLAMETTE,SSE2]
     PMULLW xmm1,xmm2/m128         ; 66 0F D5 /r     [WILLAMETTE,SSE2]

   `PMULxW' takes two packed unsigned 16-bit integer inputs, and
multiplies the values in the inputs, forming doubleword results.

   * `PMULHW' then stores the top 16 bits of each doubleword in the
     destination (first) operand;

   * `PMULLW' stores the bottom 16 bits of each doubleword in the
     destination operand.


File: nasm.info,  Node: Section B.4.242,  Next: Section B.4.243,  Prev: Section B.4.241,  Up: Section B.4

B.4.242. `PMULUDQ': Multiply Packed Unsigned 32-bit Integers, and Store.
------------------------------------------------------------------------

     PMULUDQ mm1,mm2/m64           ; 0F F4 /r        [WILLAMETTE,SSE2]
     PMULUDQ xmm1,xmm2/m128        ; 66 0F F4 /r     [WILLAMETTE,SSE2]

   `PMULUDQ' takes two packed unsigned 32-bit integer inputs, and
multiplies the values in the inputs, forming quadword results. The
source is either an unsigned doubleword in the low doubleword of a
64-bit operand, or it's two unsigned doublewords in the first and third
doublewords of a 128-bit operand. This produces either one or two
64-bit results, which are stored in the respective quadword locations
of the destination register.

   The operation is:

        dst[0-63]   := dst[0-31]  * src[0-31];
        dst[64-127] := dst[64-95] * src[64-95].


File: nasm.info,  Node: Section B.4.243,  Next: Section B.4.244,  Prev: Section B.4.242,  Up: Section B.4

B.4.243. `PMVccZB': MMX Packed Conditional Move
-----------------------------------------------

     PMVZB mmxreg,mem64            ; 0F 58 /r             [CYRIX,MMX]
     PMVNZB mmxreg,mem64           ; 0F 5A /r             [CYRIX,MMX]
     PMVLZB mmxreg,mem64           ; 0F 5B /r             [CYRIX,MMX]
     PMVGEZB mmxreg,mem64          ; 0F 5C /r             [CYRIX,MMX]

   These instructions, specific to the Cyrix MMX extensions, perform
parallel conditional moves. The two input operands are treated as
vectors of eight bytes. Each byte of the destination (first) operand is
either written from the corresponding byte of the source (second)
operand, or left alone, depending on the value of the byte in the
_implied_ operand (specified in the same way as `PADDSIW', in *Note
Section B.4.200::).

   * `PMVZB' performs each move if the corresponding byte in the implied
     operand is zero;

   * `PMVNZB' moves if the byte is non-zero;

   * `PMVLZB' moves if the byte is less than zero;

   * `PMVGEZB' moves if the byte is greater than or equal to zero.

   Note that these instructions cannot take a register as their second
source operand.


File: nasm.info,  Node: Section B.4.244,  Next: Section B.4.245,  Prev: Section B.4.243,  Up: Section B.4

B.4.244. `POP': Pop Data from Stack
-----------------------------------

     POP reg16                     ; o16 58+r             [8086]
     POP reg32                     ; o32 58+r             [386]

     POP r/m16                     ; o16 8F /0            [8086]
     POP r/m32                     ; o32 8F /0            [386]

     POP CS                        ; 0F                   [8086,UNDOC]
     POP DS                        ; 1F                   [8086]
     POP ES                        ; 07                   [8086]
     POP SS                        ; 17                   [8086]
     POP FS                        ; 0F A1                [386]
     POP GS                        ; 0F A9                [386]

   `POP' loads a value from the stack (from `[SS:SP]' or `[SS:ESP]')
and then increments the stack pointer.

   The address-size attribute of the instruction determines whether `SP'
or `ESP' is used as the stack pointer: to deliberately override the
default given by the `BITS' setting, you can use an `a16' or `a32'
prefix.

   The operand-size attribute of the instruction determines whether the
stack pointer is incremented by 2 or 4: this means that segment
register pops in `BITS 32' mode will pop 4 bytes off the stack and
discard the upper two of them. If you need to override that, you can
use an `o16' or `o32' prefix.

   The above opcode listings give two forms for general-purpose
register pop instructions: for example, `POP BX' has the two forms `5B'
and `8F C3'. NASM will always generate the shorter form when given `POP
BX'. NDISASM will disassemble both.

   `POP CS' is not a documented instruction, and is not supported on any
processor above the 8086 (since they use `0Fh' as an opcode prefix for
instruction set extensions). However, at least some 8086 processors do
support it, and so NASM generates it for completeness.


File: nasm.info,  Node: Section B.4.245,  Next: Section B.4.246,  Prev: Section B.4.244,  Up: Section B.4

B.4.245. `POPAx': Pop All General-Purpose Registers
---------------------------------------------------

     POPA                          ; 61                   [186]
     POPAW                         ; o16 61               [186]
     POPAD                         ; o32 61               [386]

   * `POPAW' pops a word from the stack into each of, successively,
     `DI', `SI', `BP', nothing (it discards a word from the stack which
     was a placeholder for `SP'), `BX', `DX', `CX' and `AX'. It is
     intended to reverse the operation of `PUSHAW' (see *Note Section
     B.4.264::), but it ignores the value for `SP' that was pushed on
     the stack by `PUSHAW'.

   * `POPAD' pops twice as much data, and places the results in `EDI',
     `ESI', `EBP', nothing (placeholder for `ESP'), `EBX', `EDX', `ECX'
     and `EAX'. It reverses the operation of `PUSHAD'.

   `POPA' is an alias mnemonic for either `POPAW' or `POPAD', depending
on the current `BITS' setting.

   Note that the registers are popped in reverse order of their numeric
values in opcodes (see *Note Section B.2.1::).


File: nasm.info,  Node: Section B.4.246,  Next: Section B.4.247,  Prev: Section B.4.245,  Up: Section B.4

B.4.246. `POPFx': Pop Flags Register
------------------------------------

     POPF                          ; 9D                   [8086]
     POPFW                         ; o16 9D               [8086]
     POPFD                         ; o32 9D               [386]

   * `POPFW' pops a word from the stack and stores it in the bottom 16
     bits of the flags register (or the whole flags register, on
     processors below a 386).

   * `POPFD' pops a doubleword and stores it in the entire flags
     register.

   `POPF' is an alias mnemonic for either `POPFW' or `POPFD', depending
on the current `BITS' setting.

   See also `PUSHF' (*Note Section B.4.265::).


File: nasm.info,  Node: Section B.4.247,  Next: Section B.4.248,  Prev: Section B.4.246,  Up: Section B.4

B.4.247. `POR': MMX Bitwise OR
------------------------------

     POR mm1,mm2/m64               ; 0F EB /r             [PENT,MMX]
     POR xmm1,xmm2/m128            ; 66 0F EB /r     [WILLAMETTE,SSE2]

   `POR' performs a bitwise OR operation between its two operands (i.e.
each bit of the result is 1 if and only if at least one of the
corresponding bits of the two inputs was 1), and stores the result in
the destination (first) operand.


File: nasm.info,  Node: Section B.4.248,  Next: Section B.4.249,  Prev: Section B.4.247,  Up: Section B.4

B.4.248. `PREFETCH': Prefetch Data Into Caches
----------------------------------------------

     PREFETCH mem8                 ; 0F 0D /0             [PENT,3DNOW]
     PREFETCHW mem8                ; 0F 0D /1             [PENT,3DNOW]

   `PREFETCH' and `PREFETCHW' fetch the line of data from memory that
contains the specified byte. `PREFETCHW' performs differently on the
Athlon to earlier processors.

   For more details, see the 3DNow! Technology Manual.


File: nasm.info,  Node: Section B.4.249,  Next: Section B.4.250,  Prev: Section B.4.248,  Up: Section B.4

B.4.249. `PREFETCHh': Prefetch Data Into Caches
-----------------------------------------------

     PREFETCHNTA m8                ; 0F 18 /0        [KATMAI]
     PREFETCHT0 m8                 ; 0F 18 /1        [KATMAI]
     PREFETCHT1 m8                 ; 0F 18 /2        [KATMAI]
     PREFETCHT2 m8                 ; 0F 18 /3        [KATMAI]

   The `PREFETCHh' instructions fetch the line of data from memory that
contains the specified byte. It is placed in the cache according to
rules specified by locality hints `h':

   The hints are:

   * `T0' (temporal data) - prefetch data into all levels of the cache
     hierarchy.

   * `T1' (temporal data with respect to first level cache) - prefetch
     data into level 2 cache and higher.

   * `T2' (temporal data with respect to second level cache) - prefetch
     data into level 2 cache and higher.

   * `NTA' (non-temporal data with respect to all cache levels) -
     prefetch data into non-temporal cache structure and into a
     location close to the processor, minimizing cache pollution.

   Note that this group of instructions doesn't provide a guarantee
that the data will be in the cache when it is needed. For more details,
see the Intel IA32 Software Developer Manual, Volume 2.


File: nasm.info,  Node: Section B.4.250,  Next: Section B.4.251,  Prev: Section B.4.249,  Up: Section B.4

B.4.250. `PSADBW': Packed Sum of Absolute Differences
-----------------------------------------------------

     PSADBW mm1,mm2/m64            ; 0F F6 /r        [KATMAI,MMX]
     PSADBW xmm1,xmm2/m128         ; 66 0F F6 /r     [WILLAMETTE,SSE2]

   `PSADBW' The PSADBW instruction computes the absolute value of the
difference of the packed unsigned bytes in the two source operands.
These differences are then summed to produce a word result in the lower
16-bit field of the destination register; the rest of the register is
cleared. The destination operand is an `MMX' or an `XMM' register. The
source operand can either be a register or a memory operand.


File: nasm.info,  Node: Section B.4.251,  Next: Section B.4.252,  Prev: Section B.4.250,  Up: Section B.4

B.4.251. `PSHUFD': Shuffle Packed Doublewords
---------------------------------------------

     PSHUFD xmm1,xmm2/m128,imm8    ; 66 0F 70 /r ib  [WILLAMETTE,SSE2]

   `PSHUFD' shuffles the doublewords in the source (second) operand
according to the encoding specified by imm8, and stores the result in
the destination (first) operand.

   Bits 0 and 1 of imm8 encode the source position of the doubleword to
be copied to position 0 in the destination operand. Bits 2 and 3 encode
for position 1, bits 4 and 5 encode for position 2, and bits 6 and 7
encode for position 3. For example, an encoding of 10 in bits 0 and 1
of imm8 indicates that the doubleword at bits 64-95 of the source
operand will be copied to bits 0-31 of the destination.


File: nasm.info,  Node: Section B.4.252,  Next: Section B.4.253,  Prev: Section B.4.251,  Up: Section B.4

B.4.252. `PSHUFHW': Shuffle Packed High Words
---------------------------------------------

     PSHUFHW xmm1,xmm2/m128,imm8   ; F3 0F 70 /r ib  [WILLAMETTE,SSE2]

   `PSHUFW' shuffles the words in the high quadword of the source
(second) operand according to the encoding specified by imm8, and stores
the result in the high quadword of the destination (first) operand.

   The operation of this instruction is similar to the `PSHUFW'
instruction, except that the source and destination are the top
quadword of a 128-bit operand, instead of being 64-bit operands. The
low quadword is copied from the source to the destination without any
changes.


File: nasm.info,  Node: Section B.4.253,  Next: Section B.4.254,  Prev: Section B.4.252,  Up: Section B.4

B.4.253. `PSHUFLW': Shuffle Packed Low Words
--------------------------------------------

     PSHUFLW xmm1,xmm2/m128,imm8   ; F2 0F 70 /r ib  [WILLAMETTE,SSE2]

   `PSHUFLW' shuffles the words in the low quadword of the source
(second) operand according to the encoding specified by imm8, and stores
the result in the low quadword of the destination (first) operand.

   The operation of this instruction is similar to the `PSHUFW'
instruction, except that the source and destination are the low
quadword of a 128-bit operand, instead of being 64-bit operands. The
high quadword is copied from the source to the destination without any
changes.


File: nasm.info,  Node: Section B.4.254,  Next: Section B.4.255,  Prev: Section B.4.253,  Up: Section B.4

B.4.254. `PSHUFW': Shuffle Packed Words
---------------------------------------

     PSHUFW mm1,mm2/m64,imm8       ; 0F 70 /r ib     [KATMAI,MMX]

   `PSHUFW' shuffles the words in the source (second) operand according
to the encoding specified by imm8, and stores the result in the
destination (first) operand.

   Bits 0 and 1 of imm8 encode the source position of the word to be
copied to position 0 in the destination operand. Bits 2 and 3 encode
for position 1, bits 4 and 5 encode for position 2, and bits 6 and 7
encode for position 3.  For example, an encoding of 10 in bits 0 and 1
of imm8 indicates that the word at bits 32-47 of the source operand
will be copied to bits 0-15 of the destination.


File: nasm.info,  Node: Section B.4.255,  Next: Section B.4.256,  Prev: Section B.4.254,  Up: Section B.4

B.4.255. `PSLLx': Packed Data Bit Shift Left Logical
----------------------------------------------------

     PSLLW mm1,mm2/m64             ; 0F F1 /r             [PENT,MMX]
     PSLLW mm,imm8                 ; 0F 71 /6 ib          [PENT,MMX]

     PSLLW xmm1,xmm2/m128          ; 66 0F F1 /r     [WILLAMETTE,SSE2]
     PSLLW xmm,imm8                ; 66 0F 71 /6 ib  [WILLAMETTE,SSE2]

     PSLLD mm1,mm2/m64             ; 0F F2 /r             [PENT,MMX]
     PSLLD mm,imm8                 ; 0F 72 /6 ib          [PENT,MMX]

     PSLLD xmm1,xmm2/m128          ; 66 0F F2 /r     [WILLAMETTE,SSE2]
     PSLLD xmm,imm8                ; 66 0F 72 /6 ib  [WILLAMETTE,SSE2]

     PSLLQ mm1,mm2/m64             ; 0F F3 /r             [PENT,MMX]
     PSLLQ mm,imm8                 ; 0F 73 /6 ib          [PENT,MMX]

     PSLLQ xmm1,xmm2/m128          ; 66 0F F3 /r     [WILLAMETTE,SSE2]
     PSLLQ xmm,imm8                ; 66 0F 73 /6 ib  [WILLAMETTE,SSE2]

     PSLLDQ xmm1,imm8              ; 66 0F 73 /7 ib  [WILLAMETTE,SSE2]

   `PSLLx' performs logical left shifts of the data elements in the
destination (first) operand, moving each bit in the separate elements
left by the number of bits specified in the source (second) operand,
clearing the low-order bits as they are vacated. `PSLLDQ' shifts bytes,
not bits.

   * `PSLLW' shifts word sized elements.

   * `PSLLD' shifts doubleword sized elements.

   * `PSLLQ' shifts quadword sized elements.

   * `PSLLDQ' shifts double quadword sized elements.


File: nasm.info,  Node: Section B.4.256,  Next: Section B.4.257,  Prev: Section B.4.255,  Up: Section B.4

B.4.256. `PSRAx': Packed Data Bit Shift Right Arithmetic
--------------------------------------------------------

     PSRAW mm1,mm2/m64             ; 0F E1 /r             [PENT,MMX]
     PSRAW mm,imm8                 ; 0F 71 /4 ib          [PENT,MMX]

     PSRAW xmm1,xmm2/m128          ; 66 0F E1 /r     [WILLAMETTE,SSE2]
     PSRAW xmm,imm8                ; 66 0F 71 /4 ib  [WILLAMETTE,SSE2]

     PSRAD mm1,mm2/m64             ; 0F E2 /r             [PENT,MMX]
     PSRAD mm,imm8                 ; 0F 72 /4 ib          [PENT,MMX]

     PSRAD xmm1,xmm2/m128          ; 66 0F E2 /r     [WILLAMETTE,SSE2]
     PSRAD xmm,imm8                ; 66 0F 72 /4 ib  [WILLAMETTE,SSE2]

   `PSRAx' performs arithmetic right shifts of the data elements in the
destination (first) operand, moving each bit in the separate elements
right by the number of bits specified in the source (second) operand,
setting the high-order bits to the value of the original sign bit.

   * `PSRAW' shifts word sized elements.

   * `PSRAD' shifts doubleword sized elements.


File: nasm.info,  Node: Section B.4.257,  Next: Section B.4.258,  Prev: Section B.4.256,  Up: Section B.4

B.4.257. `PSRLx': Packed Data Bit Shift Right Logical
-----------------------------------------------------

     PSRLW mm1,mm2/m64             ; 0F D1 /r             [PENT,MMX]
     PSRLW mm,imm8                 ; 0F 71 /2 ib          [PENT,MMX]

     PSRLW xmm1,xmm2/m128          ; 66 0F D1 /r     [WILLAMETTE,SSE2]
     PSRLW xmm,imm8                ; 66 0F 71 /2 ib  [WILLAMETTE,SSE2]

     PSRLD mm1,mm2/m64             ; 0F D2 /r             [PENT,MMX]
     PSRLD mm,imm8                 ; 0F 72 /2 ib          [PENT,MMX]

     PSRLD xmm1,xmm2/m128          ; 66 0F D2 /r     [WILLAMETTE,SSE2]
     PSRLD xmm,imm8                ; 66 0F 72 /2 ib  [WILLAMETTE,SSE2]

     PSRLQ mm1,mm2/m64             ; 0F D3 /r             [PENT,MMX]
     PSRLQ mm,imm8                 ; 0F 73 /2 ib          [PENT,MMX]

     PSRLQ xmm1,xmm2/m128          ; 66 0F D3 /r     [WILLAMETTE,SSE2]
     PSRLQ xmm,imm8                ; 66 0F 73 /2 ib  [WILLAMETTE,SSE2]

     PSRLDQ xmm1,imm8              ; 66 0F 73 /3 ib  [WILLAMETTE,SSE2]

   `PSRLx' performs logical right shifts of the data elements in the
destination (first) operand, moving each bit in the separate elements
right by the number of bits specified in the source (second) operand,
clearing the high-order bits as they are vacated. `PSRLDQ' shifts
bytes, not bits.

   * `PSRLW' shifts word sized elements.

   * `PSRLD' shifts doubleword sized elements.

   * `PSRLQ' shifts quadword sized elements.

   * `PSRLDQ' shifts double quadword sized elements.


File: nasm.info,  Node: Section B.4.258,  Next: Section B.4.259,  Prev: Section B.4.257,  Up: Section B.4

B.4.258. `PSUBx': Subtract Packed Integers
------------------------------------------

     PSUBB mm1,mm2/m64             ; 0F F8 /r             [PENT,MMX]
     PSUBW mm1,mm2/m64             ; 0F F9 /r             [PENT,MMX]
     PSUBD mm1,mm2/m64             ; 0F FA /r             [PENT,MMX]
     PSUBQ mm1,mm2/m64             ; 0F FB /r        [WILLAMETTE,SSE2]

     PSUBB xmm1,xmm2/m128          ; 66 0F F8 /r     [WILLAMETTE,SSE2]
     PSUBW xmm1,xmm2/m128          ; 66 0F F9 /r     [WILLAMETTE,SSE2]
     PSUBD xmm1,xmm2/m128          ; 66 0F FA /r     [WILLAMETTE,SSE2]
     PSUBQ xmm1,xmm2/m128          ; 66 0F FB /r     [WILLAMETTE,SSE2]

   `PSUBx' subtracts packed integers in the source operand from those in
the destination operand. It doesn't differentiate between signed and
unsigned integers, and doesn't set any of the flags.

   * `PSUBB' operates on byte sized elements.

   * `PSUBW' operates on word sized elements.

   * `PSUBD' operates on doubleword sized elements.

   * `PSUBQ' operates on quadword sized elements.


File: nasm.info,  Node: Section B.4.259,  Next: Section B.4.260,  Prev: Section B.4.258,  Up: Section B.4

B.4.259. `PSUBSxx', `PSUBUSx': Subtract Packed Integers With Saturation
-----------------------------------------------------------------------

     PSUBSB mm1,mm2/m64            ; 0F E8 /r             [PENT,MMX]
     PSUBSW mm1,mm2/m64            ; 0F E9 /r             [PENT,MMX]

     PSUBSB xmm1,xmm2/m128         ; 66 0F E8 /r     [WILLAMETTE,SSE2]
     PSUBSW xmm1,xmm2/m128         ; 66 0F E9 /r     [WILLAMETTE,SSE2]

     PSUBUSB mm1,mm2/m64           ; 0F D8 /r             [PENT,MMX]
     PSUBUSW mm1,mm2/m64           ; 0F D9 /r             [PENT,MMX]

     PSUBUSB xmm1,xmm2/m128        ; 66 0F D8 /r     [WILLAMETTE,SSE2]
     PSUBUSW xmm1,xmm2/m128        ; 66 0F D9 /r     [WILLAMETTE,SSE2]

   `PSUBSx' and `PSUBUSx' subtracts packed integers in the source
operand from those in the destination operand, and use saturation for
results that are outside the range supported by the destination operand.

   * `PSUBSB' operates on signed bytes, and uses signed saturation on
     the results.

   * `PSUBSW' operates on signed words, and uses signed saturation on
     the results.

   * `PSUBUSB' operates on unsigned bytes, and uses signed saturation on
     the results.

   * `PSUBUSW' operates on unsigned words, and uses signed saturation on
     the results.


File: nasm.info,  Node: Section B.4.260,  Next: Section B.4.261,  Prev: Section B.4.259,  Up: Section B.4

B.4.260. `PSUBSIW': MMX Packed Subtract with Saturation to Implied Destination
------------------------------------------------------------------------------

     PSUBSIW mm1,mm2/m64           ; 0F 55 /r             [CYRIX,MMX]

   `PSUBSIW', specific to the Cyrix extensions to the MMX instruction
set, performs the same function as `PSUBSW', except that the result is
not placed in the register specified by the first operand, but instead
in the implied destination register, specified as for `PADDSIW' (*Note
Section B.4.200::).


File: nasm.info,  Node: Section B.4.261,  Next: Section B.4.262,  Prev: Section B.4.260,  Up: Section B.4

B.4.261. `PSWAPD': Swap Packed Data
-----------------------------------

     PSWAPD mm1,mm2/m64            ; 0F 0F /r BB     [PENT,3DNOW]

   `PSWAPD' swaps the packed doublewords in the source operand, and
stores the result in the destination operand.

   In the `K6-2' and `K6-III' processors, this opcode uses the mnemonic
`PSWAPW', and it swaps the order of words when copying from the source
to the destination.

   The operation in the `K6-2' and `K6-III' processors is

        dst[0-15]  = src[48-63];
        dst[16-31] = src[32-47];
        dst[32-47] = src[16-31];
        dst[48-63] = src[0-15].

   The operation in the `K6-x+', `ATHLON' and later processors is:

        dst[0-31]  = src[32-63];
        dst[32-63] = src[0-31].


File: nasm.info,  Node: Section B.4.262,  Next: Section B.4.263,  Prev: Section B.4.261,  Up: Section B.4

B.4.262. `PUNPCKxxx': Unpack and Interleave Data
------------------------------------------------

     PUNPCKHBW mm1,mm2/m64         ; 0F 68 /r             [PENT,MMX]
     PUNPCKHWD mm1,mm2/m64         ; 0F 69 /r             [PENT,MMX]
     PUNPCKHDQ mm1,mm2/m64         ; 0F 6A /r             [PENT,MMX]

     PUNPCKHBW xmm1,xmm2/m128      ; 66 0F 68 /r     [WILLAMETTE,SSE2]
     PUNPCKHWD xmm1,xmm2/m128      ; 66 0F 69 /r     [WILLAMETTE,SSE2]
     PUNPCKHDQ xmm1,xmm2/m128      ; 66 0F 6A /r     [WILLAMETTE,SSE2]
     PUNPCKHQDQ xmm1,xmm2/m128     ; 66 0F 6D /r     [WILLAMETTE,SSE2]

     PUNPCKLBW mm1,mm2/m32         ; 0F 60 /r             [PENT,MMX]
     PUNPCKLWD mm1,mm2/m32         ; 0F 61 /r             [PENT,MMX]
     PUNPCKLDQ mm1,mm2/m32         ; 0F 62 /r             [PENT,MMX]

     PUNPCKLBW xmm1,xmm2/m128      ; 66 0F 60 /r     [WILLAMETTE,SSE2]
     PUNPCKLWD xmm1,xmm2/m128      ; 66 0F 61 /r     [WILLAMETTE,SSE2]
     PUNPCKLDQ xmm1,xmm2/m128      ; 66 0F 62 /r     [WILLAMETTE,SSE2]
     PUNPCKLQDQ xmm1,xmm2/m128     ; 66 0F 6C /r     [WILLAMETTE,SSE2]

   `PUNPCKxx' all treat their operands as vectors, and produce a new
vector generated by interleaving elements from the two inputs. The
`PUNPCKHxx' instructions start by throwing away the bottom half of each
input operand, and the `PUNPCKLxx' instructions throw away the top half.

   The remaining elements, are then interleaved into the destination,
alternating elements from the second (source) operand and the first
(destination) operand: so the leftmost part of each element in the
result always comes from the second operand, and the rightmost from the
destination.

   * `PUNPCKxBW' works a byte at a time, producing word sized output
     elements.

   * `PUNPCKxWD' works a word at a time, producing doubleword sized
     output elements.

   * `PUNPCKxDQ' works a doubleword at a time, producing quadword sized
     output elements.

   * `PUNPCKxQDQ' works a quadword at a time, producing double quadword
     sized output elements.

   So, for example, for `MMX' operands, if the first operand held
`0x7A6A5A4A3A2A1A0A' and the second held `0x7B6B5B4B3B2B1B0B', then:

   * `PUNPCKHBW' would return `0x7B7A6B6A5B5A4B4A'.

   * `PUNPCKHWD' would return `0x7B6B7A6A5B4B5A4A'.

   * `PUNPCKHDQ' would return `0x7B6B5B4B7A6A5A4A'.

   * `PUNPCKLBW' would return `0x3B3A2B2A1B1A0B0A'.

   * `PUNPCKLWD' would return `0x3B2B3A2A1B0B1A0A'.

   * `PUNPCKLDQ' would return `0x3B2B1B0B3A2A1A0A'.


File: nasm.info,  Node: Section B.4.263,  Next: Section B.4.264,  Prev: Section B.4.262,  Up: Section B.4

B.4.263. `PUSH': Push Data on Stack
-----------------------------------

     PUSH reg16                    ; o16 50+r             [8086]
     PUSH reg32                    ; o32 50+r             [386]

     PUSH r/m16                    ; o16 FF /6            [8086]
     PUSH r/m32                    ; o32 FF /6            [386]

     PUSH CS                       ; 0E                   [8086]
     PUSH DS                       ; 1E                   [8086]
     PUSH ES                       ; 06                   [8086]
     PUSH SS                       ; 16                   [8086]
     PUSH FS                       ; 0F A0                [386]
     PUSH GS                       ; 0F A8                [386]

     PUSH imm8                     ; 6A ib                [186]
     PUSH imm16                    ; o16 68 iw            [186]
     PUSH imm32                    ; o32 68 id            [386]

   `PUSH' decrements the stack pointer (`SP' or `ESP') by 2 or 4, and
then stores the given value at `[SS:SP]' or `[SS:ESP]'.

   The address-size attribute of the instruction determines whether `SP'
or `ESP' is used as the stack pointer: to deliberately override the
default given by the `BITS' setting, you can use an `a16' or `a32'
prefix.

   The operand-size attribute of the instruction determines whether the
stack pointer is decremented by 2 or 4: this means that segment
register pushes in `BITS 32' mode will push 4 bytes on the stack, of
which the upper two are undefined. If you need to override that, you
can use an `o16' or `o32' prefix.

   The above opcode listings give two forms for general-purpose
register push instructions: for example, `PUSH BX' has the two forms
`53' and `FF F3'. NASM will always generate the shorter form when given
`PUSH BX'. NDISASM will disassemble both.

   Unlike the undocumented and barely supported `POP CS', `PUSH CS' is
a perfectly valid and sensible instruction, supported on all processors.

   The instruction `PUSH SP' may be used to distinguish an 8086 from
later processors: on an 8086, the value of `SP' stored is the value it
has _after_ the push instruction, whereas on later processors it is the
value _before_ the push instruction.


File: nasm.info,  Node: Section B.4.264,  Next: Section B.4.265,  Prev: Section B.4.263,  Up: Section B.4

B.4.264. `PUSHAx': Push All General-Purpose Registers
-----------------------------------------------------

     PUSHA                         ; 60                   [186]
     PUSHAD                        ; o32 60               [386]
     PUSHAW                        ; o16 60               [186]

   `PUSHAW' pushes, in succession, `AX', `CX', `DX', `BX', `SP', `BP',
`SI' and `DI' on the stack, decrementing the stack pointer by a total
of 16.

   `PUSHAD' pushes, in succession, `EAX', `ECX', `EDX', `EBX', `ESP',
`EBP', `ESI' and `EDI' on the stack, decrementing the stack pointer by
a total of 32.

   In both cases, the value of `SP' or `ESP' pushed is its _original_
value, as it had before the instruction was executed.

   `PUSHA' is an alias mnemonic for either `PUSHAW' or `PUSHAD',
depending on the current `BITS' setting.

   Note that the registers are pushed in order of their numeric values
in opcodes (see *Note Section B.2.1::).

   See also `POPA' (*Note Section B.4.245::).


File: nasm.info,  Node: Section B.4.265,  Next: Section B.4.266,  Prev: Section B.4.264,  Up: Section B.4

B.4.265. `PUSHFx': Push Flags Register
--------------------------------------

     PUSHF                         ; 9C                   [8086]
     PUSHFD                        ; o32 9C               [386]
     PUSHFW                        ; o16 9C               [8086]

   * `PUSHFW' pushes the bottom 16 bits of the flags register (or the
     whole flags register, on processors below a 386) onto the stack.

   * `PUSHFD' pushes the entire flags register onto the stack.

   `PUSHF' is an alias mnemonic for either `PUSHFW' or `PUSHFD',
depending on the current `BITS' setting.

   See also `POPF' (*Note Section B.4.246::).


File: nasm.info,  Node: Section B.4.266,  Next: Section B.4.267,  Prev: Section B.4.265,  Up: Section B.4

B.4.266. `PXOR': MMX Bitwise XOR
--------------------------------

     PXOR mm1,mm2/m64              ; 0F EF /r             [PENT,MMX]
     PXOR xmm1,xmm2/m128           ; 66 0F EF /r     [WILLAMETTE,SSE2]

   `PXOR' performs a bitwise XOR operation between its two operands
(i.e.  each bit of the result is 1 if and only if exactly one of the
corresponding bits of the two inputs was 1), and stores the result in
the destination (first) operand.


File: nasm.info,  Node: Section B.4.267,  Next: Section B.4.268,  Prev: Section B.4.266,  Up: Section B.4

B.4.267. `RCL', `RCR': Bitwise Rotate through Carry Bit
-------------------------------------------------------

     RCL r/m8,1                    ; D0 /2                [8086]
     RCL r/m8,CL                   ; D2 /2                [8086]
     RCL r/m8,imm8                 ; C0 /2 ib             [186]
     RCL r/m16,1                   ; o16 D1 /2            [8086]
     RCL r/m16,CL                  ; o16 D3 /2            [8086]
     RCL r/m16,imm8                ; o16 C1 /2 ib         [186]
     RCL r/m32,1                   ; o32 D1 /2            [386]
     RCL r/m32,CL                  ; o32 D3 /2            [386]
     RCL r/m32,imm8                ; o32 C1 /2 ib         [386]

     RCR r/m8,1                    ; D0 /3                [8086]
     RCR r/m8,CL                   ; D2 /3                [8086]
     RCR r/m8,imm8                 ; C0 /3 ib             [186]
     RCR r/m16,1                   ; o16 D1 /3            [8086]
     RCR r/m16,CL                  ; o16 D3 /3            [8086]
     RCR r/m16,imm8                ; o16 C1 /3 ib         [186]
     RCR r/m32,1                   ; o32 D1 /3            [386]
     RCR r/m32,CL                  ; o32 D3 /3            [386]
     RCR r/m32,imm8                ; o32 C1 /3 ib         [386]

   `RCL' and `RCR' perform a 9-bit, 17-bit or 33-bit bitwise rotation
operation, involving the given source/destination (first) operand and
the carry bit. Thus, for example, in the operation `RCL AL,1', a 9-bit
rotation is performed in which `AL' is shifted left by 1, the top bit
of `AL' moves into the carry flag, and the original value of the carry
flag is placed in the low bit of `AL'.

   The number of bits to rotate by is given by the second operand. Only
the bottom five bits of the rotation count are considered by processors
above the 8086.

   You can force the longer (286 and upwards, beginning with a `C1'
byte) form of `RCL foo,1' by using a `BYTE' prefix: `RCL foo,BYTE 1'.
Similarly with `RCR'.


File: nasm.info,  Node: Section B.4.268,  Next: Section B.4.269,  Prev: Section B.4.267,  Up: Section B.4

B.4.268. `RCPPS': Packed Single-Precision FP Reciprocal
-------------------------------------------------------

     RCPPS xmm1,xmm2/m128          ; 0F 53 /r        [KATMAI,SSE]

   `RCPPS' returns an approximation of the reciprocal of the packed
single-precision FP values from xmm2/m128. The maximum error for this
approximation is: |Error| <= 1.5 x 2^-12


File: nasm.info,  Node: Section B.4.269,  Next: Section B.4.270,  Prev: Section B.4.268,  Up: Section B.4

B.4.269. `RCPSS': Scalar Single-Precision FP Reciprocal
-------------------------------------------------------

     RCPSS xmm1,xmm2/m128          ; F3 0F 53 /r     [KATMAI,SSE]

   `RCPSS' returns an approximation of the reciprocal of the lower
single-precision FP value from xmm2/m32; the upper three fields are
passed through from xmm1. The maximum error for this approximation is:
|Error| <= 1.5 x 2^-12


File: nasm.info,  Node: Section B.4.270,  Next: Section B.4.271,  Prev: Section B.4.269,  Up: Section B.4

B.4.270. `RDMSR': Read Model-Specific Registers
-----------------------------------------------

     RDMSR                         ; 0F 32                [PENT,PRIV]

   `RDMSR' reads the processor Model-Specific Register (MSR) whose index
is stored in `ECX', and stores the result in `EDX:EAX'. See also
`WRMSR' (*Note Section B.4.329::).


File: nasm.info,  Node: Section B.4.271,  Next: Section B.4.272,  Prev: Section B.4.270,  Up: Section B.4

B.4.271. `RDPMC': Read Performance-Monitoring Counters
------------------------------------------------------

     RDPMC                         ; 0F 33                [P6]

   `RDPMC' reads the processor performance-monitoring counter whose
index is stored in `ECX', and stores the result in `EDX:EAX'.

   This instruction is available on P6 and later processors and on MMX
class processors.


File: nasm.info,  Node: Section B.4.272,  Next: Section B.4.273,  Prev: Section B.4.271,  Up: Section B.4

B.4.272. `RDSHR': Read SMM Header Pointer Register
--------------------------------------------------

     RDSHR r/m32                   ; 0F 36 /0        [386,CYRIX,SMM]

   `RDSHR' reads the contents of the SMM header pointer register and
saves it to the destination operand, which can be either a 32 bit memory
location or a 32 bit register.

   See also `WRSHR' (*Note Section B.4.330::).


File: nasm.info,  Node: Section B.4.273,  Next: Section B.4.274,  Prev: Section B.4.272,  Up: Section B.4

B.4.273. `RDTSC': Read Time-Stamp Counter
-----------------------------------------

     RDTSC                         ; 0F 31                [PENT]

   `RDTSC' reads the processor's time-stamp counter into `EDX:EAX'.


File: nasm.info,  Node: Section B.4.274,  Next: Section B.4.275,  Prev: Section B.4.273,  Up: Section B.4

B.4.274. `RET', `RETF', `RETN': Return from Procedure Call
----------------------------------------------------------

     RET                           ; C3                   [8086]
     RET imm16                     ; C2 iw                [8086]

     RETF                          ; CB                   [8086]
     RETF imm16                    ; CA iw                [8086]

     RETN                          ; C3                   [8086]
     RETN imm16                    ; C2 iw                [8086]

   * `RET', and its exact synonym `RETN', pop `IP' or `EIP' from the
     stack and transfer control to the new address. Optionally, if a
     numeric second operand is provided, they increment the stack
     pointer by a further `imm16' bytes after popping the return
     address.

   * `RETF' executes a far return: after popping `IP'/`EIP', it then
     pops `CS', and _then_ increments the stack pointer by the optional
     argument if present.


File: nasm.info,  Node: Section B.4.275,  Next: Section B.4.276,  Prev: Section B.4.274,  Up: Section B.4

B.4.275. `ROL', `ROR': Bitwise Rotate
-------------------------------------

     ROL r/m8,1                    ; D0 /0                [8086]
     ROL r/m8,CL                   ; D2 /0                [8086]
     ROL r/m8,imm8                 ; C0 /0 ib             [186]
     ROL r/m16,1                   ; o16 D1 /0            [8086]
     ROL r/m16,CL                  ; o16 D3 /0            [8086]
     ROL r/m16,imm8                ; o16 C1 /0 ib         [186]
     ROL r/m32,1                   ; o32 D1 /0            [386]
     ROL r/m32,CL                  ; o32 D3 /0            [386]
     ROL r/m32,imm8                ; o32 C1 /0 ib         [386]

     ROR r/m8,1                    ; D0 /1                [8086]
     ROR r/m8,CL                   ; D2 /1                [8086]
     ROR r/m8,imm8                 ; C0 /1 ib             [186]
     ROR r/m16,1                   ; o16 D1 /1            [8086]
     ROR r/m16,CL                  ; o16 D3 /1            [8086]
     ROR r/m16,imm8                ; o16 C1 /1 ib         [186]
     ROR r/m32,1                   ; o32 D1 /1            [386]
     ROR r/m32,CL                  ; o32 D3 /1            [386]
     ROR r/m32,imm8                ; o32 C1 /1 ib         [386]

   `ROL' and `ROR' perform a bitwise rotation operation on the given
source/destination (first) operand. Thus, for example, in the operation
`ROL AL,1', an 8-bit rotation is performed in which `AL' is shifted
left by 1 and the original top bit of `AL' moves round into the low bit.

   The number of bits to rotate by is given by the second operand. Only
the bottom five bits of the rotation count are considered by processors
above the 8086.

   You can force the longer (286 and upwards, beginning with a `C1'
byte) form of `ROL foo,1' by using a `BYTE' prefix: `ROL foo,BYTE 1'.
Similarly with `ROR'.


File: nasm.info,  Node: Section B.4.276,  Next: Section B.4.277,  Prev: Section B.4.275,  Up: Section B.4

B.4.276. `RSDC': Restore Segment Register and Descriptor
--------------------------------------------------------

     RSDC segreg,m80               ; 0F 79 /r        [486,CYRIX,SMM]

   `RSDC' restores a segment register (DS, ES, FS, GS, or SS) from
mem80, and sets up its descriptor.


File: nasm.info,  Node: Section B.4.277,  Next: Section B.4.278,  Prev: Section B.4.276,  Up: Section B.4

B.4.277. `RSLDT': Restore Segment Register and Descriptor
---------------------------------------------------------

     RSLDT m80                     ; 0F 7B /0        [486,CYRIX,SMM]

   `RSLDT' restores the Local Descriptor Table (LDTR) from mem80.


File: nasm.info,  Node: Section B.4.278,  Next: Section B.4.279,  Prev: Section B.4.277,  Up: Section B.4

B.4.278. `RSM': Resume from System-Management Mode
--------------------------------------------------

     RSM                           ; 0F AA                [PENT]

   `RSM' returns the processor to its normal operating mode when it was
in System-Management Mode.


File: nasm.info,  Node: Section B.4.279,  Next: Section B.4.280,  Prev: Section B.4.278,  Up: Section B.4

B.4.279. `RSQRTPS': Packed Single-Precision FP Square Root Reciprocal
---------------------------------------------------------------------

     RSQRTPS xmm1,xmm2/m128        ; 0F 52 /r        [KATMAI,SSE]

   `RSQRTPS' computes the approximate reciprocals of the square roots of
the packed single-precision floating-point values in the source and
stores the results in xmm1. The maximum error for this approximation
is: |Error| <= 1.5 x 2^-12


File: nasm.info,  Node: Section B.4.280,  Next: Section B.4.281,  Prev: Section B.4.279,  Up: Section B.4

B.4.280. `RSQRTSS': Scalar Single-Precision FP Square Root Reciprocal
---------------------------------------------------------------------

     RSQRTSS xmm1,xmm2/m128        ; F3 0F 52 /r     [KATMAI,SSE]

   `RSQRTSS' returns an approximation of the reciprocal of the square
root of the lowest order single-precision FP value from the source, and
stores it in the low doubleword of the destination register. The upper
three fields of xmm1 are preserved. The maximum error for this
approximation is: |Error| <= 1.5 x 2^-12


File: nasm.info,  Node: Section B.4.281,  Next: Section B.4.282,  Prev: Section B.4.280,  Up: Section B.4

B.4.281. `RSTS': Restore TSR and Descriptor
-------------------------------------------

     RSTS m80                      ; 0F 7D /0        [486,CYRIX,SMM]

   `RSTS' restores Task State Register (TSR) from mem80.


File: nasm.info,  Node: Section B.4.282,  Next: Section B.4.283,  Prev: Section B.4.281,  Up: Section B.4

B.4.282. `SAHF': Store AH to Flags
----------------------------------

     SAHF                          ; 9E                   [8086]

   `SAHF' sets the low byte of the flags word according to the contents
of the `AH' register.

   The operation of `SAHF' is:

      AH --> SF:ZF:0:AF:0:PF:1:CF

   See also `LAHF' (*Note Section B.4.131::).


File: nasm.info,  Node: Section B.4.283,  Next: Section B.4.284,  Prev: Section B.4.282,  Up: Section B.4

B.4.283. `SAL', `SAR': Bitwise Arithmetic Shifts
------------------------------------------------

     SAL r/m8,1                    ; D0 /4                [8086]
     SAL r/m8,CL                   ; D2 /4                [8086]
     SAL r/m8,imm8                 ; C0 /4 ib             [186]
     SAL r/m16,1                   ; o16 D1 /4            [8086]
     SAL r/m16,CL                  ; o16 D3 /4            [8086]
     SAL r/m16,imm8                ; o16 C1 /4 ib         [186]
     SAL r/m32,1                   ; o32 D1 /4            [386]
     SAL r/m32,CL                  ; o32 D3 /4            [386]
     SAL r/m32,imm8                ; o32 C1 /4 ib         [386]

     SAR r/m8,1                    ; D0 /7                [8086]
     SAR r/m8,CL                   ; D2 /7                [8086]
     SAR r/m8,imm8                 ; C0 /7 ib             [186]
     SAR r/m16,1                   ; o16 D1 /7            [8086]
     SAR r/m16,CL                  ; o16 D3 /7            [8086]
     SAR r/m16,imm8                ; o16 C1 /7 ib         [186]
     SAR r/m32,1                   ; o32 D1 /7            [386]
     SAR r/m32,CL                  ; o32 D3 /7            [386]
     SAR r/m32,imm8                ; o32 C1 /7 ib         [386]

   `SAL' and `SAR' perform an arithmetic shift operation on the given
source/destination (first) operand. The vacated bits are filled with
zero for `SAL', and with copies of the original high bit of the source
operand for `SAR'.

   `SAL' is a synonym for `SHL' (see *Note Section B.4.290::). NASM
will assemble either one to the same code, but NDISASM will always
disassemble that code as `SHL'.

   The number of bits to shift by is given by the second operand. Only
the bottom five bits of the shift count are considered by processors
above the 8086.

   You can force the longer (286 and upwards, beginning with a `C1'
byte) form of `SAL foo,1' by using a `BYTE' prefix: `SAL foo,BYTE 1'.
Similarly with `SAR'.


File: nasm.info,  Node: Section B.4.284,  Next: Section B.4.285,  Prev: Section B.4.283,  Up: Section B.4

B.4.284. `SALC': Set AL from Carry Flag
---------------------------------------

     SALC                          ; D6                  [8086,UNDOC]

   `SALC' is an early undocumented instruction similar in concept to
`SETcc' (*Note Section B.4.287::). Its function is to set `AL' to zero
if the carry flag is clear, or to `0xFF' if it is set.


File: nasm.info,  Node: Section B.4.285,  Next: Section B.4.286,  Prev: Section B.4.284,  Up: Section B.4

B.4.285. `SBB': Subtract with Borrow
------------------------------------

     SBB r/m8,reg8                 ; 18 /r                [8086]
     SBB r/m16,reg16               ; o16 19 /r            [8086]
     SBB r/m32,reg32               ; o32 19 /r            [386]

     SBB reg8,r/m8                 ; 1A /r                [8086]
     SBB reg16,r/m16               ; o16 1B /r            [8086]
     SBB reg32,r/m32               ; o32 1B /r            [386]

     SBB r/m8,imm8                 ; 80 /3 ib             [8086]
     SBB r/m16,imm16               ; o16 81 /3 iw         [8086]
     SBB r/m32,imm32               ; o32 81 /3 id         [386]

     SBB r/m16,imm8                ; o16 83 /3 ib         [8086]
     SBB r/m32,imm8                ; o32 83 /3 ib         [386]

     SBB AL,imm8                   ; 1C ib                [8086]
     SBB AX,imm16                  ; o16 1D iw            [8086]
     SBB EAX,imm32                 ; o32 1D id            [386]

   `SBB' performs integer subtraction: it subtracts its second operand,
plus the value of the carry flag, from its first, and leaves the result
in its destination (first) operand. The flags are set according to the
result of the operation: in particular, the carry flag is affected and
can be used by a subsequent `SBB' instruction.

   In the forms with an 8-bit immediate second operand and a longer
first operand, the second operand is considered to be signed, and is
sign- extended to the length of the first operand. In these cases, the
`BYTE' qualifier is necessary to force NASM to generate this form of
the instruction.

   To subtract one number from another without also subtracting the
contents of the carry flag, use `SUB' (*Note Section B.4.305::).


File: nasm.info,  Node: Section B.4.286,  Next: Section B.4.287,  Prev: Section B.4.285,  Up: Section B.4

B.4.286. `SCASB', `SCASW', `SCASD': Scan String
-----------------------------------------------

     SCASB                         ; AE                   [8086]
     SCASW                         ; o16 AF               [8086]
     SCASD                         ; o32 AF               [386]

   `SCASB' compares the byte in `AL' with the byte at `[ES:DI]' or
`[ES:EDI]', and sets the flags accordingly. It then increments or
decrements (depending on the direction flag: increments if the flag is
clear, decrements if it is set) `DI' (or `EDI').

   The register used is `DI' if the address size is 16 bits, and `EDI'
if it is 32 bits. If you need to use an address size not equal to the
current `BITS' setting, you can use an explicit `a16' or `a32' prefix.

   Segment override prefixes have no effect for this instruction: the
use of `ES' for the load from `[DI]' or `[EDI]' cannot be overridden.

   `SCASW' and `SCASD' work in the same way, but they compare a word to
`AX' or a doubleword to `EAX' instead of a byte to `AL', and increment
or decrement the addressing registers by 2 or 4 instead of 1.

   The `REPE' and `REPNE' prefixes (equivalently, `REPZ' and `REPNZ')
may be used to repeat the instruction up to `CX' (or `ECX' - again, the
address size chooses which) times until the first unequal or equal byte
is found.


File: nasm.info,  Node: Section B.4.287,  Next: Section B.4.288,  Prev: Section B.4.286,  Up: Section B.4

B.4.287. `SETcc': Set Register from Condition
---------------------------------------------

     SETcc r/m8                    ; 0F 90+cc /2          [386]

   `SETcc' sets the given 8-bit operand to zero if its condition is not
satisfied, and to 1 if it is.


File: nasm.info,  Node: Section B.4.288,  Next: Section B.4.289,  Prev: Section B.4.287,  Up: Section B.4

B.4.288. `SFENCE': Store Fence
------------------------------

     SFENCE                 ; 0F AE /7               [KATMAI]

   `SFENCE' performs a serialising operation on all writes to memory
that were issued before the `SFENCE' instruction. This guarantees that
all memory writes before the `SFENCE' instruction are visible before any
writes after the `SFENCE' instruction.

   `SFENCE' is ordered respective to other `SFENCE' instruction,
`MFENCE', any memory write and any other serialising instruction (such
as `CPUID').

   Weakly ordered memory types can be used to achieve higher processor
performance through such techniques as out-of-order issue,
write-combining, and write-collapsing. The degree to which a consumer
of data recognizes or knows that the data is weakly ordered varies
among applications and may be unknown to the producer of this data. The
`SFENCE' instruction provides a performance-efficient way of insuring
store ordering between routines that produce weakly-ordered results and
routines that consume this data.

   `SFENCE' uses the following ModRM encoding:

               Mod (7:6)        = 11B
               Reg/Opcode (5:3) = 111B
               R/M (2:0)        = 000B

   All other ModRM encodings are defined to be reserved, and use of
these encodings risks incompatibility with future processors.

   See also `LFENCE' (*Note Section B.4.137::) and `MFENCE' (*Note
Section B.4.151::).


File: nasm.info,  Node: Section B.4.289,  Next: Section B.4.290,  Prev: Section B.4.288,  Up: Section B.4

B.4.289. `SGDT', `SIDT', `SLDT': Store Descriptor Table Pointers
----------------------------------------------------------------

     SGDT mem                      ; 0F 01 /0             [286,PRIV]
     SIDT mem                      ; 0F 01 /1             [286,PRIV]
     SLDT r/m16                    ; 0F 00 /0             [286,PRIV]

   `SGDT' and `SIDT' both take a 6-byte memory area as an operand: they
store the contents of the GDTR (global descriptor table register) or
IDTR (interrupt descriptor table register) into that area as a 32-bit
linear address and a 16-bit size limit from that area (in that order).
These are the only instructions which directly use _linear_ addresses,
rather than segment/offset pairs.

   `SLDT' stores the segment selector corresponding to the LDT (local
descriptor table) into the given operand.

   See also `LGDT', `LIDT' and `LLDT' (*Note Section B.4.138::).


File: nasm.info,  Node: Section B.4.290,  Next: Section B.4.291,  Prev: Section B.4.289,  Up: Section B.4

B.4.290. `SHL', `SHR': Bitwise Logical Shifts
---------------------------------------------

     SHL r/m8,1                    ; D0 /4                [8086]
     SHL r/m8,CL                   ; D2 /4                [8086]
     SHL r/m8,imm8                 ; C0 /4 ib             [186]
     SHL r/m16,1                   ; o16 D1 /4            [8086]
     SHL r/m16,CL                  ; o16 D3 /4            [8086]
     SHL r/m16,imm8                ; o16 C1 /4 ib         [186]
     SHL r/m32,1                   ; o32 D1 /4            [386]
     SHL r/m32,CL                  ; o32 D3 /4            [386]
     SHL r/m32,imm8                ; o32 C1 /4 ib         [386]

     SHR r/m8,1                    ; D0 /5                [8086]
     SHR r/m8,CL                   ; D2 /5                [8086]
     SHR r/m8,imm8                 ; C0 /5 ib             [186]
     SHR r/m16,1                   ; o16 D1 /5            [8086]
     SHR r/m16,CL                  ; o16 D3 /5            [8086]
     SHR r/m16,imm8                ; o16 C1 /5 ib         [186]
     SHR r/m32,1                   ; o32 D1 /5            [386]
     SHR r/m32,CL                  ; o32 D3 /5            [386]
     SHR r/m32,imm8                ; o32 C1 /5 ib         [386]

   `SHL' and `SHR' perform a logical shift operation on the given
source/destination (first) operand. The vacated bits are filled with
zero.

   A synonym for `SHL' is `SAL' (see *Note Section B.4.283::). NASM
will assemble either one to the same code, but NDISASM will always
disassemble that code as `SHL'.

   The number of bits to shift by is given by the second operand. Only
the bottom five bits of the shift count are considered by processors
above the 8086.

   You can force the longer (286 and upwards, beginning with a `C1'
byte) form of `SHL foo,1' by using a `BYTE' prefix: `SHL foo,BYTE 1'.
Similarly with `SHR'.


File: nasm.info,  Node: Section B.4.291,  Next: Section B.4.292,  Prev: Section B.4.290,  Up: Section B.4

B.4.291. `SHLD', `SHRD': Bitwise Double-Precision Shifts
--------------------------------------------------------

     SHLD r/m16,reg16,imm8         ; o16 0F A4 /r ib      [386]
     SHLD r/m16,reg32,imm8         ; o32 0F A4 /r ib      [386]
     SHLD r/m16,reg16,CL           ; o16 0F A5 /r         [386]
     SHLD r/m16,reg32,CL           ; o32 0F A5 /r         [386]

     SHRD r/m16,reg16,imm8         ; o16 0F AC /r ib      [386]
     SHRD r/m32,reg32,imm8         ; o32 0F AC /r ib      [386]
     SHRD r/m16,reg16,CL           ; o16 0F AD /r         [386]
     SHRD r/m32,reg32,CL           ; o32 0F AD /r         [386]

   * `SHLD' performs a double-precision left shift. It notionally places
     its second operand to the right of its first, then shifts the
     entire bit string thus generated to the left by a number of bits
     specified in the third operand. It then updates only the _first_
     operand according to the result of this. The second operand is not
     modified.

   * `SHRD' performs the corresponding right shift: it notionally places
     the second operand to the _left_ of the first, shifts the whole bit
     string right, and updates only the first operand.

   For example, if `EAX' holds `0x01234567' and `EBX' holds
`0x89ABCDEF', then the instruction `SHLD EAX,EBX,4' would update `EAX'
to hold `0x12345678'. Under the same conditions, `SHRD EAX,EBX,4' would
update `EAX' to hold `0xF0123456'.

   The number of bits to shift by is given by the third operand. Only
the bottom five bits of the shift count are considered.


File: nasm.info,  Node: Section B.4.292,  Next: Section B.4.293,  Prev: Section B.4.291,  Up: Section B.4

B.4.292. `SHUFPD': Shuffle Packed Double-Precision FP Values
------------------------------------------------------------

     SHUFPD xmm1,xmm2/m128,imm8    ; 66 0F C6 /r ib  [WILLAMETTE,SSE2]

   `SHUFPD' moves one of the packed double-precision FP values from the
destination operand into the low quadword of the destination operand;
the upper quadword is generated by moving one of the double-precision
FP values from the source operand into the destination. The select
(third) operand selects which of the values are moved to the
destination register.

   The select operand is an 8-bit immediate: bit 0 selects which value
is moved from the destination operand to the result (where 0 selects
the low quadword and 1 selects the high quadword) and bit 1 selects
which value is moved from the source operand to the result. Bits 2
through 7 of the shuffle operand are reserved.


File: nasm.info,  Node: Section B.4.293,  Next: Section B.4.294,  Prev: Section B.4.292,  Up: Section B.4

B.4.293. `SHUFPS': Shuffle Packed Single-Precision FP Values
------------------------------------------------------------

     SHUFPS xmm1,xmm2/m128,imm8    ; 0F C6 /r ib     [KATMAI,SSE]

   `SHUFPS' moves two of the packed single-precision FP values from the
destination operand into the low quadword of the destination operand;
the upper quadword is generated by moving two of the single-precision
FP values from the source operand into the destination. The select
(third) operand selects which of the values are moved to the
destination register.

   The select operand is an 8-bit immediate: bits 0 and 1 select the
value to be moved from the destination operand the low doubleword of
the result, bits 2 and 3 select the value to be moved from the
destination operand the second doubleword of the result, bits 4 and 5
select the value to be moved from the source operand the third
doubleword of the result, and bits 6 and 7 select the value to be moved
from the source operand to the high doubleword of the result.


File: nasm.info,  Node: Section B.4.294,  Next: Section B.4.295,  Prev: Section B.4.293,  Up: Section B.4

B.4.294. `SMI': System Management Interrupt
-------------------------------------------

     SMI                           ; F1                   [386,UNDOC]

   `SMI' puts some AMD processors into SMM mode. It is available on some
386 and 486 processors, and is only available when DR7 bit 12 is set,
otherwise it generates an Int 1.


File: nasm.info,  Node: Section B.4.295,  Next: Section B.4.296,  Prev: Section B.4.294,  Up: Section B.4

B.4.295. `SMINT', `SMINTOLD': Software SMM Entry (CYRIX)
--------------------------------------------------------

     SMINT                         ; 0F 38                [PENT,CYRIX]
     SMINTOLD                      ; 0F 7E                [486,CYRIX]

   `SMINT' puts the processor into SMM mode. The CPU state information
is saved in the SMM memory header, and then execution begins at the SMM
base address.

   `SMINTOLD' is the same as `SMINT', but was the opcode used on the
486.

   This pair of opcodes are specific to the Cyrix and compatible range
of processors (Cyrix, IBM, Via).


File: nasm.info,  Node: Section B.4.296,  Next: Section B.4.297,  Prev: Section B.4.295,  Up: Section B.4

B.4.296. `SMSW': Store Machine Status Word
------------------------------------------

     SMSW r/m16                    ; 0F 01 /4             [286,PRIV]

   `SMSW' stores the bottom half of the `CR0' control register (or the
Machine Status Word, on 286 processors) into the destination operand.
See also `LMSW' (*Note Section B.4.139::).

   For 32-bit code, this would store all of `CR0' in the specified
register (or the bottom 16 bits if the destination is a memory
location), without needing an operand size override byte.


File: nasm.info,  Node: Section B.4.297,  Next: Section B.4.298,  Prev: Section B.4.296,  Up: Section B.4

B.4.297. `SQRTPD': Packed Double-Precision FP Square Root
---------------------------------------------------------

     SQRTPD xmm1,xmm2/m128         ; 66 0F 51 /r     [WILLAMETTE,SSE2]

   `SQRTPD' calculates the square root of the packed double-precision FP
value from the source operand, and stores the double-precision results
in the destination register.


File: nasm.info,  Node: Section B.4.298,  Next: Section B.4.299,  Prev: Section B.4.297,  Up: Section B.4

B.4.298. `SQRTPS': Packed Single-Precision FP Square Root
---------------------------------------------------------

     SQRTPS xmm1,xmm2/m128         ; 0F 51 /r        [KATMAI,SSE]

   `SQRTPS' calculates the square root of the packed single-precision FP
value from the source operand, and stores the single-precision results
in the destination register.


File: nasm.info,  Node: Section B.4.299,  Next: Section B.4.300,  Prev: Section B.4.298,  Up: Section B.4

B.4.299. `SQRTSD': Scalar Double-Precision FP Square Root
---------------------------------------------------------

     SQRTSD xmm1,xmm2/m128         ; F2 0F 51 /r     [WILLAMETTE,SSE2]

   `SQRTSD' calculates the square root of the low-order double-precision
FP value from the source operand, and stores the double-precision
result in the destination register. The high-quadword remains unchanged.


File: nasm.info,  Node: Section B.4.300,  Next: Section B.4.301,  Prev: Section B.4.299,  Up: Section B.4

B.4.300. `SQRTSS': Scalar Single-Precision FP Square Root
---------------------------------------------------------

     SQRTSS xmm1,xmm2/m128         ; F3 0F 51 /r     [KATMAI,SSE]

   `SQRTSS' calculates the square root of the low-order single-precision
FP value from the source operand, and stores the single-precision
result in the destination register. The three high doublewords remain
unchanged.


File: nasm.info,  Node: Section B.4.301,  Next: Section B.4.302,  Prev: Section B.4.300,  Up: Section B.4

B.4.301. `STC', `STD', `STI': Set Flags
---------------------------------------

     STC                           ; F9                   [8086]
     STD                           ; FD                   [8086]
     STI                           ; FB                   [8086]

   These instructions set various flags. `STC' sets the carry flag;
`STD' sets the direction flag; and `STI' sets the interrupt flag (thus
enabling interrupts).

   To clear the carry, direction, or interrupt flags, use the `CLC',
`CLD' and `CLI' instructions (*Note Section B.4.20::). To invert the
carry flag, use `CMC' (*Note Section B.4.22::).


File: nasm.info,  Node: Section B.4.302,  Next: Section B.4.303,  Prev: Section B.4.301,  Up: Section B.4

B.4.302. `STMXCSR': Store Streaming SIMD Extension Control/Status
-----------------------------------------------------------------

     STMXCSR m32                   ; 0F AE /3        [KATMAI,SSE]

   `STMXCSR' stores the contents of the `MXCSR' control/status register
to the specified memory location. `MXCSR' is used to enable
masked/unmasked exception handling, to set rounding modes, to set
flush-to- zero mode, and to view exception status flags. The reserved
bits in the `MXCSR' register are stored as 0s.

   For details of the `MXCSR' register, see the Intel processor docs.

   See also `LDMXCSR' (*Note Section B.4.133::).

